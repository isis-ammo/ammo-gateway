/* soapC.cpp
   Generated by gSOAP 2.7.17 from ContentService.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.17 2010-09-09 17:22:48 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE__ns2__OrganizationType_UsageStatus:
		return soap_in__ns2__OrganizationType_UsageStatus(soap, NULL, NULL, "ns2:OrganizationType-UsageStatus");
	case SOAP_TYPE__ns2__DetailedPlaceInfoType_UsageStatus:
		return soap_in__ns2__DetailedPlaceInfoType_UsageStatus(soap, NULL, NULL, "ns2:DetailedPlaceInfoType-UsageStatus");
	case SOAP_TYPE__ns2__DeleteResponseType_status:
		return soap_in__ns2__DeleteResponseType_status(soap, NULL, NULL, "ns2:DeleteResponseType-status");
	case SOAP_TYPE__ns2__UpdateResponseType_status:
		return soap_in__ns2__UpdateResponseType_status(soap, NULL, NULL, "ns2:UpdateResponseType-status");
	case SOAP_TYPE_ns3__MediaFileFormType:
		return soap_in_ns3__MediaFileFormType(soap, NULL, NULL, "ns3:MediaFileFormType");
	case SOAP_TYPE_ns2__ReinforcementStatusType:
		return soap_in_ns2__ReinforcementStatusType(soap, NULL, NULL, "ns2:ReinforcementStatusType");
	case SOAP_TYPE_ns2__TrainingStatusType:
		return soap_in_ns2__TrainingStatusType(soap, NULL, NULL, "ns2:TrainingStatusType");
	case SOAP_TYPE_ns2__CBRNDressStatusType:
		return soap_in_ns2__CBRNDressStatusType(soap, NULL, NULL, "ns2:CBRNDressStatusType");
	case SOAP_TYPE_ns2__ReadinessType:
		return soap_in_ns2__ReadinessType(soap, NULL, NULL, "ns2:ReadinessType");
	case SOAP_TYPE_ns2__CommitmentStatusType:
		return soap_in_ns2__CommitmentStatusType(soap, NULL, NULL, "ns2:CommitmentStatusType");
	case SOAP_TYPE_ns2__AvailabilityType:
		return soap_in_ns2__AvailabilityType(soap, NULL, NULL, "ns2:AvailabilityType");
	case SOAP_TYPE_ns2__GroupPeopleType:
		return soap_in_ns2__GroupPeopleType(soap, NULL, NULL, "ns2:GroupPeopleType");
	case SOAP_TYPE_ns2__CommandAndControlType:
		return soap_in_ns2__CommandAndControlType(soap, NULL, NULL, "ns2:CommandAndControlType");
	case SOAP_TYPE_ns2__SecurityStatusType:
		return soap_in_ns2__SecurityStatusType(soap, NULL, NULL, "ns2:SecurityStatusType");
	case SOAP_TYPE_ns2__EnemyActivityPresentType:
		return soap_in_ns2__EnemyActivityPresentType(soap, NULL, NULL, "ns2:EnemyActivityPresentType");
	case SOAP_TYPE_ns2__ConstructionType:
		return soap_in_ns2__ConstructionType(soap, NULL, NULL, "ns2:ConstructionType");
	case SOAP_TYPE_ns2__OccupationStatusType:
		return soap_in_ns2__OccupationStatusType(soap, NULL, NULL, "ns2:OccupationStatusType");
	case SOAP_TYPE_ns2__MinistryType:
		return soap_in_ns2__MinistryType(soap, NULL, NULL, "ns2:MinistryType");
	case SOAP_TYPE_ns2__LineOfOperationType:
		return soap_in_ns2__LineOfOperationType(soap, NULL, NULL, "ns2:LineOfOperationType");
	case SOAP_TYPE_ns2__MissionType:
		return soap_in_ns2__MissionType(soap, NULL, NULL, "ns2:MissionType");
	case SOAP_TYPE_ns2__KeywordType:
		return soap_in_ns2__KeywordType(soap, NULL, NULL, "ns2:KeywordType");
	case SOAP_TYPE_ns2__AnalyticalToolMethodType:
		return soap_in_ns2__AnalyticalToolMethodType(soap, NULL, NULL, "ns2:AnalyticalToolMethodType");
	case SOAP_TYPE_ns2__DataCollectionMethodType:
		return soap_in_ns2__DataCollectionMethodType(soap, NULL, NULL, "ns2:DataCollectionMethodType");
	case SOAP_TYPE_ns2__ProductType:
		return soap_in_ns2__ProductType(soap, NULL, NULL, "ns2:ProductType");
	case SOAP_TYPE_ns2__SomaliaProvinceType:
		return soap_in_ns2__SomaliaProvinceType(soap, NULL, NULL, "ns2:SomaliaProvinceType");
	case SOAP_TYPE_ns2__EthiopiaProvinceType:
		return soap_in_ns2__EthiopiaProvinceType(soap, NULL, NULL, "ns2:EthiopiaProvinceType");
	case SOAP_TYPE_ns2__DijiboutiProvinceType:
		return soap_in_ns2__DijiboutiProvinceType(soap, NULL, NULL, "ns2:DijiboutiProvinceType");
	case SOAP_TYPE_ns2__EritreaProvinceType:
		return soap_in_ns2__EritreaProvinceType(soap, NULL, NULL, "ns2:EritreaProvinceType");
	case SOAP_TYPE_ns2__IraqProvinceType:
		return soap_in_ns2__IraqProvinceType(soap, NULL, NULL, "ns2:IraqProvinceType");
	case SOAP_TYPE_ns2__AfghanistanProvinceType:
		return soap_in_ns2__AfghanistanProvinceType(soap, NULL, NULL, "ns2:AfghanistanProvinceType");
	case SOAP_TYPE_ns2__CountryType:
		return soap_in_ns2__CountryType(soap, NULL, NULL, "ns2:CountryType");
	case SOAP_TYPE_ns2__JustificationType:
		return soap_in_ns2__JustificationType(soap, NULL, NULL, "ns2:JustificationType");
	case SOAP_TYPE_ns2__RoleType:
		return soap_in_ns2__RoleType(soap, NULL, NULL, "ns2:RoleType");
	case SOAP_TYPE_ns2__WritingHandType:
		return soap_in_ns2__WritingHandType(soap, NULL, NULL, "ns2:WritingHandType");
	case SOAP_TYPE_ns2__MannerOfDressType:
		return soap_in_ns2__MannerOfDressType(soap, NULL, NULL, "ns2:MannerOfDressType");
	case SOAP_TYPE_ns2__BuildType:
		return soap_in_ns2__BuildType(soap, NULL, NULL, "ns2:BuildType");
	case SOAP_TYPE_ns2__HairColorType:
		return soap_in_ns2__HairColorType(soap, NULL, NULL, "ns2:HairColorType");
	case SOAP_TYPE_ns2__EyeColorType:
		return soap_in_ns2__EyeColorType(soap, NULL, NULL, "ns2:EyeColorType");
	case SOAP_TYPE_ns2__PoliticalStanceType:
		return soap_in_ns2__PoliticalStanceType(soap, NULL, NULL, "ns2:PoliticalStanceType");
	case SOAP_TYPE_ns2__PhysicalStatus2Type:
		return soap_in_ns2__PhysicalStatus2Type(soap, NULL, NULL, "ns2:PhysicalStatus2Type");
	case SOAP_TYPE_ns2__PhysicalStatusType:
		return soap_in_ns2__PhysicalStatusType(soap, NULL, NULL, "ns2:PhysicalStatusType");
	case SOAP_TYPE_ns2__DutyStatusType:
		return soap_in_ns2__DutyStatusType(soap, NULL, NULL, "ns2:DutyStatusType");
	case SOAP_TYPE_ns2__RankType:
		return soap_in_ns2__RankType(soap, NULL, NULL, "ns2:RankType");
	case SOAP_TYPE_ns2__PeopleType2Type:
		return soap_in_ns2__PeopleType2Type(soap, NULL, NULL, "ns2:PeopleType2Type");
	case SOAP_TYPE_ns2__PeopleTypeType:
		return soap_in_ns2__PeopleTypeType(soap, NULL, NULL, "ns2:PeopleTypeType");
	case SOAP_TYPE_ns2__GenderType:
		return soap_in_ns2__GenderType(soap, NULL, NULL, "ns2:GenderType");
	case SOAP_TYPE_ns2__YesNoType:
		return soap_in_ns2__YesNoType(soap, NULL, NULL, "ns2:YesNoType");
	case SOAP_TYPE_ns2__OperationalStatus2Type:
		return soap_in_ns2__OperationalStatus2Type(soap, NULL, NULL, "ns2:OperationalStatus2Type");
	case SOAP_TYPE_ns2__OperationalStatusType:
		return soap_in_ns2__OperationalStatusType(soap, NULL, NULL, "ns2:OperationalStatusType");
	case SOAP_TYPE_ns2__ReleasabilityType:
		return soap_in_ns2__ReleasabilityType(soap, NULL, NULL, "ns2:ReleasabilityType");
	case SOAP_TYPE_ns2__ClassificationType:
		return soap_in_ns2__ClassificationType(soap, NULL, NULL, "ns2:ClassificationType");
	case SOAP_TYPE_ns2__CategoryValueType:
		return soap_in_ns2__CategoryValueType(soap, NULL, NULL, "ns2:CategoryValueType");
	case SOAP_TYPE_ns2__UnitValueType:
		return soap_in_ns2__UnitValueType(soap, NULL, NULL, "ns2:UnitValueType");
	case SOAP_TYPE_ns2__CardinalityType:
		return soap_in_ns2__CardinalityType(soap, NULL, NULL, "ns2:CardinalityType");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_in__wsa5__IsReferenceParameter(soap, NULL, NULL, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_in_wsa5__FaultCodesType(soap, NULL, NULL, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_in_wsa5__RelationshipType(soap, NULL, NULL, "wsa5:RelationshipType");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_in_wsu__tTimestampFault(soap, NULL, NULL, "wsu:tTimestampFault");
	case SOAP_TYPE_ns3__VersionType:
		return soap_in_ns3__VersionType(soap, NULL, NULL, "ns3:VersionType");
	case SOAP_TYPE_ns3__GuidType:
		return soap_in_ns3__GuidType(soap, NULL, NULL, "ns3:GuidType");
	case SOAP_TYPE_ns3__MimeType:
		return soap_in_ns3__MimeType(soap, NULL, NULL, "ns3:MimeType");
	case SOAP_TYPE_ns3__NonEmptyStringType:
		return soap_in_ns3__NonEmptyStringType(soap, NULL, NULL, "ns3:NonEmptyStringType");
	case SOAP_TYPE_ns3__CoordinatesType:
		return soap_in_ns3__CoordinatesType(soap, NULL, NULL, "ns3:CoordinatesType");
	case SOAP_TYPE_ns3__URIListType:
		return soap_in_ns3__URIListType(soap, NULL, NULL, "ns3:URIListType");
	case SOAP_TYPE_ns3__QNameListType:
		return soap_in_ns3__QNameListType(soap, NULL, NULL, "ns3:QNameListType");
	case SOAP_TYPE_ns3__PolygonType:
		return soap_in_ns3__PolygonType(soap, NULL, NULL, "ns3:PolygonType");
	case SOAP_TYPE_ns3__LinearRingType:
		return soap_in_ns3__LinearRingType(soap, NULL, NULL, "ns3:LinearRingType");
	case SOAP_TYPE_ns3__LineStringType:
		return soap_in_ns3__LineStringType(soap, NULL, NULL, "ns3:LineStringType");
	case SOAP_TYPE_ns3__PointType:
		return soap_in_ns3__PointType(soap, NULL, NULL, "ns3:PointType");
	case SOAP_TYPE_ns3__AbstractGeometryType:
		return soap_in_ns3__AbstractGeometryType(soap, NULL, NULL, "ns3:AbstractGeometryType");
	case SOAP_TYPE_ns3__EnvelopeType:
		return soap_in_ns3__EnvelopeType(soap, NULL, NULL, "ns3:EnvelopeType");
	case SOAP_TYPE_ns3__GetCapabilitiesType:
		return soap_in_ns3__GetCapabilitiesType(soap, NULL, NULL, "ns3:GetCapabilitiesType");
	case SOAP_TYPE_ns3__BaseServiceCapabilitiesType:
		return soap_in_ns3__BaseServiceCapabilitiesType(soap, NULL, NULL, "ns3:BaseServiceCapabilitiesType");
	case SOAP_TYPE_ns3__BaseRequestType:
		return soap_in_ns3__BaseRequestType(soap, NULL, NULL, "ns3:BaseRequestType");
	case SOAP_TYPE_ns3__TimePeriodType:
		return soap_in_ns3__TimePeriodType(soap, NULL, NULL, "ns3:TimePeriodType");
	case SOAP_TYPE_ns2__OrganizationType:
		return soap_in_ns2__OrganizationType(soap, NULL, NULL, "ns2:OrganizationType");
	case SOAP_TYPE_ns2__SpecialCollectionType:
		return soap_in_ns2__SpecialCollectionType(soap, NULL, NULL, "ns2:SpecialCollectionType");
	case SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType:
		return soap_in_ns2__SpecialCollectionUserPropertiesType(soap, NULL, NULL, "ns2:SpecialCollectionUserPropertiesType");
	case SOAP_TYPE_ns2__DetailedPlaceInfoType:
		return soap_in_ns2__DetailedPlaceInfoType(soap, NULL, NULL, "ns2:DetailedPlaceInfoType");
	case SOAP_TYPE_ns2__SpecialPlaceType:
		return soap_in_ns2__SpecialPlaceType(soap, NULL, NULL, "ns2:SpecialPlaceType");
	case SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType:
		return soap_in_ns2__SpecialPlaceUserPropertiesType(soap, NULL, NULL, "ns2:SpecialPlaceUserPropertiesType");
	case SOAP_TYPE_ns2__UpcomingEventType:
		return soap_in_ns2__UpcomingEventType(soap, NULL, NULL, "ns2:UpcomingEventType");
	case SOAP_TYPE_ns2__UpcomingEventsType:
		return soap_in_ns2__UpcomingEventsType(soap, NULL, NULL, "ns2:UpcomingEventsType");
	case SOAP_TYPE_ns2__AssessmentsType:
		return soap_in_ns2__AssessmentsType(soap, NULL, NULL, "ns2:AssessmentsType");
	case SOAP_TYPE_ns2__PEMSIIOutcomeType:
		return soap_in_ns2__PEMSIIOutcomeType(soap, NULL, NULL, "ns2:PEMSIIOutcomeType");
	case SOAP_TYPE_ns2__PEMSIIOutcomesType:
		return soap_in_ns2__PEMSIIOutcomesType(soap, NULL, NULL, "ns2:PEMSIIOutcomesType");
	case SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType:
		return soap_in_ns2__CIDNE_USCORECMODailyReportType(soap, NULL, NULL, "ns2:CIDNE_CMODailyReportType");
	case SOAP_TYPE_ns2__HTSAreaAssessmentType:
		return soap_in_ns2__HTSAreaAssessmentType(soap, NULL, NULL, "ns2:HTSAreaAssessmentType");
	case SOAP_TYPE_ns2__RemarkType:
		return soap_in_ns2__RemarkType(soap, NULL, NULL, "ns2:RemarkType");
	case SOAP_TYPE_ns2__LocationInfoType:
		return soap_in_ns2__LocationInfoType(soap, NULL, NULL, "ns2:LocationInfoType");
	case SOAP_TYPE_ns2__FamilyMemberInfoType:
		return soap_in_ns2__FamilyMemberInfoType(soap, NULL, NULL, "ns2:FamilyMemberInfoType");
	case SOAP_TYPE_ns2__VehicleInfoType:
		return soap_in_ns2__VehicleInfoType(soap, NULL, NULL, "ns2:VehicleInfoType");
	case SOAP_TYPE_ns2__PEMSIIType:
		return soap_in_ns2__PEMSIIType(soap, NULL, NULL, "ns2:PEMSIIType");
	case SOAP_TYPE_ns2__DescriptionType:
		return soap_in_ns2__DescriptionType(soap, NULL, NULL, "ns2:DescriptionType");
	case SOAP_TYPE_ns2__TitleAliasIdInfoType:
		return soap_in_ns2__TitleAliasIdInfoType(soap, NULL, NULL, "ns2:TitleAliasIdInfoType");
	case SOAP_TYPE_ns2__OtherIDType:
		return soap_in_ns2__OtherIDType(soap, NULL, NULL, "ns2:OtherIDType");
	case SOAP_TYPE_ns2__ContactInfoType:
		return soap_in_ns2__ContactInfoType(soap, NULL, NULL, "ns2:ContactInfoType");
	case SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType:
		return soap_in_ns2__CIDNE_USCOREPersonalInfoType(soap, NULL, NULL, "ns2:CIDNE_PersonalInfoType");
	case SOAP_TYPE_ns2__NameInfoType:
		return soap_in_ns2__NameInfoType(soap, NULL, NULL, "ns2:NameInfoType");
	case SOAP_TYPE_ns2__CIDNE_USCOREPersonType:
		return soap_in_ns2__CIDNE_USCOREPersonType(soap, NULL, NULL, "ns2:CIDNE_PersonType");
	case SOAP_TYPE_ns2__PeopleType:
		return soap_in_ns2__PeopleType(soap, NULL, NULL, "ns2:PeopleType");
	case SOAP_TYPE_ns2__SpecialReportType:
		return soap_in_ns2__SpecialReportType(soap, NULL, NULL, "ns2:SpecialReportType");
	case SOAP_TYPE_ns2__SpecialReportUserPropertiesType:
		return soap_in_ns2__SpecialReportUserPropertiesType(soap, NULL, NULL, "ns2:SpecialReportUserPropertiesType");
	case SOAP_TYPE_ns2__DeletedType:
		return soap_in_ns2__DeletedType(soap, NULL, NULL, "ns2:DeletedType");
	case SOAP_TYPE_ns2__ForumPostType:
		return soap_in_ns2__ForumPostType(soap, NULL, NULL, "ns2:ForumPostType");
	case SOAP_TYPE_ns2__ForumPostUserPropertiesType:
		return soap_in_ns2__ForumPostUserPropertiesType(soap, NULL, NULL, "ns2:ForumPostUserPropertiesType");
	case SOAP_TYPE_ns2__ForumTopicType:
		return soap_in_ns2__ForumTopicType(soap, NULL, NULL, "ns2:ForumTopicType");
	case SOAP_TYPE_ns2__ForumTopicUserPropertiesType:
		return soap_in_ns2__ForumTopicUserPropertiesType(soap, NULL, NULL, "ns2:ForumTopicUserPropertiesType");
	case SOAP_TYPE_ns2__CollectionType:
		return soap_in_ns2__CollectionType(soap, NULL, NULL, "ns2:CollectionType");
	case SOAP_TYPE_ns2__CollectionUserPropertiesType:
		return soap_in_ns2__CollectionUserPropertiesType(soap, NULL, NULL, "ns2:CollectionUserPropertiesType");
	case SOAP_TYPE_ns2__ReportType:
		return soap_in_ns2__ReportType(soap, NULL, NULL, "ns2:ReportType");
	case SOAP_TYPE_ns2__ReportUserPropertiesType:
		return soap_in_ns2__ReportUserPropertiesType(soap, NULL, NULL, "ns2:ReportUserPropertiesType");
	case SOAP_TYPE_ns2__PlaceType:
		return soap_in_ns2__PlaceType(soap, NULL, NULL, "ns2:PlaceType");
	case SOAP_TYPE_ns2__PlaceUserPropertiesType:
		return soap_in_ns2__PlaceUserPropertiesType(soap, NULL, NULL, "ns2:PlaceUserPropertiesType");
	case SOAP_TYPE_ns2__EventType:
		return soap_in_ns2__EventType(soap, NULL, NULL, "ns2:EventType");
	case SOAP_TYPE_ns2__EventUserPropertiesType:
		return soap_in_ns2__EventUserPropertiesType(soap, NULL, NULL, "ns2:EventUserPropertiesType");
	case SOAP_TYPE_ns2__ImageType:
		return soap_in_ns2__ImageType(soap, NULL, NULL, "ns2:ImageType");
	case SOAP_TYPE_ns2__ImageUserPropertiesType:
		return soap_in_ns2__ImageUserPropertiesType(soap, NULL, NULL, "ns2:ImageUserPropertiesType");
	case SOAP_TYPE_ns2__MediaType:
		return soap_in_ns2__MediaType(soap, NULL, NULL, "ns2:MediaType");
	case SOAP_TYPE_ns2__MediaFileUrlType:
		return soap_in_ns2__MediaFileUrlType(soap, NULL, NULL, "ns2:MediaFileUrlType");
	case SOAP_TYPE_ns2__MediaUserPropertiesType:
		return soap_in_ns2__MediaUserPropertiesType(soap, NULL, NULL, "ns2:MediaUserPropertiesType");
	case SOAP_TYPE_ns2__AnnotationType:
		return soap_in_ns2__AnnotationType(soap, NULL, NULL, "ns2:AnnotationType");
	case SOAP_TYPE_ns2__AnnotationUserPropertiesType:
		return soap_in_ns2__AnnotationUserPropertiesType(soap, NULL, NULL, "ns2:AnnotationUserPropertiesType");
	case SOAP_TYPE_ns2__CategoryListType:
		return soap_in_ns2__CategoryListType(soap, NULL, NULL, "ns2:CategoryListType");
	case SOAP_TYPE_ns2__LocationListType:
		return soap_in_ns2__LocationListType(soap, NULL, NULL, "ns2:LocationListType");
	case SOAP_TYPE_ns2__AbstractContentUserPropertiesType:
		return soap_in_ns2__AbstractContentUserPropertiesType(soap, NULL, NULL, "ns2:AbstractContentUserPropertiesType");
	case SOAP_TYPE_ns2__AbstractContentType:
		return soap_in_ns2__AbstractContentType(soap, NULL, NULL, "ns2:AbstractContentType");
	case SOAP_TYPE_ns2__ContentIdentifierReferenceType:
		return soap_in_ns2__ContentIdentifierReferenceType(soap, NULL, NULL, "ns2:ContentIdentifierReferenceType");
	case SOAP_TYPE_ns2__AbstractContentReferenceHolderType:
		return soap_in_ns2__AbstractContentReferenceHolderType(soap, NULL, NULL, "ns2:AbstractContentReferenceHolderType");
	case SOAP_TYPE_ns2__AbstractContentReferenceListType:
		return soap_in_ns2__AbstractContentReferenceListType(soap, NULL, NULL, "ns2:AbstractContentReferenceListType");
	case SOAP_TYPE_ns2__AbstractContentReferenceType:
		return soap_in_ns2__AbstractContentReferenceType(soap, NULL, NULL, "ns2:AbstractContentReferenceType");
	case SOAP_TYPE_ns2__UnitType:
		return soap_in_ns2__UnitType(soap, NULL, NULL, "ns2:UnitType");
	case SOAP_TYPE_ns2__ContentVersionInfoListType:
		return soap_in_ns2__ContentVersionInfoListType(soap, NULL, NULL, "ns2:ContentVersionInfoListType");
	case SOAP_TYPE_ns2__ContentVersionInfoType:
		return soap_in_ns2__ContentVersionInfoType(soap, NULL, NULL, "ns2:ContentVersionInfoType");
	case SOAP_TYPE_ns2__UserInfoType:
		return soap_in_ns2__UserInfoType(soap, NULL, NULL, "ns2:UserInfoType");
	case SOAP_TYPE_ns2__ExternalIdType:
		return soap_in_ns2__ExternalIdType(soap, NULL, NULL, "ns2:ExternalIdType");
	case SOAP_TYPE_ns2__SecurityInfoListType:
		return soap_in_ns2__SecurityInfoListType(soap, NULL, NULL, "ns2:SecurityInfoListType");
	case SOAP_TYPE_ns2__ContentAssociationModelListType:
		return soap_in_ns2__ContentAssociationModelListType(soap, NULL, NULL, "ns2:ContentAssociationModelListType");
	case SOAP_TYPE_ns2__ContentAssociationModelMemberType:
		return soap_in_ns2__ContentAssociationModelMemberType(soap, NULL, NULL, "ns2:ContentAssociationModelMemberType");
	case SOAP_TYPE_ns2__ContentAssociationModelType:
		return soap_in_ns2__ContentAssociationModelType(soap, NULL, NULL, "ns2:ContentAssociationModelType");
	case SOAP_TYPE_ns2__ContentServiceCapabilitiesType:
		return soap_in_ns2__ContentServiceCapabilitiesType(soap, NULL, NULL, "ns2:ContentServiceCapabilitiesType");
	case SOAP_TYPE_ns2__GetResponseType:
		return soap_in_ns2__GetResponseType(soap, NULL, NULL, "ns2:GetResponseType");
	case SOAP_TYPE_ns2__GetType:
		return soap_in_ns2__GetType(soap, NULL, NULL, "ns2:GetType");
	case SOAP_TYPE_ns2__DeleteResponseType:
		return soap_in_ns2__DeleteResponseType(soap, NULL, NULL, "ns2:DeleteResponseType");
	case SOAP_TYPE_ns2__DeleteType:
		return soap_in_ns2__DeleteType(soap, NULL, NULL, "ns2:DeleteType");
	case SOAP_TYPE_ns2__UpdateResponseType:
		return soap_in_ns2__UpdateResponseType(soap, NULL, NULL, "ns2:UpdateResponseType");
	case SOAP_TYPE_ns2__UpdateType:
		return soap_in_ns2__UpdateType(soap, NULL, NULL, "ns2:UpdateType");
	case SOAP_TYPE_ns2__CreateResponseType:
		return soap_in_ns2__CreateResponseType(soap, NULL, NULL, "ns2:CreateResponseType");
	case SOAP_TYPE_ns2__CreateType:
		return soap_in_ns2__CreateType(soap, NULL, NULL, "ns2:CreateType");
	case SOAP_TYPE_xsd__positiveInteger:
		return soap_in_xsd__positiveInteger(soap, NULL, NULL, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_in_xsd__NMTOKEN(soap, NULL, NULL, "xsd:NMTOKEN");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_in_wsa5__ProblemActionType(soap, NULL, NULL, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_in_wsa5__RelatesToType(soap, NULL, NULL, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_in_wsa5__MetadataType(soap, NULL, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_in_wsa5__ReferenceParametersType(soap, NULL, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_in_wsa5__EndpointReferenceType(soap, NULL, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_in_ds__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_in_ds__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_in_ds__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_in_ds__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_ds__TransformsType:
		return soap_in_ds__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_in_ds__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_in_ds__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_in_ds__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_in_ds__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_in_ds__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTons2__ContentServiceCapabilitiesType:
		return soap_in_PointerTons2__ContentServiceCapabilitiesType(soap, NULL, NULL, "ns2:ContentServiceCapabilitiesType");
	case SOAP_TYPE_PointerTons3__GetCapabilitiesType:
		return soap_in_PointerTons3__GetCapabilitiesType(soap, NULL, NULL, "ns3:GetCapabilitiesType");
	case SOAP_TYPE_PointerTons2__UpdateType:
		return soap_in_PointerTons2__UpdateType(soap, NULL, NULL, "ns2:UpdateType");
	case SOAP_TYPE_PointerTons2__DeleteType:
		return soap_in_PointerTons2__DeleteType(soap, NULL, NULL, "ns2:DeleteType");
	case SOAP_TYPE_PointerTons2__GetResponseType:
		return soap_in_PointerTons2__GetResponseType(soap, NULL, NULL, "ns2:GetResponseType");
	case SOAP_TYPE_PointerTons2__GetType:
		return soap_in_PointerTons2__GetType(soap, NULL, NULL, "ns2:GetType");
	case SOAP_TYPE_PointerTons2__CreateResponseType:
		return soap_in_PointerTons2__CreateResponseType(soap, NULL, NULL, "ns2:CreateResponseType");
	case SOAP_TYPE_PointerTons2__CreateType:
		return soap_in_PointerTons2__CreateType(soap, NULL, NULL, "ns2:CreateType");
	case SOAP_TYPE_PointerTons2__OrganizationType:
		return soap_in_PointerTons2__OrganizationType(soap, NULL, NULL, "ns2:OrganizationType");
	case SOAP_TYPE_PointerTons2__DetailedPlaceInfoType:
		return soap_in_PointerTons2__DetailedPlaceInfoType(soap, NULL, NULL, "ns2:DetailedPlaceInfoType");
	case SOAP_TYPE_PointerTons2__CIDNE_USCORECMODailyReportType:
		return soap_in_PointerTons2__CIDNE_USCORECMODailyReportType(soap, NULL, NULL, "ns2:CIDNE_CMODailyReportType");
	case SOAP_TYPE_PointerTons2__HTSAreaAssessmentType:
		return soap_in_PointerTons2__HTSAreaAssessmentType(soap, NULL, NULL, "ns2:HTSAreaAssessmentType");
	case SOAP_TYPE_PointerTons2__CIDNE_USCOREPersonType:
		return soap_in_PointerTons2__CIDNE_USCOREPersonType(soap, NULL, NULL, "ns2:CIDNE_PersonType");
	case SOAP_TYPE_PointerTons2__PeopleType:
		return soap_in_PointerTons2__PeopleType(soap, NULL, NULL, "ns2:PeopleType");
	case SOAP_TYPE_PointerTons2__CategoryListType:
		return soap_in_PointerTons2__CategoryListType(soap, NULL, NULL, "ns2:CategoryListType");
	case SOAP_TYPE_PointerTons2__MediaFileUrlType:
		return soap_in_PointerTons2__MediaFileUrlType(soap, NULL, NULL, "ns2:MediaFileUrlType");
	case SOAP_TYPE_PointerTons3__TimePeriodType:
		return soap_in_PointerTons3__TimePeriodType(soap, NULL, NULL, "ns3:TimePeriodType");
	case SOAP_TYPE_PointerTons2__LocationListType:
		return soap_in_PointerTons2__LocationListType(soap, NULL, NULL, "ns2:LocationListType");
	case SOAP_TYPE_PointerTons3__NonEmptyStringType:
		return soap_in_PointerTons3__NonEmptyStringType(soap, NULL, NULL, "ns3:NonEmptyStringType");
	case SOAP_TYPE_PointerTons2__AbstractContentReferenceHolderType:
		return soap_in_PointerTons2__AbstractContentReferenceHolderType(soap, NULL, NULL, "ns2:AbstractContentReferenceHolderType");
	case SOAP_TYPE_PointerTons2__AbstractContentReferenceListType:
		return soap_in_PointerTons2__AbstractContentReferenceListType(soap, NULL, NULL, "ns2:AbstractContentReferenceListType");
	case SOAP_TYPE_PointerTons3__MediaFileFormType:
		return soap_in_PointerTons3__MediaFileFormType(soap, NULL, NULL, "ns3:MediaFileFormType");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_in_PointerToxsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTons2__SecurityInfoListType:
		return soap_in_PointerTons2__SecurityInfoListType(soap, NULL, NULL, "ns2:SecurityInfoListType");
	case SOAP_TYPE_PointerTons2__ContentAssociationModelListType:
		return soap_in_PointerTons2__ContentAssociationModelListType(soap, NULL, NULL, "ns2:ContentAssociationModelListType");
	case SOAP_TYPE_PointerTons2__ForumPostUserPropertiesType:
		return soap_in_PointerTons2__ForumPostUserPropertiesType(soap, NULL, NULL, "ns2:ForumPostUserPropertiesType");
	case SOAP_TYPE_PointerTons2__ForumTopicUserPropertiesType:
		return soap_in_PointerTons2__ForumTopicUserPropertiesType(soap, NULL, NULL, "ns2:ForumTopicUserPropertiesType");
	case SOAP_TYPE_PointerTons2__CollectionUserPropertiesType:
		return soap_in_PointerTons2__CollectionUserPropertiesType(soap, NULL, NULL, "ns2:CollectionUserPropertiesType");
	case SOAP_TYPE_PointerTons2__ReportUserPropertiesType:
		return soap_in_PointerTons2__ReportUserPropertiesType(soap, NULL, NULL, "ns2:ReportUserPropertiesType");
	case SOAP_TYPE_PointerTons2__PlaceUserPropertiesType:
		return soap_in_PointerTons2__PlaceUserPropertiesType(soap, NULL, NULL, "ns2:PlaceUserPropertiesType");
	case SOAP_TYPE_PointerTons2__EventUserPropertiesType:
		return soap_in_PointerTons2__EventUserPropertiesType(soap, NULL, NULL, "ns2:EventUserPropertiesType");
	case SOAP_TYPE_PointerTons2__ImageUserPropertiesType:
		return soap_in_PointerTons2__ImageUserPropertiesType(soap, NULL, NULL, "ns2:ImageUserPropertiesType");
	case SOAP_TYPE_PointerTons2__MediaUserPropertiesType:
		return soap_in_PointerTons2__MediaUserPropertiesType(soap, NULL, NULL, "ns2:MediaUserPropertiesType");
	case SOAP_TYPE_PointerTons2__AnnotationUserPropertiesType:
		return soap_in_PointerTons2__AnnotationUserPropertiesType(soap, NULL, NULL, "ns2:AnnotationUserPropertiesType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTons2__ReinforcementStatusType:
		return soap_in_PointerTons2__ReinforcementStatusType(soap, NULL, NULL, "ns2:ReinforcementStatusType");
	case SOAP_TYPE_PointerTons2__TrainingStatusType:
		return soap_in_PointerTons2__TrainingStatusType(soap, NULL, NULL, "ns2:TrainingStatusType");
	case SOAP_TYPE_PointerTons2__CBRNDressStatusType:
		return soap_in_PointerTons2__CBRNDressStatusType(soap, NULL, NULL, "ns2:CBRNDressStatusType");
	case SOAP_TYPE_PointerTons2__ReadinessType:
		return soap_in_PointerTons2__ReadinessType(soap, NULL, NULL, "ns2:ReadinessType");
	case SOAP_TYPE_PointerTons2__CommitmentStatusType:
		return soap_in_PointerTons2__CommitmentStatusType(soap, NULL, NULL, "ns2:CommitmentStatusType");
	case SOAP_TYPE_PointerTo_ns2__OrganizationType_UsageStatus:
		return soap_in_PointerTo_ns2__OrganizationType_UsageStatus(soap, NULL, NULL, "ns2:OrganizationType-UsageStatus");
	case SOAP_TYPE_PointerTons2__AvailabilityType:
		return soap_in_PointerTons2__AvailabilityType(soap, NULL, NULL, "ns2:AvailabilityType");
	case SOAP_TYPE_PointerTons2__GroupPeopleType:
		return soap_in_PointerTons2__GroupPeopleType(soap, NULL, NULL, "ns2:GroupPeopleType");
	case SOAP_TYPE_PointerTons2__CommandAndControlType:
		return soap_in_PointerTons2__CommandAndControlType(soap, NULL, NULL, "ns2:CommandAndControlType");
	case SOAP_TYPE_PointerTons2__YesNoType:
		return soap_in_PointerTons2__YesNoType(soap, NULL, NULL, "ns2:YesNoType");
	case SOAP_TYPE_PointerTons2__SecurityStatusType:
		return soap_in_PointerTons2__SecurityStatusType(soap, NULL, NULL, "ns2:SecurityStatusType");
	case SOAP_TYPE_PointerTons2__EnemyActivityPresentType:
		return soap_in_PointerTons2__EnemyActivityPresentType(soap, NULL, NULL, "ns2:EnemyActivityPresentType");
	case SOAP_TYPE_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus:
		return soap_in_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(soap, NULL, NULL, "ns2:DetailedPlaceInfoType-UsageStatus");
	case SOAP_TYPE_PointerTons2__ConstructionType:
		return soap_in_PointerTons2__ConstructionType(soap, NULL, NULL, "ns2:ConstructionType");
	case SOAP_TYPE_PointerTons2__OccupationStatusType:
		return soap_in_PointerTons2__OccupationStatusType(soap, NULL, NULL, "ns2:OccupationStatusType");
	case SOAP_TYPE_PointerTons2__OperationalStatus2Type:
		return soap_in_PointerTons2__OperationalStatus2Type(soap, NULL, NULL, "ns2:OperationalStatus2Type");
	case SOAP_TYPE_PointerTons2__OperationalStatusType:
		return soap_in_PointerTons2__OperationalStatusType(soap, NULL, NULL, "ns2:OperationalStatusType");
	case SOAP_TYPE_PointerTons2__UpcomingEventType:
		return soap_in_PointerTons2__UpcomingEventType(soap, NULL, NULL, "ns2:UpcomingEventType");
	case SOAP_TYPE_PointerTons2__PEMSIIOutcomeType:
		return soap_in_PointerTons2__PEMSIIOutcomeType(soap, NULL, NULL, "ns2:PEMSIIOutcomeType");
	case SOAP_TYPE_PointerTons2__UpcomingEventsType:
		return soap_in_PointerTons2__UpcomingEventsType(soap, NULL, NULL, "ns2:UpcomingEventsType");
	case SOAP_TYPE_PointerTons2__AssessmentsType:
		return soap_in_PointerTons2__AssessmentsType(soap, NULL, NULL, "ns2:AssessmentsType");
	case SOAP_TYPE_PointerTons2__PEMSIIOutcomesType:
		return soap_in_PointerTons2__PEMSIIOutcomesType(soap, NULL, NULL, "ns2:PEMSIIOutcomesType");
	case SOAP_TYPE_PointerTons2__OtherIDType:
		return soap_in_PointerTons2__OtherIDType(soap, NULL, NULL, "ns2:OtherIDType");
	case SOAP_TYPE_PointerTons2__RemarkType:
		return soap_in_PointerTons2__RemarkType(soap, NULL, NULL, "ns2:RemarkType");
	case SOAP_TYPE_PointerTons2__LocationInfoType:
		return soap_in_PointerTons2__LocationInfoType(soap, NULL, NULL, "ns2:LocationInfoType");
	case SOAP_TYPE_PointerTons2__FamilyMemberInfoType:
		return soap_in_PointerTons2__FamilyMemberInfoType(soap, NULL, NULL, "ns2:FamilyMemberInfoType");
	case SOAP_TYPE_PointerTons2__VehicleInfoType:
		return soap_in_PointerTons2__VehicleInfoType(soap, NULL, NULL, "ns2:VehicleInfoType");
	case SOAP_TYPE_PointerTons2__PEMSIIType:
		return soap_in_PointerTons2__PEMSIIType(soap, NULL, NULL, "ns2:PEMSIIType");
	case SOAP_TYPE_PointerTons2__DescriptionType:
		return soap_in_PointerTons2__DescriptionType(soap, NULL, NULL, "ns2:DescriptionType");
	case SOAP_TYPE_PointerTons2__TitleAliasIdInfoType:
		return soap_in_PointerTons2__TitleAliasIdInfoType(soap, NULL, NULL, "ns2:TitleAliasIdInfoType");
	case SOAP_TYPE_PointerTons2__ContactInfoType:
		return soap_in_PointerTons2__ContactInfoType(soap, NULL, NULL, "ns2:ContactInfoType");
	case SOAP_TYPE_PointerTons2__CIDNE_USCOREPersonalInfoType:
		return soap_in_PointerTons2__CIDNE_USCOREPersonalInfoType(soap, NULL, NULL, "ns2:CIDNE_PersonalInfoType");
	case SOAP_TYPE_PointerTons2__NameInfoType:
		return soap_in_PointerTons2__NameInfoType(soap, NULL, NULL, "ns2:NameInfoType");
	case SOAP_TYPE_PointerTons2__PhysicalStatus2Type:
		return soap_in_PointerTons2__PhysicalStatus2Type(soap, NULL, NULL, "ns2:PhysicalStatus2Type");
	case SOAP_TYPE_PointerTons2__PhysicalStatusType:
		return soap_in_PointerTons2__PhysicalStatusType(soap, NULL, NULL, "ns2:PhysicalStatusType");
	case SOAP_TYPE_PointerTons2__DutyStatusType:
		return soap_in_PointerTons2__DutyStatusType(soap, NULL, NULL, "ns2:DutyStatusType");
	case SOAP_TYPE_PointerTons2__GenderType:
		return soap_in_PointerTons2__GenderType(soap, NULL, NULL, "ns2:GenderType");
	case SOAP_TYPE_PointerTons2__RankType:
		return soap_in_PointerTons2__RankType(soap, NULL, NULL, "ns2:RankType");
	case SOAP_TYPE_PointerTons2__PeopleType2Type:
		return soap_in_PointerTons2__PeopleType2Type(soap, NULL, NULL, "ns2:PeopleType2Type");
	case SOAP_TYPE_PointerTons2__PeopleTypeType:
		return soap_in_PointerTons2__PeopleTypeType(soap, NULL, NULL, "ns2:PeopleTypeType");
	case SOAP_TYPE_PointerTons3__PolygonType:
		return soap_in_PointerTons3__PolygonType(soap, NULL, NULL, "ns3:PolygonType");
	case SOAP_TYPE_PointerTons3__LinearRingType:
		return soap_in_PointerTons3__LinearRingType(soap, NULL, NULL, "ns3:LinearRingType");
	case SOAP_TYPE_PointerTons3__LineStringType:
		return soap_in_PointerTons3__LineStringType(soap, NULL, NULL, "ns3:LineStringType");
	case SOAP_TYPE_PointerTons3__PointType:
		return soap_in_PointerTons3__PointType(soap, NULL, NULL, "ns3:PointType");
	case SOAP_TYPE_PointerTons2__ExternalIdType:
		return soap_in_PointerTons2__ExternalIdType(soap, NULL, NULL, "ns2:ExternalIdType");
	case SOAP_TYPE_PointerTons2__UnitType:
		return soap_in_PointerTons2__UnitType(soap, NULL, NULL, "ns2:UnitType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons2__ContentVersionInfoListType:
		return soap_in_PointerTons2__ContentVersionInfoListType(soap, NULL, NULL, "ns2:ContentVersionInfoListType");
	case SOAP_TYPE_PointerTons2__ContentVersionInfoType:
		return soap_in_PointerTons2__ContentVersionInfoType(soap, NULL, NULL, "ns2:ContentVersionInfoType");
	case SOAP_TYPE_PointerTons2__UserInfoType:
		return soap_in_PointerTons2__UserInfoType(soap, NULL, NULL, "ns2:UserInfoType");
	case SOAP_TYPE_PointerTons2__ContentAssociationModelType:
		return soap_in_PointerTons2__ContentAssociationModelType(soap, NULL, NULL, "ns2:ContentAssociationModelType");
	case SOAP_TYPE_PointerToxsd__NMTOKEN:
		return soap_in_PointerToxsd__NMTOKEN(soap, NULL, NULL, "xsd:NMTOKEN");
	case SOAP_TYPE_PointerTons2__ContentAssociationModelMemberType:
		return soap_in_PointerTons2__ContentAssociationModelMemberType(soap, NULL, NULL, "ns2:ContentAssociationModelMemberType");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_in_PointerToxsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTons2__ContentIdentifierReferenceType:
		return soap_in_PointerTons2__ContentIdentifierReferenceType(soap, NULL, NULL, "ns2:ContentIdentifierReferenceType");
	case SOAP_TYPE_PointerTons2__DeletedType:
		return soap_in_PointerTons2__DeletedType(soap, NULL, NULL, "ns2:DeletedType");
	case SOAP_TYPE_PointerTons2__ForumPostType:
		return soap_in_PointerTons2__ForumPostType(soap, NULL, NULL, "ns2:ForumPostType");
	case SOAP_TYPE_PointerTons2__ForumTopicType:
		return soap_in_PointerTons2__ForumTopicType(soap, NULL, NULL, "ns2:ForumTopicType");
	case SOAP_TYPE_PointerTons2__SpecialCollectionType:
		return soap_in_PointerTons2__SpecialCollectionType(soap, NULL, NULL, "ns2:SpecialCollectionType");
	case SOAP_TYPE_PointerTons2__CollectionType:
		return soap_in_PointerTons2__CollectionType(soap, NULL, NULL, "ns2:CollectionType");
	case SOAP_TYPE_PointerTons2__SpecialReportType:
		return soap_in_PointerTons2__SpecialReportType(soap, NULL, NULL, "ns2:SpecialReportType");
	case SOAP_TYPE_PointerTons2__ReportType:
		return soap_in_PointerTons2__ReportType(soap, NULL, NULL, "ns2:ReportType");
	case SOAP_TYPE_PointerTons2__SpecialPlaceType:
		return soap_in_PointerTons2__SpecialPlaceType(soap, NULL, NULL, "ns2:SpecialPlaceType");
	case SOAP_TYPE_PointerTons2__PlaceType:
		return soap_in_PointerTons2__PlaceType(soap, NULL, NULL, "ns2:PlaceType");
	case SOAP_TYPE_PointerTons2__EventType:
		return soap_in_PointerTons2__EventType(soap, NULL, NULL, "ns2:EventType");
	case SOAP_TYPE_PointerTons2__ImageType:
		return soap_in_PointerTons2__ImageType(soap, NULL, NULL, "ns2:ImageType");
	case SOAP_TYPE_PointerTons2__MediaType:
		return soap_in_PointerTons2__MediaType(soap, NULL, NULL, "ns2:MediaType");
	case SOAP_TYPE_PointerTons2__AnnotationType:
		return soap_in_PointerTons2__AnnotationType(soap, NULL, NULL, "ns2:AnnotationType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_in_PointerTo_wsa5__FaultTo(soap, NULL, NULL, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_in_PointerTo_wsa5__ReplyTo(soap, NULL, NULL, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_in_PointerTo_wsa5__From(soap, NULL, NULL, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_in_PointerTo_wsa5__RelatesTo(soap, NULL, NULL, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
	{	char **s;
		s = soap_in__wsa5__ProblemHeaderQName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_in_PointerTowsa5__MetadataType(soap, NULL, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_in_PointerTowsa5__ReferenceParametersType(soap, NULL, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa5__FaultCodesOpenEnumType(soap, NULL, NULL, "wsa5:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, NULL, NULL, "wsa5:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_in_PointerTo_wsse__Security(soap, NULL, NULL, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_in_PointerTods__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_in_PointerTo_wsse__BinarySecurityToken(soap, NULL, NULL, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_in_PointerTo_wsse__UsernameToken(soap, NULL, NULL, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_in_PointerTo_wsu__Timestamp(soap, NULL, NULL, "wsu:Timestamp");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_in_PointerTods__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_in_PointerTods__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_in_PointerTods__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_in_PointerTods__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_in_PointerTods__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_in_PointerTods__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_in_PointerToPointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_in_PointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_in_PointerTods__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_in_PointerTods__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_in_PointerTo_wsse__SecurityTokenReference(soap, NULL, NULL, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_in_PointerTods__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_in_PointerTods__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_in_PointerTods__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, NULL, NULL, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_in_PointerTods__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_in_PointerTods__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_in_PointerTo_wsse__Embedded(soap, NULL, NULL, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_in_PointerTo_wsse__KeyIdentifier(soap, NULL, NULL, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_in_PointerTo_wsse__Reference(soap, NULL, NULL, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_in_PointerTo_wsse__Password(soap, NULL, NULL, "wsse:Password");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns3:VersionType"))
		{	*type = SOAP_TYPE_ns3__VersionType;
			return soap_in_ns3__VersionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GuidType"))
		{	*type = SOAP_TYPE_ns3__GuidType;
			return soap_in_ns3__GuidType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:MimeType"))
		{	*type = SOAP_TYPE_ns3__MimeType;
			return soap_in_ns3__MimeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:NonEmptyStringType"))
		{	*type = SOAP_TYPE_ns3__NonEmptyStringType;
			return soap_in_ns3__NonEmptyStringType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:CoordinatesType"))
		{	*type = SOAP_TYPE_ns3__CoordinatesType;
			return soap_in_ns3__CoordinatesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:URIListType"))
		{	*type = SOAP_TYPE_ns3__URIListType;
			return soap_in_ns3__URIListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:QNameListType"))
		{	*type = SOAP_TYPE_ns3__QNameListType;
			return soap_in_ns3__QNameListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PolygonType"))
		{	*type = SOAP_TYPE_ns3__PolygonType;
			return soap_in_ns3__PolygonType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LinearRingType"))
		{	*type = SOAP_TYPE_ns3__LinearRingType;
			return soap_in_ns3__LinearRingType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:LineStringType"))
		{	*type = SOAP_TYPE_ns3__LineStringType;
			return soap_in_ns3__LineStringType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:PointType"))
		{	*type = SOAP_TYPE_ns3__PointType;
			return soap_in_ns3__PointType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:AbstractGeometryType"))
		{	*type = SOAP_TYPE_ns3__AbstractGeometryType;
			return soap_in_ns3__AbstractGeometryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:EnvelopeType"))
		{	*type = SOAP_TYPE_ns3__EnvelopeType;
			return soap_in_ns3__EnvelopeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:GetCapabilitiesType"))
		{	*type = SOAP_TYPE_ns3__GetCapabilitiesType;
			return soap_in_ns3__GetCapabilitiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:BaseServiceCapabilitiesType"))
		{	*type = SOAP_TYPE_ns3__BaseServiceCapabilitiesType;
			return soap_in_ns3__BaseServiceCapabilitiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:BaseRequestType"))
		{	*type = SOAP_TYPE_ns3__BaseRequestType;
			return soap_in_ns3__BaseRequestType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:TimePeriodType"))
		{	*type = SOAP_TYPE_ns3__TimePeriodType;
			return soap_in_ns3__TimePeriodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OrganizationType"))
		{	*type = SOAP_TYPE_ns2__OrganizationType;
			return soap_in_ns2__OrganizationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SpecialCollectionType"))
		{	*type = SOAP_TYPE_ns2__SpecialCollectionType;
			return soap_in_ns2__SpecialCollectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SpecialCollectionUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType;
			return soap_in_ns2__SpecialCollectionUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DetailedPlaceInfoType"))
		{	*type = SOAP_TYPE_ns2__DetailedPlaceInfoType;
			return soap_in_ns2__DetailedPlaceInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SpecialPlaceType"))
		{	*type = SOAP_TYPE_ns2__SpecialPlaceType;
			return soap_in_ns2__SpecialPlaceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SpecialPlaceUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType;
			return soap_in_ns2__SpecialPlaceUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UpcomingEventType"))
		{	*type = SOAP_TYPE_ns2__UpcomingEventType;
			return soap_in_ns2__UpcomingEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UpcomingEventsType"))
		{	*type = SOAP_TYPE_ns2__UpcomingEventsType;
			return soap_in_ns2__UpcomingEventsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AssessmentsType"))
		{	*type = SOAP_TYPE_ns2__AssessmentsType;
			return soap_in_ns2__AssessmentsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PEMSIIOutcomeType"))
		{	*type = SOAP_TYPE_ns2__PEMSIIOutcomeType;
			return soap_in_ns2__PEMSIIOutcomeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PEMSIIOutcomesType"))
		{	*type = SOAP_TYPE_ns2__PEMSIIOutcomesType;
			return soap_in_ns2__PEMSIIOutcomesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CIDNE_CMODailyReportType"))
		{	*type = SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType;
			return soap_in_ns2__CIDNE_USCORECMODailyReportType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HTSAreaAssessmentType"))
		{	*type = SOAP_TYPE_ns2__HTSAreaAssessmentType;
			return soap_in_ns2__HTSAreaAssessmentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RemarkType"))
		{	*type = SOAP_TYPE_ns2__RemarkType;
			return soap_in_ns2__RemarkType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LocationInfoType"))
		{	*type = SOAP_TYPE_ns2__LocationInfoType;
			return soap_in_ns2__LocationInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FamilyMemberInfoType"))
		{	*type = SOAP_TYPE_ns2__FamilyMemberInfoType;
			return soap_in_ns2__FamilyMemberInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VehicleInfoType"))
		{	*type = SOAP_TYPE_ns2__VehicleInfoType;
			return soap_in_ns2__VehicleInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PEMSIIType"))
		{	*type = SOAP_TYPE_ns2__PEMSIIType;
			return soap_in_ns2__PEMSIIType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DescriptionType"))
		{	*type = SOAP_TYPE_ns2__DescriptionType;
			return soap_in_ns2__DescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TitleAliasIdInfoType"))
		{	*type = SOAP_TYPE_ns2__TitleAliasIdInfoType;
			return soap_in_ns2__TitleAliasIdInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OtherIDType"))
		{	*type = SOAP_TYPE_ns2__OtherIDType;
			return soap_in_ns2__OtherIDType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContactInfoType"))
		{	*type = SOAP_TYPE_ns2__ContactInfoType;
			return soap_in_ns2__ContactInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CIDNE_PersonalInfoType"))
		{	*type = SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType;
			return soap_in_ns2__CIDNE_USCOREPersonalInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NameInfoType"))
		{	*type = SOAP_TYPE_ns2__NameInfoType;
			return soap_in_ns2__NameInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CIDNE_PersonType"))
		{	*type = SOAP_TYPE_ns2__CIDNE_USCOREPersonType;
			return soap_in_ns2__CIDNE_USCOREPersonType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PeopleType"))
		{	*type = SOAP_TYPE_ns2__PeopleType;
			return soap_in_ns2__PeopleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SpecialReportType"))
		{	*type = SOAP_TYPE_ns2__SpecialReportType;
			return soap_in_ns2__SpecialReportType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SpecialReportUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__SpecialReportUserPropertiesType;
			return soap_in_ns2__SpecialReportUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DeletedType"))
		{	*type = SOAP_TYPE_ns2__DeletedType;
			return soap_in_ns2__DeletedType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ForumPostType"))
		{	*type = SOAP_TYPE_ns2__ForumPostType;
			return soap_in_ns2__ForumPostType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ForumPostUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__ForumPostUserPropertiesType;
			return soap_in_ns2__ForumPostUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ForumTopicType"))
		{	*type = SOAP_TYPE_ns2__ForumTopicType;
			return soap_in_ns2__ForumTopicType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ForumTopicUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__ForumTopicUserPropertiesType;
			return soap_in_ns2__ForumTopicUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CollectionType"))
		{	*type = SOAP_TYPE_ns2__CollectionType;
			return soap_in_ns2__CollectionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CollectionUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__CollectionUserPropertiesType;
			return soap_in_ns2__CollectionUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReportType"))
		{	*type = SOAP_TYPE_ns2__ReportType;
			return soap_in_ns2__ReportType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReportUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__ReportUserPropertiesType;
			return soap_in_ns2__ReportUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PlaceType"))
		{	*type = SOAP_TYPE_ns2__PlaceType;
			return soap_in_ns2__PlaceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PlaceUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__PlaceUserPropertiesType;
			return soap_in_ns2__PlaceUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EventType"))
		{	*type = SOAP_TYPE_ns2__EventType;
			return soap_in_ns2__EventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EventUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__EventUserPropertiesType;
			return soap_in_ns2__EventUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImageType"))
		{	*type = SOAP_TYPE_ns2__ImageType;
			return soap_in_ns2__ImageType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ImageUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__ImageUserPropertiesType;
			return soap_in_ns2__ImageUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MediaType"))
		{	*type = SOAP_TYPE_ns2__MediaType;
			return soap_in_ns2__MediaType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MediaFileUrlType"))
		{	*type = SOAP_TYPE_ns2__MediaFileUrlType;
			return soap_in_ns2__MediaFileUrlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MediaUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__MediaUserPropertiesType;
			return soap_in_ns2__MediaUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AnnotationType"))
		{	*type = SOAP_TYPE_ns2__AnnotationType;
			return soap_in_ns2__AnnotationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AnnotationUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__AnnotationUserPropertiesType;
			return soap_in_ns2__AnnotationUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CategoryListType"))
		{	*type = SOAP_TYPE_ns2__CategoryListType;
			return soap_in_ns2__CategoryListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LocationListType"))
		{	*type = SOAP_TYPE_ns2__LocationListType;
			return soap_in_ns2__LocationListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AbstractContentUserPropertiesType"))
		{	*type = SOAP_TYPE_ns2__AbstractContentUserPropertiesType;
			return soap_in_ns2__AbstractContentUserPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AbstractContentType"))
		{	*type = SOAP_TYPE_ns2__AbstractContentType;
			return soap_in_ns2__AbstractContentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContentIdentifierReferenceType"))
		{	*type = SOAP_TYPE_ns2__ContentIdentifierReferenceType;
			return soap_in_ns2__ContentIdentifierReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AbstractContentReferenceHolderType"))
		{	*type = SOAP_TYPE_ns2__AbstractContentReferenceHolderType;
			return soap_in_ns2__AbstractContentReferenceHolderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AbstractContentReferenceListType"))
		{	*type = SOAP_TYPE_ns2__AbstractContentReferenceListType;
			return soap_in_ns2__AbstractContentReferenceListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AbstractContentReferenceType"))
		{	*type = SOAP_TYPE_ns2__AbstractContentReferenceType;
			return soap_in_ns2__AbstractContentReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UnitType"))
		{	*type = SOAP_TYPE_ns2__UnitType;
			return soap_in_ns2__UnitType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContentVersionInfoListType"))
		{	*type = SOAP_TYPE_ns2__ContentVersionInfoListType;
			return soap_in_ns2__ContentVersionInfoListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContentVersionInfoType"))
		{	*type = SOAP_TYPE_ns2__ContentVersionInfoType;
			return soap_in_ns2__ContentVersionInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UserInfoType"))
		{	*type = SOAP_TYPE_ns2__UserInfoType;
			return soap_in_ns2__UserInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ExternalIdType"))
		{	*type = SOAP_TYPE_ns2__ExternalIdType;
			return soap_in_ns2__ExternalIdType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SecurityInfoListType"))
		{	*type = SOAP_TYPE_ns2__SecurityInfoListType;
			return soap_in_ns2__SecurityInfoListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContentAssociationModelListType"))
		{	*type = SOAP_TYPE_ns2__ContentAssociationModelListType;
			return soap_in_ns2__ContentAssociationModelListType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContentAssociationModelMemberType"))
		{	*type = SOAP_TYPE_ns2__ContentAssociationModelMemberType;
			return soap_in_ns2__ContentAssociationModelMemberType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContentAssociationModelType"))
		{	*type = SOAP_TYPE_ns2__ContentAssociationModelType;
			return soap_in_ns2__ContentAssociationModelType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContentServiceCapabilitiesType"))
		{	*type = SOAP_TYPE_ns2__ContentServiceCapabilitiesType;
			return soap_in_ns2__ContentServiceCapabilitiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetResponseType"))
		{	*type = SOAP_TYPE_ns2__GetResponseType;
			return soap_in_ns2__GetResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetType"))
		{	*type = SOAP_TYPE_ns2__GetType;
			return soap_in_ns2__GetType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DeleteResponseType"))
		{	*type = SOAP_TYPE_ns2__DeleteResponseType;
			return soap_in_ns2__DeleteResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DeleteType"))
		{	*type = SOAP_TYPE_ns2__DeleteType;
			return soap_in_ns2__DeleteType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UpdateResponseType"))
		{	*type = SOAP_TYPE_ns2__UpdateResponseType;
			return soap_in_ns2__UpdateResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UpdateType"))
		{	*type = SOAP_TYPE_ns2__UpdateType;
			return soap_in_ns2__UpdateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CreateResponseType"))
		{	*type = SOAP_TYPE_ns2__CreateResponseType;
			return soap_in_ns2__CreateResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CreateType"))
		{	*type = SOAP_TYPE_ns2__CreateType;
			return soap_in_ns2__CreateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:positiveInteger"))
		{	*type = SOAP_TYPE_xsd__positiveInteger;
			return soap_in_xsd__positiveInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NMTOKEN"))
		{	*type = SOAP_TYPE_xsd__NMTOKEN;
			return soap_in_xsd__NMTOKEN(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OrganizationType-UsageStatus"))
		{	*type = SOAP_TYPE__ns2__OrganizationType_UsageStatus;
			return soap_in__ns2__OrganizationType_UsageStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DetailedPlaceInfoType-UsageStatus"))
		{	*type = SOAP_TYPE__ns2__DetailedPlaceInfoType_UsageStatus;
			return soap_in__ns2__DetailedPlaceInfoType_UsageStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DeleteResponseType-status"))
		{	*type = SOAP_TYPE__ns2__DeleteResponseType_status;
			return soap_in__ns2__DeleteResponseType_status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UpdateResponseType-status"))
		{	*type = SOAP_TYPE__ns2__UpdateResponseType_status;
			return soap_in__ns2__UpdateResponseType_status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:MediaFileFormType"))
		{	*type = SOAP_TYPE_ns3__MediaFileFormType;
			return soap_in_ns3__MediaFileFormType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReinforcementStatusType"))
		{	*type = SOAP_TYPE_ns2__ReinforcementStatusType;
			return soap_in_ns2__ReinforcementStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TrainingStatusType"))
		{	*type = SOAP_TYPE_ns2__TrainingStatusType;
			return soap_in_ns2__TrainingStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CBRNDressStatusType"))
		{	*type = SOAP_TYPE_ns2__CBRNDressStatusType;
			return soap_in_ns2__CBRNDressStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReadinessType"))
		{	*type = SOAP_TYPE_ns2__ReadinessType;
			return soap_in_ns2__ReadinessType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CommitmentStatusType"))
		{	*type = SOAP_TYPE_ns2__CommitmentStatusType;
			return soap_in_ns2__CommitmentStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AvailabilityType"))
		{	*type = SOAP_TYPE_ns2__AvailabilityType;
			return soap_in_ns2__AvailabilityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GroupPeopleType"))
		{	*type = SOAP_TYPE_ns2__GroupPeopleType;
			return soap_in_ns2__GroupPeopleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CommandAndControlType"))
		{	*type = SOAP_TYPE_ns2__CommandAndControlType;
			return soap_in_ns2__CommandAndControlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SecurityStatusType"))
		{	*type = SOAP_TYPE_ns2__SecurityStatusType;
			return soap_in_ns2__SecurityStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EnemyActivityPresentType"))
		{	*type = SOAP_TYPE_ns2__EnemyActivityPresentType;
			return soap_in_ns2__EnemyActivityPresentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConstructionType"))
		{	*type = SOAP_TYPE_ns2__ConstructionType;
			return soap_in_ns2__ConstructionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OccupationStatusType"))
		{	*type = SOAP_TYPE_ns2__OccupationStatusType;
			return soap_in_ns2__OccupationStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MinistryType"))
		{	*type = SOAP_TYPE_ns2__MinistryType;
			return soap_in_ns2__MinistryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LineOfOperationType"))
		{	*type = SOAP_TYPE_ns2__LineOfOperationType;
			return soap_in_ns2__LineOfOperationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MissionType"))
		{	*type = SOAP_TYPE_ns2__MissionType;
			return soap_in_ns2__MissionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:KeywordType"))
		{	*type = SOAP_TYPE_ns2__KeywordType;
			return soap_in_ns2__KeywordType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AnalyticalToolMethodType"))
		{	*type = SOAP_TYPE_ns2__AnalyticalToolMethodType;
			return soap_in_ns2__AnalyticalToolMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DataCollectionMethodType"))
		{	*type = SOAP_TYPE_ns2__DataCollectionMethodType;
			return soap_in_ns2__DataCollectionMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ProductType"))
		{	*type = SOAP_TYPE_ns2__ProductType;
			return soap_in_ns2__ProductType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SomaliaProvinceType"))
		{	*type = SOAP_TYPE_ns2__SomaliaProvinceType;
			return soap_in_ns2__SomaliaProvinceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EthiopiaProvinceType"))
		{	*type = SOAP_TYPE_ns2__EthiopiaProvinceType;
			return soap_in_ns2__EthiopiaProvinceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DijiboutiProvinceType"))
		{	*type = SOAP_TYPE_ns2__DijiboutiProvinceType;
			return soap_in_ns2__DijiboutiProvinceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EritreaProvinceType"))
		{	*type = SOAP_TYPE_ns2__EritreaProvinceType;
			return soap_in_ns2__EritreaProvinceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IraqProvinceType"))
		{	*type = SOAP_TYPE_ns2__IraqProvinceType;
			return soap_in_ns2__IraqProvinceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AfghanistanProvinceType"))
		{	*type = SOAP_TYPE_ns2__AfghanistanProvinceType;
			return soap_in_ns2__AfghanistanProvinceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CountryType"))
		{	*type = SOAP_TYPE_ns2__CountryType;
			return soap_in_ns2__CountryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:JustificationType"))
		{	*type = SOAP_TYPE_ns2__JustificationType;
			return soap_in_ns2__JustificationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RoleType"))
		{	*type = SOAP_TYPE_ns2__RoleType;
			return soap_in_ns2__RoleType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WritingHandType"))
		{	*type = SOAP_TYPE_ns2__WritingHandType;
			return soap_in_ns2__WritingHandType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MannerOfDressType"))
		{	*type = SOAP_TYPE_ns2__MannerOfDressType;
			return soap_in_ns2__MannerOfDressType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BuildType"))
		{	*type = SOAP_TYPE_ns2__BuildType;
			return soap_in_ns2__BuildType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HairColorType"))
		{	*type = SOAP_TYPE_ns2__HairColorType;
			return soap_in_ns2__HairColorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EyeColorType"))
		{	*type = SOAP_TYPE_ns2__EyeColorType;
			return soap_in_ns2__EyeColorType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PoliticalStanceType"))
		{	*type = SOAP_TYPE_ns2__PoliticalStanceType;
			return soap_in_ns2__PoliticalStanceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PhysicalStatus2Type"))
		{	*type = SOAP_TYPE_ns2__PhysicalStatus2Type;
			return soap_in_ns2__PhysicalStatus2Type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PhysicalStatusType"))
		{	*type = SOAP_TYPE_ns2__PhysicalStatusType;
			return soap_in_ns2__PhysicalStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DutyStatusType"))
		{	*type = SOAP_TYPE_ns2__DutyStatusType;
			return soap_in_ns2__DutyStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RankType"))
		{	*type = SOAP_TYPE_ns2__RankType;
			return soap_in_ns2__RankType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PeopleType2Type"))
		{	*type = SOAP_TYPE_ns2__PeopleType2Type;
			return soap_in_ns2__PeopleType2Type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PeopleTypeType"))
		{	*type = SOAP_TYPE_ns2__PeopleTypeType;
			return soap_in_ns2__PeopleTypeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GenderType"))
		{	*type = SOAP_TYPE_ns2__GenderType;
			return soap_in_ns2__GenderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:YesNoType"))
		{	*type = SOAP_TYPE_ns2__YesNoType;
			return soap_in_ns2__YesNoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OperationalStatus2Type"))
		{	*type = SOAP_TYPE_ns2__OperationalStatus2Type;
			return soap_in_ns2__OperationalStatus2Type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OperationalStatusType"))
		{	*type = SOAP_TYPE_ns2__OperationalStatusType;
			return soap_in_ns2__OperationalStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReleasabilityType"))
		{	*type = SOAP_TYPE_ns2__ReleasabilityType;
			return soap_in_ns2__ReleasabilityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ClassificationType"))
		{	*type = SOAP_TYPE_ns2__ClassificationType;
			return soap_in_ns2__ClassificationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CategoryValueType"))
		{	*type = SOAP_TYPE_ns2__CategoryValueType;
			return soap_in_ns2__CategoryValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UnitValueType"))
		{	*type = SOAP_TYPE_ns2__UnitValueType;
			return soap_in_ns2__UnitValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CardinalityType"))
		{	*type = SOAP_TYPE_ns2__CardinalityType;
			return soap_in_ns2__CardinalityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa5__IsReferenceParameter;
			return soap_in__wsa5__IsReferenceParameter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa5__FaultCodesType;
			return soap_in_wsa5__FaultCodesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipType"))
		{	*type = SOAP_TYPE_wsa5__RelationshipType;
			return soap_in_wsa5__RelationshipType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum"))
		{	*type = SOAP_TYPE_wsse__FaultcodeEnum;
			return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:tTimestampFault"))
		{	*type = SOAP_TYPE_wsu__tTimestampFault;
			return soap_in_wsu__tTimestampFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa5__ProblemActionType;
			return soap_in_wsa5__ProblemActionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesToType"))
		{	*type = SOAP_TYPE_wsa5__RelatesToType;
			return soap_in_wsa5__RelatesToType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:MetadataType"))
		{	*type = SOAP_TYPE_wsa5__MetadataType;
			return soap_in_wsa5__MetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa5__ReferenceParametersType;
			return soap_in_wsa5__ReferenceParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType;
			return soap_in_wsa5__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__RSAKeyValueType;
			return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__DSAKeyValueType;
			return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType"))
		{	*type = SOAP_TYPE_ds__X509IssuerSerialType;
			return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509DataType"))
		{	*type = SOAP_TYPE_ds__X509DataType;
			return soap_in_ds__X509DataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RetrievalMethodType"))
		{	*type = SOAP_TYPE_ds__RetrievalMethodType;
			return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyValueType"))
		{	*type = SOAP_TYPE_ds__KeyValueType;
			return soap_in_ds__KeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DigestMethodType"))
		{	*type = SOAP_TYPE_ds__DigestMethodType;
			return soap_in_ds__DigestMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformType"))
		{	*type = SOAP_TYPE_ds__TransformType;
			return soap_in_ds__TransformType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformsType"))
		{	*type = SOAP_TYPE_ds__TransformsType;
			return soap_in_ds__TransformsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:ReferenceType"))
		{	*type = SOAP_TYPE_ds__ReferenceType;
			return soap_in_ds__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureMethodType"))
		{	*type = SOAP_TYPE_ds__SignatureMethodType;
			return soap_in_ds__SignatureMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType"))
		{	*type = SOAP_TYPE_ds__CanonicalizationMethodType;
			return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfoType"))
		{	*type = SOAP_TYPE_ds__KeyInfoType;
			return soap_in_ds__KeyInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignedInfoType"))
		{	*type = SOAP_TYPE_ds__SignedInfoType;
			return soap_in_ds__SignedInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureType"))
		{	*type = SOAP_TYPE_ds__SignatureType;
			return soap_in_ds__SignatureType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemHeaderQName;
			s = soap_in__wsa5__ProblemHeaderQName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
			s = soap_in_wsa5__FaultCodesOpenEnumType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
			s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsa5:RetryAfter"))
		{	*type = SOAP_TYPE__wsa5__RetryAfter;
			return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemAction"))
		{	*type = SOAP_TYPE__wsa5__ProblemAction;
			return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultTo"))
		{	*type = SOAP_TYPE__wsa5__FaultTo;
			return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:From"))
		{	*type = SOAP_TYPE__wsa5__From;
			return soap_in__wsa5__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReplyTo"))
		{	*type = SOAP_TYPE__wsa5__ReplyTo;
			return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesTo"))
		{	*type = SOAP_TYPE__wsa5__RelatesTo;
			return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:Metadata"))
		{	*type = SOAP_TYPE__wsa5__Metadata;
			return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa5__ReferenceParameters;
			return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReference"))
		{	*type = SOAP_TYPE__wsa5__EndpointReference;
			return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Security"))
		{	*type = SOAP_TYPE__wsse__Security;
			return soap_in__wsse__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces"))
		{	*type = SOAP_TYPE__c14n__InclusiveNamespaces;
			return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference"))
		{	*type = SOAP_TYPE__wsse__SecurityTokenReference;
			return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:KeyIdentifier"))
		{	*type = SOAP_TYPE__wsse__KeyIdentifier;
			return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Embedded"))
		{	*type = SOAP_TYPE__wsse__Embedded;
			return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Reference"))
		{	*type = SOAP_TYPE__wsse__Reference;
			return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken"))
		{	*type = SOAP_TYPE__wsse__BinarySecurityToken;
			return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Password"))
		{	*type = SOAP_TYPE__wsse__Password;
			return soap_in__wsse__Password(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:UsernameToken"))
		{	*type = SOAP_TYPE__wsse__UsernameToken;
			return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:Timestamp"))
		{	*type = SOAP_TYPE__wsu__Timestamp;
			return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemIRI"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemIRI;
			s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__Action;
			s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__To;
			s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__MessageID;
			s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__wsa5__RetryAfter:
		return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, NULL);
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns2__OrganizationType_UsageStatus:
		return soap_out__ns2__OrganizationType_UsageStatus(soap, tag, id, (const enum _ns2__OrganizationType_UsageStatus *)ptr, "ns2:OrganizationType-UsageStatus");
	case SOAP_TYPE__ns2__DetailedPlaceInfoType_UsageStatus:
		return soap_out__ns2__DetailedPlaceInfoType_UsageStatus(soap, tag, id, (const enum _ns2__DetailedPlaceInfoType_UsageStatus *)ptr, "ns2:DetailedPlaceInfoType-UsageStatus");
	case SOAP_TYPE__ns2__DeleteResponseType_status:
		return soap_out__ns2__DeleteResponseType_status(soap, tag, id, (const enum _ns2__DeleteResponseType_status *)ptr, "ns2:DeleteResponseType-status");
	case SOAP_TYPE__ns2__UpdateResponseType_status:
		return soap_out__ns2__UpdateResponseType_status(soap, tag, id, (const enum _ns2__UpdateResponseType_status *)ptr, "ns2:UpdateResponseType-status");
	case SOAP_TYPE_ns3__MediaFileFormType:
		return soap_out_ns3__MediaFileFormType(soap, tag, id, (const enum ns3__MediaFileFormType *)ptr, "ns3:MediaFileFormType");
	case SOAP_TYPE_ns2__ReinforcementStatusType:
		return soap_out_ns2__ReinforcementStatusType(soap, tag, id, (const enum ns2__ReinforcementStatusType *)ptr, "ns2:ReinforcementStatusType");
	case SOAP_TYPE_ns2__TrainingStatusType:
		return soap_out_ns2__TrainingStatusType(soap, tag, id, (const enum ns2__TrainingStatusType *)ptr, "ns2:TrainingStatusType");
	case SOAP_TYPE_ns2__CBRNDressStatusType:
		return soap_out_ns2__CBRNDressStatusType(soap, tag, id, (const enum ns2__CBRNDressStatusType *)ptr, "ns2:CBRNDressStatusType");
	case SOAP_TYPE_ns2__ReadinessType:
		return soap_out_ns2__ReadinessType(soap, tag, id, (const enum ns2__ReadinessType *)ptr, "ns2:ReadinessType");
	case SOAP_TYPE_ns2__CommitmentStatusType:
		return soap_out_ns2__CommitmentStatusType(soap, tag, id, (const enum ns2__CommitmentStatusType *)ptr, "ns2:CommitmentStatusType");
	case SOAP_TYPE_ns2__AvailabilityType:
		return soap_out_ns2__AvailabilityType(soap, tag, id, (const enum ns2__AvailabilityType *)ptr, "ns2:AvailabilityType");
	case SOAP_TYPE_ns2__GroupPeopleType:
		return soap_out_ns2__GroupPeopleType(soap, tag, id, (const enum ns2__GroupPeopleType *)ptr, "ns2:GroupPeopleType");
	case SOAP_TYPE_ns2__CommandAndControlType:
		return soap_out_ns2__CommandAndControlType(soap, tag, id, (const enum ns2__CommandAndControlType *)ptr, "ns2:CommandAndControlType");
	case SOAP_TYPE_ns2__SecurityStatusType:
		return soap_out_ns2__SecurityStatusType(soap, tag, id, (const enum ns2__SecurityStatusType *)ptr, "ns2:SecurityStatusType");
	case SOAP_TYPE_ns2__EnemyActivityPresentType:
		return soap_out_ns2__EnemyActivityPresentType(soap, tag, id, (const enum ns2__EnemyActivityPresentType *)ptr, "ns2:EnemyActivityPresentType");
	case SOAP_TYPE_ns2__ConstructionType:
		return soap_out_ns2__ConstructionType(soap, tag, id, (const enum ns2__ConstructionType *)ptr, "ns2:ConstructionType");
	case SOAP_TYPE_ns2__OccupationStatusType:
		return soap_out_ns2__OccupationStatusType(soap, tag, id, (const enum ns2__OccupationStatusType *)ptr, "ns2:OccupationStatusType");
	case SOAP_TYPE_ns2__MinistryType:
		return soap_out_ns2__MinistryType(soap, tag, id, (const enum ns2__MinistryType *)ptr, "ns2:MinistryType");
	case SOAP_TYPE_ns2__LineOfOperationType:
		return soap_out_ns2__LineOfOperationType(soap, tag, id, (const enum ns2__LineOfOperationType *)ptr, "ns2:LineOfOperationType");
	case SOAP_TYPE_ns2__MissionType:
		return soap_out_ns2__MissionType(soap, tag, id, (const enum ns2__MissionType *)ptr, "ns2:MissionType");
	case SOAP_TYPE_ns2__KeywordType:
		return soap_out_ns2__KeywordType(soap, tag, id, (const enum ns2__KeywordType *)ptr, "ns2:KeywordType");
	case SOAP_TYPE_ns2__AnalyticalToolMethodType:
		return soap_out_ns2__AnalyticalToolMethodType(soap, tag, id, (const enum ns2__AnalyticalToolMethodType *)ptr, "ns2:AnalyticalToolMethodType");
	case SOAP_TYPE_ns2__DataCollectionMethodType:
		return soap_out_ns2__DataCollectionMethodType(soap, tag, id, (const enum ns2__DataCollectionMethodType *)ptr, "ns2:DataCollectionMethodType");
	case SOAP_TYPE_ns2__ProductType:
		return soap_out_ns2__ProductType(soap, tag, id, (const enum ns2__ProductType *)ptr, "ns2:ProductType");
	case SOAP_TYPE_ns2__SomaliaProvinceType:
		return soap_out_ns2__SomaliaProvinceType(soap, tag, id, (const enum ns2__SomaliaProvinceType *)ptr, "ns2:SomaliaProvinceType");
	case SOAP_TYPE_ns2__EthiopiaProvinceType:
		return soap_out_ns2__EthiopiaProvinceType(soap, tag, id, (const enum ns2__EthiopiaProvinceType *)ptr, "ns2:EthiopiaProvinceType");
	case SOAP_TYPE_ns2__DijiboutiProvinceType:
		return soap_out_ns2__DijiboutiProvinceType(soap, tag, id, (const enum ns2__DijiboutiProvinceType *)ptr, "ns2:DijiboutiProvinceType");
	case SOAP_TYPE_ns2__EritreaProvinceType:
		return soap_out_ns2__EritreaProvinceType(soap, tag, id, (const enum ns2__EritreaProvinceType *)ptr, "ns2:EritreaProvinceType");
	case SOAP_TYPE_ns2__IraqProvinceType:
		return soap_out_ns2__IraqProvinceType(soap, tag, id, (const enum ns2__IraqProvinceType *)ptr, "ns2:IraqProvinceType");
	case SOAP_TYPE_ns2__AfghanistanProvinceType:
		return soap_out_ns2__AfghanistanProvinceType(soap, tag, id, (const enum ns2__AfghanistanProvinceType *)ptr, "ns2:AfghanistanProvinceType");
	case SOAP_TYPE_ns2__CountryType:
		return soap_out_ns2__CountryType(soap, tag, id, (const enum ns2__CountryType *)ptr, "ns2:CountryType");
	case SOAP_TYPE_ns2__JustificationType:
		return soap_out_ns2__JustificationType(soap, tag, id, (const enum ns2__JustificationType *)ptr, "ns2:JustificationType");
	case SOAP_TYPE_ns2__RoleType:
		return soap_out_ns2__RoleType(soap, tag, id, (const enum ns2__RoleType *)ptr, "ns2:RoleType");
	case SOAP_TYPE_ns2__WritingHandType:
		return soap_out_ns2__WritingHandType(soap, tag, id, (const enum ns2__WritingHandType *)ptr, "ns2:WritingHandType");
	case SOAP_TYPE_ns2__MannerOfDressType:
		return soap_out_ns2__MannerOfDressType(soap, tag, id, (const enum ns2__MannerOfDressType *)ptr, "ns2:MannerOfDressType");
	case SOAP_TYPE_ns2__BuildType:
		return soap_out_ns2__BuildType(soap, tag, id, (const enum ns2__BuildType *)ptr, "ns2:BuildType");
	case SOAP_TYPE_ns2__HairColorType:
		return soap_out_ns2__HairColorType(soap, tag, id, (const enum ns2__HairColorType *)ptr, "ns2:HairColorType");
	case SOAP_TYPE_ns2__EyeColorType:
		return soap_out_ns2__EyeColorType(soap, tag, id, (const enum ns2__EyeColorType *)ptr, "ns2:EyeColorType");
	case SOAP_TYPE_ns2__PoliticalStanceType:
		return soap_out_ns2__PoliticalStanceType(soap, tag, id, (const enum ns2__PoliticalStanceType *)ptr, "ns2:PoliticalStanceType");
	case SOAP_TYPE_ns2__PhysicalStatus2Type:
		return soap_out_ns2__PhysicalStatus2Type(soap, tag, id, (const enum ns2__PhysicalStatus2Type *)ptr, "ns2:PhysicalStatus2Type");
	case SOAP_TYPE_ns2__PhysicalStatusType:
		return soap_out_ns2__PhysicalStatusType(soap, tag, id, (const enum ns2__PhysicalStatusType *)ptr, "ns2:PhysicalStatusType");
	case SOAP_TYPE_ns2__DutyStatusType:
		return soap_out_ns2__DutyStatusType(soap, tag, id, (const enum ns2__DutyStatusType *)ptr, "ns2:DutyStatusType");
	case SOAP_TYPE_ns2__RankType:
		return soap_out_ns2__RankType(soap, tag, id, (const enum ns2__RankType *)ptr, "ns2:RankType");
	case SOAP_TYPE_ns2__PeopleType2Type:
		return soap_out_ns2__PeopleType2Type(soap, tag, id, (const enum ns2__PeopleType2Type *)ptr, "ns2:PeopleType2Type");
	case SOAP_TYPE_ns2__PeopleTypeType:
		return soap_out_ns2__PeopleTypeType(soap, tag, id, (const enum ns2__PeopleTypeType *)ptr, "ns2:PeopleTypeType");
	case SOAP_TYPE_ns2__GenderType:
		return soap_out_ns2__GenderType(soap, tag, id, (const enum ns2__GenderType *)ptr, "ns2:GenderType");
	case SOAP_TYPE_ns2__YesNoType:
		return soap_out_ns2__YesNoType(soap, tag, id, (const enum ns2__YesNoType *)ptr, "ns2:YesNoType");
	case SOAP_TYPE_ns2__OperationalStatus2Type:
		return soap_out_ns2__OperationalStatus2Type(soap, tag, id, (const enum ns2__OperationalStatus2Type *)ptr, "ns2:OperationalStatus2Type");
	case SOAP_TYPE_ns2__OperationalStatusType:
		return soap_out_ns2__OperationalStatusType(soap, tag, id, (const enum ns2__OperationalStatusType *)ptr, "ns2:OperationalStatusType");
	case SOAP_TYPE_ns2__ReleasabilityType:
		return soap_out_ns2__ReleasabilityType(soap, tag, id, (const enum ns2__ReleasabilityType *)ptr, "ns2:ReleasabilityType");
	case SOAP_TYPE_ns2__ClassificationType:
		return soap_out_ns2__ClassificationType(soap, tag, id, (const enum ns2__ClassificationType *)ptr, "ns2:ClassificationType");
	case SOAP_TYPE_ns2__CategoryValueType:
		return soap_out_ns2__CategoryValueType(soap, tag, id, (const enum ns2__CategoryValueType *)ptr, "ns2:CategoryValueType");
	case SOAP_TYPE_ns2__UnitValueType:
		return soap_out_ns2__UnitValueType(soap, tag, id, (const enum ns2__UnitValueType *)ptr, "ns2:UnitValueType");
	case SOAP_TYPE_ns2__CardinalityType:
		return soap_out_ns2__CardinalityType(soap, tag, id, (const enum ns2__CardinalityType *)ptr, "ns2:CardinalityType");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
	case SOAP_TYPE_ns3__VersionType:
		return soap_out_ns3__VersionType(soap, tag, id, (const std::string *)ptr, "ns3:VersionType");
	case SOAP_TYPE_ns3__GuidType:
		return soap_out_ns3__GuidType(soap, tag, id, (const std::string *)ptr, "ns3:GuidType");
	case SOAP_TYPE_ns3__MimeType:
		return soap_out_ns3__MimeType(soap, tag, id, (const std::string *)ptr, "ns3:MimeType");
	case SOAP_TYPE_ns3__NonEmptyStringType:
		return soap_out_ns3__NonEmptyStringType(soap, tag, id, (const std::string *)ptr, "ns3:NonEmptyStringType");
	case SOAP_TYPE_ns3__CoordinatesType:
		return soap_out_ns3__CoordinatesType(soap, tag, id, (const std::string *)ptr, "ns3:CoordinatesType");
	case SOAP_TYPE_ns3__URIListType:
		return soap_out_ns3__URIListType(soap, tag, id, (const std::string *)ptr, "ns3:URIListType");
	case SOAP_TYPE_ns3__QNameListType:
		return soap_out_ns3__QNameListType(soap, tag, id, (const std::string *)ptr, "ns3:QNameListType");
	case SOAP_TYPE_ns3__PolygonType:
		return ((ns3__PolygonType *)ptr)->soap_out(soap, tag, id, "ns3:PolygonType");
	case SOAP_TYPE_ns3__LinearRingType:
		return ((ns3__LinearRingType *)ptr)->soap_out(soap, tag, id, "ns3:LinearRingType");
	case SOAP_TYPE_ns3__LineStringType:
		return ((ns3__LineStringType *)ptr)->soap_out(soap, tag, id, "ns3:LineStringType");
	case SOAP_TYPE_ns3__PointType:
		return ((ns3__PointType *)ptr)->soap_out(soap, tag, id, "ns3:PointType");
	case SOAP_TYPE_ns3__AbstractGeometryType:
		return ((ns3__AbstractGeometryType *)ptr)->soap_out(soap, tag, id, "ns3:AbstractGeometryType");
	case SOAP_TYPE_ns3__EnvelopeType:
		return ((ns3__EnvelopeType *)ptr)->soap_out(soap, tag, id, "ns3:EnvelopeType");
	case SOAP_TYPE_ns3__GetCapabilitiesType:
		return ((ns3__GetCapabilitiesType *)ptr)->soap_out(soap, tag, id, "ns3:GetCapabilitiesType");
	case SOAP_TYPE_ns3__BaseServiceCapabilitiesType:
		return ((ns3__BaseServiceCapabilitiesType *)ptr)->soap_out(soap, tag, id, "ns3:BaseServiceCapabilitiesType");
	case SOAP_TYPE_ns3__BaseRequestType:
		return ((ns3__BaseRequestType *)ptr)->soap_out(soap, tag, id, "ns3:BaseRequestType");
	case SOAP_TYPE_ns3__TimePeriodType:
		return ((ns3__TimePeriodType *)ptr)->soap_out(soap, tag, id, "ns3:TimePeriodType");
	case SOAP_TYPE_ns2__OrganizationType:
		return ((ns2__OrganizationType *)ptr)->soap_out(soap, tag, id, "ns2:OrganizationType");
	case SOAP_TYPE_ns2__SpecialCollectionType:
		return ((ns2__SpecialCollectionType *)ptr)->soap_out(soap, tag, id, "ns2:SpecialCollectionType");
	case SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType:
		return ((ns2__SpecialCollectionUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:SpecialCollectionUserPropertiesType");
	case SOAP_TYPE_ns2__DetailedPlaceInfoType:
		return ((ns2__DetailedPlaceInfoType *)ptr)->soap_out(soap, tag, id, "ns2:DetailedPlaceInfoType");
	case SOAP_TYPE_ns2__SpecialPlaceType:
		return ((ns2__SpecialPlaceType *)ptr)->soap_out(soap, tag, id, "ns2:SpecialPlaceType");
	case SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType:
		return ((ns2__SpecialPlaceUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:SpecialPlaceUserPropertiesType");
	case SOAP_TYPE_ns2__UpcomingEventType:
		return ((ns2__UpcomingEventType *)ptr)->soap_out(soap, tag, id, "ns2:UpcomingEventType");
	case SOAP_TYPE_ns2__UpcomingEventsType:
		return ((ns2__UpcomingEventsType *)ptr)->soap_out(soap, tag, id, "ns2:UpcomingEventsType");
	case SOAP_TYPE_ns2__AssessmentsType:
		return ((ns2__AssessmentsType *)ptr)->soap_out(soap, tag, id, "ns2:AssessmentsType");
	case SOAP_TYPE_ns2__PEMSIIOutcomeType:
		return ((ns2__PEMSIIOutcomeType *)ptr)->soap_out(soap, tag, id, "ns2:PEMSIIOutcomeType");
	case SOAP_TYPE_ns2__PEMSIIOutcomesType:
		return ((ns2__PEMSIIOutcomesType *)ptr)->soap_out(soap, tag, id, "ns2:PEMSIIOutcomesType");
	case SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType:
		return ((ns2__CIDNE_USCORECMODailyReportType *)ptr)->soap_out(soap, tag, id, "ns2:CIDNE_CMODailyReportType");
	case SOAP_TYPE_ns2__HTSAreaAssessmentType:
		return ((ns2__HTSAreaAssessmentType *)ptr)->soap_out(soap, tag, id, "ns2:HTSAreaAssessmentType");
	case SOAP_TYPE_ns2__RemarkType:
		return ((ns2__RemarkType *)ptr)->soap_out(soap, tag, id, "ns2:RemarkType");
	case SOAP_TYPE_ns2__LocationInfoType:
		return ((ns2__LocationInfoType *)ptr)->soap_out(soap, tag, id, "ns2:LocationInfoType");
	case SOAP_TYPE_ns2__FamilyMemberInfoType:
		return ((ns2__FamilyMemberInfoType *)ptr)->soap_out(soap, tag, id, "ns2:FamilyMemberInfoType");
	case SOAP_TYPE_ns2__VehicleInfoType:
		return ((ns2__VehicleInfoType *)ptr)->soap_out(soap, tag, id, "ns2:VehicleInfoType");
	case SOAP_TYPE_ns2__PEMSIIType:
		return ((ns2__PEMSIIType *)ptr)->soap_out(soap, tag, id, "ns2:PEMSIIType");
	case SOAP_TYPE_ns2__DescriptionType:
		return ((ns2__DescriptionType *)ptr)->soap_out(soap, tag, id, "ns2:DescriptionType");
	case SOAP_TYPE_ns2__TitleAliasIdInfoType:
		return ((ns2__TitleAliasIdInfoType *)ptr)->soap_out(soap, tag, id, "ns2:TitleAliasIdInfoType");
	case SOAP_TYPE_ns2__OtherIDType:
		return ((ns2__OtherIDType *)ptr)->soap_out(soap, tag, id, "ns2:OtherIDType");
	case SOAP_TYPE_ns2__ContactInfoType:
		return ((ns2__ContactInfoType *)ptr)->soap_out(soap, tag, id, "ns2:ContactInfoType");
	case SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType:
		return ((ns2__CIDNE_USCOREPersonalInfoType *)ptr)->soap_out(soap, tag, id, "ns2:CIDNE_PersonalInfoType");
	case SOAP_TYPE_ns2__NameInfoType:
		return ((ns2__NameInfoType *)ptr)->soap_out(soap, tag, id, "ns2:NameInfoType");
	case SOAP_TYPE_ns2__CIDNE_USCOREPersonType:
		return ((ns2__CIDNE_USCOREPersonType *)ptr)->soap_out(soap, tag, id, "ns2:CIDNE_PersonType");
	case SOAP_TYPE_ns2__PeopleType:
		return ((ns2__PeopleType *)ptr)->soap_out(soap, tag, id, "ns2:PeopleType");
	case SOAP_TYPE_ns2__SpecialReportType:
		return ((ns2__SpecialReportType *)ptr)->soap_out(soap, tag, id, "ns2:SpecialReportType");
	case SOAP_TYPE_ns2__SpecialReportUserPropertiesType:
		return ((ns2__SpecialReportUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:SpecialReportUserPropertiesType");
	case SOAP_TYPE_ns2__DeletedType:
		return ((ns2__DeletedType *)ptr)->soap_out(soap, tag, id, "ns2:DeletedType");
	case SOAP_TYPE_ns2__ForumPostType:
		return ((ns2__ForumPostType *)ptr)->soap_out(soap, tag, id, "ns2:ForumPostType");
	case SOAP_TYPE_ns2__ForumPostUserPropertiesType:
		return ((ns2__ForumPostUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:ForumPostUserPropertiesType");
	case SOAP_TYPE_ns2__ForumTopicType:
		return ((ns2__ForumTopicType *)ptr)->soap_out(soap, tag, id, "ns2:ForumTopicType");
	case SOAP_TYPE_ns2__ForumTopicUserPropertiesType:
		return ((ns2__ForumTopicUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:ForumTopicUserPropertiesType");
	case SOAP_TYPE_ns2__CollectionType:
		return ((ns2__CollectionType *)ptr)->soap_out(soap, tag, id, "ns2:CollectionType");
	case SOAP_TYPE_ns2__CollectionUserPropertiesType:
		return ((ns2__CollectionUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:CollectionUserPropertiesType");
	case SOAP_TYPE_ns2__ReportType:
		return ((ns2__ReportType *)ptr)->soap_out(soap, tag, id, "ns2:ReportType");
	case SOAP_TYPE_ns2__ReportUserPropertiesType:
		return ((ns2__ReportUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:ReportUserPropertiesType");
	case SOAP_TYPE_ns2__PlaceType:
		return ((ns2__PlaceType *)ptr)->soap_out(soap, tag, id, "ns2:PlaceType");
	case SOAP_TYPE_ns2__PlaceUserPropertiesType:
		return ((ns2__PlaceUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:PlaceUserPropertiesType");
	case SOAP_TYPE_ns2__EventType:
		return ((ns2__EventType *)ptr)->soap_out(soap, tag, id, "ns2:EventType");
	case SOAP_TYPE_ns2__EventUserPropertiesType:
		return ((ns2__EventUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:EventUserPropertiesType");
	case SOAP_TYPE_ns2__ImageType:
		return ((ns2__ImageType *)ptr)->soap_out(soap, tag, id, "ns2:ImageType");
	case SOAP_TYPE_ns2__ImageUserPropertiesType:
		return ((ns2__ImageUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:ImageUserPropertiesType");
	case SOAP_TYPE_ns2__MediaType:
		return ((ns2__MediaType *)ptr)->soap_out(soap, tag, id, "ns2:MediaType");
	case SOAP_TYPE_ns2__MediaFileUrlType:
		return ((ns2__MediaFileUrlType *)ptr)->soap_out(soap, tag, id, "ns2:MediaFileUrlType");
	case SOAP_TYPE_ns2__MediaUserPropertiesType:
		return ((ns2__MediaUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:MediaUserPropertiesType");
	case SOAP_TYPE_ns2__AnnotationType:
		return ((ns2__AnnotationType *)ptr)->soap_out(soap, tag, id, "ns2:AnnotationType");
	case SOAP_TYPE_ns2__AnnotationUserPropertiesType:
		return ((ns2__AnnotationUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:AnnotationUserPropertiesType");
	case SOAP_TYPE_ns2__CategoryListType:
		return ((ns2__CategoryListType *)ptr)->soap_out(soap, tag, id, "ns2:CategoryListType");
	case SOAP_TYPE_ns2__LocationListType:
		return ((ns2__LocationListType *)ptr)->soap_out(soap, tag, id, "ns2:LocationListType");
	case SOAP_TYPE_ns2__AbstractContentUserPropertiesType:
		return ((ns2__AbstractContentUserPropertiesType *)ptr)->soap_out(soap, tag, id, "ns2:AbstractContentUserPropertiesType");
	case SOAP_TYPE_ns2__AbstractContentType:
		return ((ns2__AbstractContentType *)ptr)->soap_out(soap, tag, id, "ns2:AbstractContentType");
	case SOAP_TYPE_ns2__ContentIdentifierReferenceType:
		return ((ns2__ContentIdentifierReferenceType *)ptr)->soap_out(soap, tag, id, "ns2:ContentIdentifierReferenceType");
	case SOAP_TYPE_ns2__AbstractContentReferenceHolderType:
		return ((ns2__AbstractContentReferenceHolderType *)ptr)->soap_out(soap, tag, id, "ns2:AbstractContentReferenceHolderType");
	case SOAP_TYPE_ns2__AbstractContentReferenceListType:
		return ((ns2__AbstractContentReferenceListType *)ptr)->soap_out(soap, tag, id, "ns2:AbstractContentReferenceListType");
	case SOAP_TYPE_ns2__AbstractContentReferenceType:
		return ((ns2__AbstractContentReferenceType *)ptr)->soap_out(soap, tag, id, "ns2:AbstractContentReferenceType");
	case SOAP_TYPE_ns2__UnitType:
		return ((ns2__UnitType *)ptr)->soap_out(soap, tag, id, "ns2:UnitType");
	case SOAP_TYPE_ns2__ContentVersionInfoListType:
		return ((ns2__ContentVersionInfoListType *)ptr)->soap_out(soap, tag, id, "ns2:ContentVersionInfoListType");
	case SOAP_TYPE_ns2__ContentVersionInfoType:
		return ((ns2__ContentVersionInfoType *)ptr)->soap_out(soap, tag, id, "ns2:ContentVersionInfoType");
	case SOAP_TYPE_ns2__UserInfoType:
		return ((ns2__UserInfoType *)ptr)->soap_out(soap, tag, id, "ns2:UserInfoType");
	case SOAP_TYPE_ns2__ExternalIdType:
		return ((ns2__ExternalIdType *)ptr)->soap_out(soap, tag, id, "ns2:ExternalIdType");
	case SOAP_TYPE_ns2__SecurityInfoListType:
		return ((ns2__SecurityInfoListType *)ptr)->soap_out(soap, tag, id, "ns2:SecurityInfoListType");
	case SOAP_TYPE_ns2__ContentAssociationModelListType:
		return ((ns2__ContentAssociationModelListType *)ptr)->soap_out(soap, tag, id, "ns2:ContentAssociationModelListType");
	case SOAP_TYPE_ns2__ContentAssociationModelMemberType:
		return ((ns2__ContentAssociationModelMemberType *)ptr)->soap_out(soap, tag, id, "ns2:ContentAssociationModelMemberType");
	case SOAP_TYPE_ns2__ContentAssociationModelType:
		return ((ns2__ContentAssociationModelType *)ptr)->soap_out(soap, tag, id, "ns2:ContentAssociationModelType");
	case SOAP_TYPE_ns2__ContentServiceCapabilitiesType:
		return ((ns2__ContentServiceCapabilitiesType *)ptr)->soap_out(soap, tag, id, "ns2:ContentServiceCapabilitiesType");
	case SOAP_TYPE_ns2__GetResponseType:
		return ((ns2__GetResponseType *)ptr)->soap_out(soap, tag, id, "ns2:GetResponseType");
	case SOAP_TYPE_ns2__GetType:
		return ((ns2__GetType *)ptr)->soap_out(soap, tag, id, "ns2:GetType");
	case SOAP_TYPE_ns2__DeleteResponseType:
		return ((ns2__DeleteResponseType *)ptr)->soap_out(soap, tag, id, "ns2:DeleteResponseType");
	case SOAP_TYPE_ns2__DeleteType:
		return ((ns2__DeleteType *)ptr)->soap_out(soap, tag, id, "ns2:DeleteType");
	case SOAP_TYPE_ns2__UpdateResponseType:
		return ((ns2__UpdateResponseType *)ptr)->soap_out(soap, tag, id, "ns2:UpdateResponseType");
	case SOAP_TYPE_ns2__UpdateType:
		return ((ns2__UpdateType *)ptr)->soap_out(soap, tag, id, "ns2:UpdateType");
	case SOAP_TYPE_ns2__CreateResponseType:
		return ((ns2__CreateResponseType *)ptr)->soap_out(soap, tag, id, "ns2:CreateResponseType");
	case SOAP_TYPE_ns2__CreateType:
		return ((ns2__CreateType *)ptr)->soap_out(soap, tag, id, "ns2:CreateType");
	case SOAP_TYPE_xsd__positiveInteger:
		return soap_out_xsd__positiveInteger(soap, tag, id, (const std::string *)ptr, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const xsd__QName *)ptr, "xsd:QName");
	case SOAP_TYPE_xsd__NMTOKEN:
		return soap_out_xsd__NMTOKEN(soap, tag, id, (const std::string *)ptr, "xsd:NMTOKEN");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__wsa5__ProblemAction:
		return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, NULL);
	case SOAP_TYPE__wsa5__FaultTo:
		return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa5__From:
		return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa5__ReplyTo:
		return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE__wsa5__RelatesTo:
		return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, NULL);
	case SOAP_TYPE__wsa5__Metadata:
		return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, NULL);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, NULL);
	case SOAP_TYPE__wsa5__EndpointReference:
		return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, NULL);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE__wsse__Security:
		return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, NULL);
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, NULL);
	case SOAP_TYPE_ds__TransformsType:
		return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, NULL);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, NULL);
	case SOAP_TYPE__wsse__Embedded:
		return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, NULL);
	case SOAP_TYPE__wsse__Reference:
		return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, NULL);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, NULL);
	case SOAP_TYPE__wsse__Password:
		return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, NULL);
	case SOAP_TYPE__wsse__UsernameToken:
		return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, NULL);
	case SOAP_TYPE__wsu__Timestamp:
		return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, NULL);
	case SOAP_TYPE_PointerTons2__ContentServiceCapabilitiesType:
		return soap_out_PointerTons2__ContentServiceCapabilitiesType(soap, tag, id, (ns2__ContentServiceCapabilitiesType *const*)ptr, "ns2:ContentServiceCapabilitiesType");
	case SOAP_TYPE_PointerTons3__GetCapabilitiesType:
		return soap_out_PointerTons3__GetCapabilitiesType(soap, tag, id, (ns3__GetCapabilitiesType *const*)ptr, "ns3:GetCapabilitiesType");
	case SOAP_TYPE_PointerTons2__UpdateType:
		return soap_out_PointerTons2__UpdateType(soap, tag, id, (ns2__UpdateType *const*)ptr, "ns2:UpdateType");
	case SOAP_TYPE_PointerTons2__DeleteType:
		return soap_out_PointerTons2__DeleteType(soap, tag, id, (ns2__DeleteType *const*)ptr, "ns2:DeleteType");
	case SOAP_TYPE_PointerTons2__GetResponseType:
		return soap_out_PointerTons2__GetResponseType(soap, tag, id, (ns2__GetResponseType *const*)ptr, "ns2:GetResponseType");
	case SOAP_TYPE_PointerTons2__GetType:
		return soap_out_PointerTons2__GetType(soap, tag, id, (ns2__GetType *const*)ptr, "ns2:GetType");
	case SOAP_TYPE_PointerTons2__CreateResponseType:
		return soap_out_PointerTons2__CreateResponseType(soap, tag, id, (ns2__CreateResponseType *const*)ptr, "ns2:CreateResponseType");
	case SOAP_TYPE_PointerTons2__CreateType:
		return soap_out_PointerTons2__CreateType(soap, tag, id, (ns2__CreateType *const*)ptr, "ns2:CreateType");
	case SOAP_TYPE_PointerTons2__OrganizationType:
		return soap_out_PointerTons2__OrganizationType(soap, tag, id, (ns2__OrganizationType *const*)ptr, "ns2:OrganizationType");
	case SOAP_TYPE_PointerTons2__DetailedPlaceInfoType:
		return soap_out_PointerTons2__DetailedPlaceInfoType(soap, tag, id, (ns2__DetailedPlaceInfoType *const*)ptr, "ns2:DetailedPlaceInfoType");
	case SOAP_TYPE_PointerTons2__CIDNE_USCORECMODailyReportType:
		return soap_out_PointerTons2__CIDNE_USCORECMODailyReportType(soap, tag, id, (ns2__CIDNE_USCORECMODailyReportType *const*)ptr, "ns2:CIDNE_CMODailyReportType");
	case SOAP_TYPE_PointerTons2__HTSAreaAssessmentType:
		return soap_out_PointerTons2__HTSAreaAssessmentType(soap, tag, id, (ns2__HTSAreaAssessmentType *const*)ptr, "ns2:HTSAreaAssessmentType");
	case SOAP_TYPE_PointerTons2__CIDNE_USCOREPersonType:
		return soap_out_PointerTons2__CIDNE_USCOREPersonType(soap, tag, id, (ns2__CIDNE_USCOREPersonType *const*)ptr, "ns2:CIDNE_PersonType");
	case SOAP_TYPE_PointerTons2__PeopleType:
		return soap_out_PointerTons2__PeopleType(soap, tag, id, (ns2__PeopleType *const*)ptr, "ns2:PeopleType");
	case SOAP_TYPE_PointerTons2__CategoryListType:
		return soap_out_PointerTons2__CategoryListType(soap, tag, id, (ns2__CategoryListType *const*)ptr, "ns2:CategoryListType");
	case SOAP_TYPE_PointerTons2__MediaFileUrlType:
		return soap_out_PointerTons2__MediaFileUrlType(soap, tag, id, (ns2__MediaFileUrlType *const*)ptr, "ns2:MediaFileUrlType");
	case SOAP_TYPE_PointerTons3__TimePeriodType:
		return soap_out_PointerTons3__TimePeriodType(soap, tag, id, (ns3__TimePeriodType *const*)ptr, "ns3:TimePeriodType");
	case SOAP_TYPE_PointerTons2__LocationListType:
		return soap_out_PointerTons2__LocationListType(soap, tag, id, (ns2__LocationListType *const*)ptr, "ns2:LocationListType");
	case SOAP_TYPE_PointerTons3__NonEmptyStringType:
		return soap_out_PointerTons3__NonEmptyStringType(soap, tag, id, (std::string *const*)ptr, "ns3:NonEmptyStringType");
	case SOAP_TYPE_PointerTons2__AbstractContentReferenceHolderType:
		return soap_out_PointerTons2__AbstractContentReferenceHolderType(soap, tag, id, (ns2__AbstractContentReferenceHolderType *const*)ptr, "ns2:AbstractContentReferenceHolderType");
	case SOAP_TYPE_PointerTons2__AbstractContentReferenceListType:
		return soap_out_PointerTons2__AbstractContentReferenceListType(soap, tag, id, (ns2__AbstractContentReferenceListType *const*)ptr, "ns2:AbstractContentReferenceListType");
	case SOAP_TYPE_PointerTons3__MediaFileFormType:
		return soap_out_PointerTons3__MediaFileFormType(soap, tag, id, (enum ns3__MediaFileFormType *const*)ptr, "ns3:MediaFileFormType");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_out_PointerToxsd__QName(soap, tag, id, (xsd__QName *const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTons2__SecurityInfoListType:
		return soap_out_PointerTons2__SecurityInfoListType(soap, tag, id, (ns2__SecurityInfoListType *const*)ptr, "ns2:SecurityInfoListType");
	case SOAP_TYPE_PointerTons2__ContentAssociationModelListType:
		return soap_out_PointerTons2__ContentAssociationModelListType(soap, tag, id, (ns2__ContentAssociationModelListType *const*)ptr, "ns2:ContentAssociationModelListType");
	case SOAP_TYPE_PointerTons2__ForumPostUserPropertiesType:
		return soap_out_PointerTons2__ForumPostUserPropertiesType(soap, tag, id, (ns2__ForumPostUserPropertiesType *const*)ptr, "ns2:ForumPostUserPropertiesType");
	case SOAP_TYPE_PointerTons2__ForumTopicUserPropertiesType:
		return soap_out_PointerTons2__ForumTopicUserPropertiesType(soap, tag, id, (ns2__ForumTopicUserPropertiesType *const*)ptr, "ns2:ForumTopicUserPropertiesType");
	case SOAP_TYPE_PointerTons2__CollectionUserPropertiesType:
		return soap_out_PointerTons2__CollectionUserPropertiesType(soap, tag, id, (ns2__CollectionUserPropertiesType *const*)ptr, "ns2:CollectionUserPropertiesType");
	case SOAP_TYPE_PointerTons2__ReportUserPropertiesType:
		return soap_out_PointerTons2__ReportUserPropertiesType(soap, tag, id, (ns2__ReportUserPropertiesType *const*)ptr, "ns2:ReportUserPropertiesType");
	case SOAP_TYPE_PointerTons2__PlaceUserPropertiesType:
		return soap_out_PointerTons2__PlaceUserPropertiesType(soap, tag, id, (ns2__PlaceUserPropertiesType *const*)ptr, "ns2:PlaceUserPropertiesType");
	case SOAP_TYPE_PointerTons2__EventUserPropertiesType:
		return soap_out_PointerTons2__EventUserPropertiesType(soap, tag, id, (ns2__EventUserPropertiesType *const*)ptr, "ns2:EventUserPropertiesType");
	case SOAP_TYPE_PointerTons2__ImageUserPropertiesType:
		return soap_out_PointerTons2__ImageUserPropertiesType(soap, tag, id, (ns2__ImageUserPropertiesType *const*)ptr, "ns2:ImageUserPropertiesType");
	case SOAP_TYPE_PointerTons2__MediaUserPropertiesType:
		return soap_out_PointerTons2__MediaUserPropertiesType(soap, tag, id, (ns2__MediaUserPropertiesType *const*)ptr, "ns2:MediaUserPropertiesType");
	case SOAP_TYPE_PointerTons2__AnnotationUserPropertiesType:
		return soap_out_PointerTons2__AnnotationUserPropertiesType(soap, tag, id, (ns2__AnnotationUserPropertiesType *const*)ptr, "ns2:AnnotationUserPropertiesType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTons2__ReinforcementStatusType:
		return soap_out_PointerTons2__ReinforcementStatusType(soap, tag, id, (enum ns2__ReinforcementStatusType *const*)ptr, "ns2:ReinforcementStatusType");
	case SOAP_TYPE_PointerTons2__TrainingStatusType:
		return soap_out_PointerTons2__TrainingStatusType(soap, tag, id, (enum ns2__TrainingStatusType *const*)ptr, "ns2:TrainingStatusType");
	case SOAP_TYPE_PointerTons2__CBRNDressStatusType:
		return soap_out_PointerTons2__CBRNDressStatusType(soap, tag, id, (enum ns2__CBRNDressStatusType *const*)ptr, "ns2:CBRNDressStatusType");
	case SOAP_TYPE_PointerTons2__ReadinessType:
		return soap_out_PointerTons2__ReadinessType(soap, tag, id, (enum ns2__ReadinessType *const*)ptr, "ns2:ReadinessType");
	case SOAP_TYPE_PointerTons2__CommitmentStatusType:
		return soap_out_PointerTons2__CommitmentStatusType(soap, tag, id, (enum ns2__CommitmentStatusType *const*)ptr, "ns2:CommitmentStatusType");
	case SOAP_TYPE_PointerTo_ns2__OrganizationType_UsageStatus:
		return soap_out_PointerTo_ns2__OrganizationType_UsageStatus(soap, tag, id, (enum _ns2__OrganizationType_UsageStatus *const*)ptr, "ns2:OrganizationType-UsageStatus");
	case SOAP_TYPE_PointerTons2__AvailabilityType:
		return soap_out_PointerTons2__AvailabilityType(soap, tag, id, (enum ns2__AvailabilityType *const*)ptr, "ns2:AvailabilityType");
	case SOAP_TYPE_PointerTons2__GroupPeopleType:
		return soap_out_PointerTons2__GroupPeopleType(soap, tag, id, (enum ns2__GroupPeopleType *const*)ptr, "ns2:GroupPeopleType");
	case SOAP_TYPE_PointerTons2__CommandAndControlType:
		return soap_out_PointerTons2__CommandAndControlType(soap, tag, id, (enum ns2__CommandAndControlType *const*)ptr, "ns2:CommandAndControlType");
	case SOAP_TYPE_PointerTons2__YesNoType:
		return soap_out_PointerTons2__YesNoType(soap, tag, id, (enum ns2__YesNoType *const*)ptr, "ns2:YesNoType");
	case SOAP_TYPE_PointerTons2__SecurityStatusType:
		return soap_out_PointerTons2__SecurityStatusType(soap, tag, id, (enum ns2__SecurityStatusType *const*)ptr, "ns2:SecurityStatusType");
	case SOAP_TYPE_PointerTons2__EnemyActivityPresentType:
		return soap_out_PointerTons2__EnemyActivityPresentType(soap, tag, id, (enum ns2__EnemyActivityPresentType *const*)ptr, "ns2:EnemyActivityPresentType");
	case SOAP_TYPE_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus:
		return soap_out_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(soap, tag, id, (enum _ns2__DetailedPlaceInfoType_UsageStatus *const*)ptr, "ns2:DetailedPlaceInfoType-UsageStatus");
	case SOAP_TYPE_PointerTons2__ConstructionType:
		return soap_out_PointerTons2__ConstructionType(soap, tag, id, (enum ns2__ConstructionType *const*)ptr, "ns2:ConstructionType");
	case SOAP_TYPE_PointerTons2__OccupationStatusType:
		return soap_out_PointerTons2__OccupationStatusType(soap, tag, id, (enum ns2__OccupationStatusType *const*)ptr, "ns2:OccupationStatusType");
	case SOAP_TYPE_PointerTons2__OperationalStatus2Type:
		return soap_out_PointerTons2__OperationalStatus2Type(soap, tag, id, (enum ns2__OperationalStatus2Type *const*)ptr, "ns2:OperationalStatus2Type");
	case SOAP_TYPE_PointerTons2__OperationalStatusType:
		return soap_out_PointerTons2__OperationalStatusType(soap, tag, id, (enum ns2__OperationalStatusType *const*)ptr, "ns2:OperationalStatusType");
	case SOAP_TYPE_PointerTons2__UpcomingEventType:
		return soap_out_PointerTons2__UpcomingEventType(soap, tag, id, (ns2__UpcomingEventType *const*)ptr, "ns2:UpcomingEventType");
	case SOAP_TYPE_PointerTons2__PEMSIIOutcomeType:
		return soap_out_PointerTons2__PEMSIIOutcomeType(soap, tag, id, (ns2__PEMSIIOutcomeType *const*)ptr, "ns2:PEMSIIOutcomeType");
	case SOAP_TYPE_PointerTons2__UpcomingEventsType:
		return soap_out_PointerTons2__UpcomingEventsType(soap, tag, id, (ns2__UpcomingEventsType *const*)ptr, "ns2:UpcomingEventsType");
	case SOAP_TYPE_PointerTons2__AssessmentsType:
		return soap_out_PointerTons2__AssessmentsType(soap, tag, id, (ns2__AssessmentsType *const*)ptr, "ns2:AssessmentsType");
	case SOAP_TYPE_PointerTons2__PEMSIIOutcomesType:
		return soap_out_PointerTons2__PEMSIIOutcomesType(soap, tag, id, (ns2__PEMSIIOutcomesType *const*)ptr, "ns2:PEMSIIOutcomesType");
	case SOAP_TYPE_PointerTons2__OtherIDType:
		return soap_out_PointerTons2__OtherIDType(soap, tag, id, (ns2__OtherIDType *const*)ptr, "ns2:OtherIDType");
	case SOAP_TYPE_PointerTons2__RemarkType:
		return soap_out_PointerTons2__RemarkType(soap, tag, id, (ns2__RemarkType *const*)ptr, "ns2:RemarkType");
	case SOAP_TYPE_PointerTons2__LocationInfoType:
		return soap_out_PointerTons2__LocationInfoType(soap, tag, id, (ns2__LocationInfoType *const*)ptr, "ns2:LocationInfoType");
	case SOAP_TYPE_PointerTons2__FamilyMemberInfoType:
		return soap_out_PointerTons2__FamilyMemberInfoType(soap, tag, id, (ns2__FamilyMemberInfoType *const*)ptr, "ns2:FamilyMemberInfoType");
	case SOAP_TYPE_PointerTons2__VehicleInfoType:
		return soap_out_PointerTons2__VehicleInfoType(soap, tag, id, (ns2__VehicleInfoType *const*)ptr, "ns2:VehicleInfoType");
	case SOAP_TYPE_PointerTons2__PEMSIIType:
		return soap_out_PointerTons2__PEMSIIType(soap, tag, id, (ns2__PEMSIIType *const*)ptr, "ns2:PEMSIIType");
	case SOAP_TYPE_PointerTons2__DescriptionType:
		return soap_out_PointerTons2__DescriptionType(soap, tag, id, (ns2__DescriptionType *const*)ptr, "ns2:DescriptionType");
	case SOAP_TYPE_PointerTons2__TitleAliasIdInfoType:
		return soap_out_PointerTons2__TitleAliasIdInfoType(soap, tag, id, (ns2__TitleAliasIdInfoType *const*)ptr, "ns2:TitleAliasIdInfoType");
	case SOAP_TYPE_PointerTons2__ContactInfoType:
		return soap_out_PointerTons2__ContactInfoType(soap, tag, id, (ns2__ContactInfoType *const*)ptr, "ns2:ContactInfoType");
	case SOAP_TYPE_PointerTons2__CIDNE_USCOREPersonalInfoType:
		return soap_out_PointerTons2__CIDNE_USCOREPersonalInfoType(soap, tag, id, (ns2__CIDNE_USCOREPersonalInfoType *const*)ptr, "ns2:CIDNE_PersonalInfoType");
	case SOAP_TYPE_PointerTons2__NameInfoType:
		return soap_out_PointerTons2__NameInfoType(soap, tag, id, (ns2__NameInfoType *const*)ptr, "ns2:NameInfoType");
	case SOAP_TYPE_PointerTons2__PhysicalStatus2Type:
		return soap_out_PointerTons2__PhysicalStatus2Type(soap, tag, id, (enum ns2__PhysicalStatus2Type *const*)ptr, "ns2:PhysicalStatus2Type");
	case SOAP_TYPE_PointerTons2__PhysicalStatusType:
		return soap_out_PointerTons2__PhysicalStatusType(soap, tag, id, (enum ns2__PhysicalStatusType *const*)ptr, "ns2:PhysicalStatusType");
	case SOAP_TYPE_PointerTons2__DutyStatusType:
		return soap_out_PointerTons2__DutyStatusType(soap, tag, id, (enum ns2__DutyStatusType *const*)ptr, "ns2:DutyStatusType");
	case SOAP_TYPE_PointerTons2__GenderType:
		return soap_out_PointerTons2__GenderType(soap, tag, id, (enum ns2__GenderType *const*)ptr, "ns2:GenderType");
	case SOAP_TYPE_PointerTons2__RankType:
		return soap_out_PointerTons2__RankType(soap, tag, id, (enum ns2__RankType *const*)ptr, "ns2:RankType");
	case SOAP_TYPE_PointerTons2__PeopleType2Type:
		return soap_out_PointerTons2__PeopleType2Type(soap, tag, id, (enum ns2__PeopleType2Type *const*)ptr, "ns2:PeopleType2Type");
	case SOAP_TYPE_PointerTons2__PeopleTypeType:
		return soap_out_PointerTons2__PeopleTypeType(soap, tag, id, (enum ns2__PeopleTypeType *const*)ptr, "ns2:PeopleTypeType");
	case SOAP_TYPE_PointerTons3__PolygonType:
		return soap_out_PointerTons3__PolygonType(soap, tag, id, (ns3__PolygonType *const*)ptr, "ns3:PolygonType");
	case SOAP_TYPE_PointerTons3__LinearRingType:
		return soap_out_PointerTons3__LinearRingType(soap, tag, id, (ns3__LinearRingType *const*)ptr, "ns3:LinearRingType");
	case SOAP_TYPE_PointerTons3__LineStringType:
		return soap_out_PointerTons3__LineStringType(soap, tag, id, (ns3__LineStringType *const*)ptr, "ns3:LineStringType");
	case SOAP_TYPE_PointerTons3__PointType:
		return soap_out_PointerTons3__PointType(soap, tag, id, (ns3__PointType *const*)ptr, "ns3:PointType");
	case SOAP_TYPE_PointerTons2__ExternalIdType:
		return soap_out_PointerTons2__ExternalIdType(soap, tag, id, (ns2__ExternalIdType *const*)ptr, "ns2:ExternalIdType");
	case SOAP_TYPE_PointerTons2__UnitType:
		return soap_out_PointerTons2__UnitType(soap, tag, id, (ns2__UnitType *const*)ptr, "ns2:UnitType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons2__ContentVersionInfoListType:
		return soap_out_PointerTons2__ContentVersionInfoListType(soap, tag, id, (ns2__ContentVersionInfoListType *const*)ptr, "ns2:ContentVersionInfoListType");
	case SOAP_TYPE_PointerTons2__ContentVersionInfoType:
		return soap_out_PointerTons2__ContentVersionInfoType(soap, tag, id, (ns2__ContentVersionInfoType *const*)ptr, "ns2:ContentVersionInfoType");
	case SOAP_TYPE_PointerTons2__UserInfoType:
		return soap_out_PointerTons2__UserInfoType(soap, tag, id, (ns2__UserInfoType *const*)ptr, "ns2:UserInfoType");
	case SOAP_TYPE_PointerTons2__ContentAssociationModelType:
		return soap_out_PointerTons2__ContentAssociationModelType(soap, tag, id, (ns2__ContentAssociationModelType *const*)ptr, "ns2:ContentAssociationModelType");
	case SOAP_TYPE_PointerToxsd__NMTOKEN:
		return soap_out_PointerToxsd__NMTOKEN(soap, tag, id, (std::string *const*)ptr, "xsd:NMTOKEN");
	case SOAP_TYPE_PointerTons2__ContentAssociationModelMemberType:
		return soap_out_PointerTons2__ContentAssociationModelMemberType(soap, tag, id, (ns2__ContentAssociationModelMemberType *const*)ptr, "ns2:ContentAssociationModelMemberType");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_out_PointerToxsd__nonNegativeInteger(soap, tag, id, (std::string *const*)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTons2__ContentIdentifierReferenceType:
		return soap_out_PointerTons2__ContentIdentifierReferenceType(soap, tag, id, (ns2__ContentIdentifierReferenceType *const*)ptr, "ns2:ContentIdentifierReferenceType");
	case SOAP_TYPE_PointerTons2__DeletedType:
		return soap_out_PointerTons2__DeletedType(soap, tag, id, (ns2__DeletedType *const*)ptr, "ns2:DeletedType");
	case SOAP_TYPE_PointerTons2__ForumPostType:
		return soap_out_PointerTons2__ForumPostType(soap, tag, id, (ns2__ForumPostType *const*)ptr, "ns2:ForumPostType");
	case SOAP_TYPE_PointerTons2__ForumTopicType:
		return soap_out_PointerTons2__ForumTopicType(soap, tag, id, (ns2__ForumTopicType *const*)ptr, "ns2:ForumTopicType");
	case SOAP_TYPE_PointerTons2__SpecialCollectionType:
		return soap_out_PointerTons2__SpecialCollectionType(soap, tag, id, (ns2__SpecialCollectionType *const*)ptr, "ns2:SpecialCollectionType");
	case SOAP_TYPE_PointerTons2__CollectionType:
		return soap_out_PointerTons2__CollectionType(soap, tag, id, (ns2__CollectionType *const*)ptr, "ns2:CollectionType");
	case SOAP_TYPE_PointerTons2__SpecialReportType:
		return soap_out_PointerTons2__SpecialReportType(soap, tag, id, (ns2__SpecialReportType *const*)ptr, "ns2:SpecialReportType");
	case SOAP_TYPE_PointerTons2__ReportType:
		return soap_out_PointerTons2__ReportType(soap, tag, id, (ns2__ReportType *const*)ptr, "ns2:ReportType");
	case SOAP_TYPE_PointerTons2__SpecialPlaceType:
		return soap_out_PointerTons2__SpecialPlaceType(soap, tag, id, (ns2__SpecialPlaceType *const*)ptr, "ns2:SpecialPlaceType");
	case SOAP_TYPE_PointerTons2__PlaceType:
		return soap_out_PointerTons2__PlaceType(soap, tag, id, (ns2__PlaceType *const*)ptr, "ns2:PlaceType");
	case SOAP_TYPE_PointerTons2__EventType:
		return soap_out_PointerTons2__EventType(soap, tag, id, (ns2__EventType *const*)ptr, "ns2:EventType");
	case SOAP_TYPE_PointerTons2__ImageType:
		return soap_out_PointerTons2__ImageType(soap, tag, id, (ns2__ImageType *const*)ptr, "ns2:ImageType");
	case SOAP_TYPE_PointerTons2__MediaType:
		return soap_out_PointerTons2__MediaType(soap, tag, id, (ns2__MediaType *const*)ptr, "ns2:MediaType");
	case SOAP_TYPE_PointerTons2__AnnotationType:
		return soap_out_PointerTons2__AnnotationType(soap, tag, id, (ns2__AnnotationType *const*)ptr, "ns2:AnnotationType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemIRI:
		return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE__wsa5__Action:
		return soap_out_string(soap, "wsa5:Action", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa5__To:
		return soap_out_string(soap, "wsa5:To", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE__wsa5__MessageID:
		return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa5:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "wsa5:RelationshipTypeOpenEnum");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns2__union_LocationListType:
		((__ns2__union_LocationListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns2__union_AbstractContentReferenceListType:
		((__ns2__union_AbstractContentReferenceListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns2__union_GetResponseType:
		((__ns2__union_GetResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__VersionType:
		soap_serialize_ns3__VersionType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns3__GuidType:
		soap_serialize_ns3__GuidType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns3__MimeType:
		soap_serialize_ns3__MimeType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns3__NonEmptyStringType:
		soap_serialize_ns3__NonEmptyStringType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns3__CoordinatesType:
		soap_serialize_ns3__CoordinatesType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns3__URIListType:
		soap_serialize_ns3__URIListType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns3__QNameListType:
		soap_serialize_ns3__QNameListType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns3__PolygonType:
		((ns3__PolygonType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__LinearRingType:
		((ns3__LinearRingType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__LineStringType:
		((ns3__LineStringType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__PointType:
		((ns3__PointType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__AbstractGeometryType:
		((ns3__AbstractGeometryType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__EnvelopeType:
		((ns3__EnvelopeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__GetCapabilitiesType:
		((ns3__GetCapabilitiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__BaseServiceCapabilitiesType:
		((ns3__BaseServiceCapabilitiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__BaseRequestType:
		((ns3__BaseRequestType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__TimePeriodType:
		((ns3__TimePeriodType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OrganizationType:
		((ns2__OrganizationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SpecialCollectionType:
		((ns2__SpecialCollectionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType:
		((ns2__SpecialCollectionUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DetailedPlaceInfoType:
		((ns2__DetailedPlaceInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SpecialPlaceType:
		((ns2__SpecialPlaceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType:
		((ns2__SpecialPlaceUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__UpcomingEventType:
		((ns2__UpcomingEventType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__UpcomingEventsType:
		((ns2__UpcomingEventsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AssessmentsType:
		((ns2__AssessmentsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PEMSIIOutcomeType:
		((ns2__PEMSIIOutcomeType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PEMSIIOutcomesType:
		((ns2__PEMSIIOutcomesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType:
		((ns2__CIDNE_USCORECMODailyReportType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HTSAreaAssessmentType:
		((ns2__HTSAreaAssessmentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RemarkType:
		((ns2__RemarkType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LocationInfoType:
		((ns2__LocationInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FamilyMemberInfoType:
		((ns2__FamilyMemberInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VehicleInfoType:
		((ns2__VehicleInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PEMSIIType:
		((ns2__PEMSIIType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DescriptionType:
		((ns2__DescriptionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TitleAliasIdInfoType:
		((ns2__TitleAliasIdInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OtherIDType:
		((ns2__OtherIDType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ContactInfoType:
		((ns2__ContactInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType:
		((ns2__CIDNE_USCOREPersonalInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NameInfoType:
		((ns2__NameInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CIDNE_USCOREPersonType:
		((ns2__CIDNE_USCOREPersonType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PeopleType:
		((ns2__PeopleType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SpecialReportType:
		((ns2__SpecialReportType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SpecialReportUserPropertiesType:
		((ns2__SpecialReportUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DeletedType:
		((ns2__DeletedType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ForumPostType:
		((ns2__ForumPostType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ForumPostUserPropertiesType:
		((ns2__ForumPostUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ForumTopicType:
		((ns2__ForumTopicType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ForumTopicUserPropertiesType:
		((ns2__ForumTopicUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CollectionType:
		((ns2__CollectionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CollectionUserPropertiesType:
		((ns2__CollectionUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ReportType:
		((ns2__ReportType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ReportUserPropertiesType:
		((ns2__ReportUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PlaceType:
		((ns2__PlaceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PlaceUserPropertiesType:
		((ns2__PlaceUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EventType:
		((ns2__EventType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EventUserPropertiesType:
		((ns2__EventUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ImageType:
		((ns2__ImageType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ImageUserPropertiesType:
		((ns2__ImageUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MediaType:
		((ns2__MediaType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MediaFileUrlType:
		((ns2__MediaFileUrlType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MediaUserPropertiesType:
		((ns2__MediaUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AnnotationType:
		((ns2__AnnotationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AnnotationUserPropertiesType:
		((ns2__AnnotationUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CategoryListType:
		((ns2__CategoryListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LocationListType:
		((ns2__LocationListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AbstractContentUserPropertiesType:
		((ns2__AbstractContentUserPropertiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AbstractContentType:
		((ns2__AbstractContentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ContentIdentifierReferenceType:
		((ns2__ContentIdentifierReferenceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AbstractContentReferenceHolderType:
		((ns2__AbstractContentReferenceHolderType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AbstractContentReferenceListType:
		((ns2__AbstractContentReferenceListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AbstractContentReferenceType:
		((ns2__AbstractContentReferenceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__UnitType:
		((ns2__UnitType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ContentVersionInfoListType:
		((ns2__ContentVersionInfoListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ContentVersionInfoType:
		((ns2__ContentVersionInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__UserInfoType:
		((ns2__UserInfoType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ExternalIdType:
		((ns2__ExternalIdType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SecurityInfoListType:
		((ns2__SecurityInfoListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ContentAssociationModelListType:
		((ns2__ContentAssociationModelListType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ContentAssociationModelMemberType:
		((ns2__ContentAssociationModelMemberType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ContentAssociationModelType:
		((ns2__ContentAssociationModelType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ContentServiceCapabilitiesType:
		((ns2__ContentServiceCapabilitiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__GetResponseType:
		((ns2__GetResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__GetType:
		((ns2__GetType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DeleteResponseType:
		((ns2__DeleteResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DeleteType:
		((ns2__DeleteType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__UpdateResponseType:
		((ns2__UpdateResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__UpdateType:
		((ns2__UpdateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CreateResponseType:
		((ns2__CreateResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CreateType:
		((ns2__CreateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__positiveInteger:
		soap_serialize_xsd__positiveInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const xsd__QName *)ptr);
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		soap_serialize_xsd__NMTOKEN(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns4__GetCapabilitiesOperation:
		soap_serialize___ns4__GetCapabilitiesOperation(soap, (const struct __ns4__GetCapabilitiesOperation *)ptr);
		break;
	case SOAP_TYPE___ns4__UpdateOperation:
		soap_serialize___ns4__UpdateOperation(soap, (const struct __ns4__UpdateOperation *)ptr);
		break;
	case SOAP_TYPE___ns4__UpdateOperationResponse:
		soap_serialize___ns4__UpdateOperationResponse(soap, (const struct __ns4__UpdateOperationResponse *)ptr);
		break;
	case SOAP_TYPE___ns4__DeleteOperation:
		soap_serialize___ns4__DeleteOperation(soap, (const struct __ns4__DeleteOperation *)ptr);
		break;
	case SOAP_TYPE___ns4__DeleteOperationResponse:
		soap_serialize___ns4__DeleteOperationResponse(soap, (const struct __ns4__DeleteOperationResponse *)ptr);
		break;
	case SOAP_TYPE___ns4__GetOperation:
		soap_serialize___ns4__GetOperation(soap, (const struct __ns4__GetOperation *)ptr);
		break;
	case SOAP_TYPE___ns4__CreateOperation:
		soap_serialize___ns4__CreateOperation(soap, (const struct __ns4__CreateOperation *)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsse__Security:
		soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContentServiceCapabilitiesType:
		soap_serialize_PointerTons2__ContentServiceCapabilitiesType(soap, (ns2__ContentServiceCapabilitiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__GetCapabilitiesType:
		soap_serialize_PointerTons3__GetCapabilitiesType(soap, (ns3__GetCapabilitiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UpdateType:
		soap_serialize_PointerTons2__UpdateType(soap, (ns2__UpdateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DeleteType:
		soap_serialize_PointerTons2__DeleteType(soap, (ns2__DeleteType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__GetResponseType:
		soap_serialize_PointerTons2__GetResponseType(soap, (ns2__GetResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__GetType:
		soap_serialize_PointerTons2__GetType(soap, (ns2__GetType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CreateResponseType:
		soap_serialize_PointerTons2__CreateResponseType(soap, (ns2__CreateResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CreateType:
		soap_serialize_PointerTons2__CreateType(soap, (ns2__CreateType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OrganizationType:
		soap_serialize_PointerTons2__OrganizationType(soap, (ns2__OrganizationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DetailedPlaceInfoType:
		soap_serialize_PointerTons2__DetailedPlaceInfoType(soap, (ns2__DetailedPlaceInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CIDNE_USCORECMODailyReportType:
		soap_serialize_PointerTons2__CIDNE_USCORECMODailyReportType(soap, (ns2__CIDNE_USCORECMODailyReportType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HTSAreaAssessmentType:
		soap_serialize_PointerTons2__HTSAreaAssessmentType(soap, (ns2__HTSAreaAssessmentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CIDNE_USCOREPersonType:
		soap_serialize_PointerTons2__CIDNE_USCOREPersonType(soap, (ns2__CIDNE_USCOREPersonType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PeopleType:
		soap_serialize_PointerTons2__PeopleType(soap, (ns2__PeopleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CategoryListType:
		soap_serialize_PointerTons2__CategoryListType(soap, (ns2__CategoryListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MediaFileUrlType:
		soap_serialize_PointerTons2__MediaFileUrlType(soap, (ns2__MediaFileUrlType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__TimePeriodType:
		soap_serialize_PointerTons3__TimePeriodType(soap, (ns3__TimePeriodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LocationListType:
		soap_serialize_PointerTons2__LocationListType(soap, (ns2__LocationListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__NonEmptyStringType:
		soap_serialize_PointerTons3__NonEmptyStringType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AbstractContentReferenceHolderType:
		soap_serialize_PointerTons2__AbstractContentReferenceHolderType(soap, (ns2__AbstractContentReferenceHolderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AbstractContentReferenceListType:
		soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, (ns2__AbstractContentReferenceListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__MediaFileFormType:
		soap_serialize_PointerTons3__MediaFileFormType(soap, (enum ns3__MediaFileFormType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__QName:
		soap_serialize_PointerToxsd__QName(soap, (xsd__QName *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SecurityInfoListType:
		soap_serialize_PointerTons2__SecurityInfoListType(soap, (ns2__SecurityInfoListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContentAssociationModelListType:
		soap_serialize_PointerTons2__ContentAssociationModelListType(soap, (ns2__ContentAssociationModelListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ForumPostUserPropertiesType:
		soap_serialize_PointerTons2__ForumPostUserPropertiesType(soap, (ns2__ForumPostUserPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ForumTopicUserPropertiesType:
		soap_serialize_PointerTons2__ForumTopicUserPropertiesType(soap, (ns2__ForumTopicUserPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CollectionUserPropertiesType:
		soap_serialize_PointerTons2__CollectionUserPropertiesType(soap, (ns2__CollectionUserPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReportUserPropertiesType:
		soap_serialize_PointerTons2__ReportUserPropertiesType(soap, (ns2__ReportUserPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PlaceUserPropertiesType:
		soap_serialize_PointerTons2__PlaceUserPropertiesType(soap, (ns2__PlaceUserPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EventUserPropertiesType:
		soap_serialize_PointerTons2__EventUserPropertiesType(soap, (ns2__EventUserPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ImageUserPropertiesType:
		soap_serialize_PointerTons2__ImageUserPropertiesType(soap, (ns2__ImageUserPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MediaUserPropertiesType:
		soap_serialize_PointerTons2__MediaUserPropertiesType(soap, (ns2__MediaUserPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AnnotationUserPropertiesType:
		soap_serialize_PointerTons2__AnnotationUserPropertiesType(soap, (ns2__AnnotationUserPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReinforcementStatusType:
		soap_serialize_PointerTons2__ReinforcementStatusType(soap, (enum ns2__ReinforcementStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TrainingStatusType:
		soap_serialize_PointerTons2__TrainingStatusType(soap, (enum ns2__TrainingStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CBRNDressStatusType:
		soap_serialize_PointerTons2__CBRNDressStatusType(soap, (enum ns2__CBRNDressStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReadinessType:
		soap_serialize_PointerTons2__ReadinessType(soap, (enum ns2__ReadinessType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CommitmentStatusType:
		soap_serialize_PointerTons2__CommitmentStatusType(soap, (enum ns2__CommitmentStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__OrganizationType_UsageStatus:
		soap_serialize_PointerTo_ns2__OrganizationType_UsageStatus(soap, (enum _ns2__OrganizationType_UsageStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AvailabilityType:
		soap_serialize_PointerTons2__AvailabilityType(soap, (enum ns2__AvailabilityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__GroupPeopleType:
		soap_serialize_PointerTons2__GroupPeopleType(soap, (enum ns2__GroupPeopleType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CommandAndControlType:
		soap_serialize_PointerTons2__CommandAndControlType(soap, (enum ns2__CommandAndControlType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__YesNoType:
		soap_serialize_PointerTons2__YesNoType(soap, (enum ns2__YesNoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SecurityStatusType:
		soap_serialize_PointerTons2__SecurityStatusType(soap, (enum ns2__SecurityStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EnemyActivityPresentType:
		soap_serialize_PointerTons2__EnemyActivityPresentType(soap, (enum ns2__EnemyActivityPresentType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus:
		soap_serialize_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(soap, (enum _ns2__DetailedPlaceInfoType_UsageStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ConstructionType:
		soap_serialize_PointerTons2__ConstructionType(soap, (enum ns2__ConstructionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OccupationStatusType:
		soap_serialize_PointerTons2__OccupationStatusType(soap, (enum ns2__OccupationStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OperationalStatus2Type:
		soap_serialize_PointerTons2__OperationalStatus2Type(soap, (enum ns2__OperationalStatus2Type *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OperationalStatusType:
		soap_serialize_PointerTons2__OperationalStatusType(soap, (enum ns2__OperationalStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UpcomingEventType:
		soap_serialize_PointerTons2__UpcomingEventType(soap, (ns2__UpcomingEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PEMSIIOutcomeType:
		soap_serialize_PointerTons2__PEMSIIOutcomeType(soap, (ns2__PEMSIIOutcomeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UpcomingEventsType:
		soap_serialize_PointerTons2__UpcomingEventsType(soap, (ns2__UpcomingEventsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AssessmentsType:
		soap_serialize_PointerTons2__AssessmentsType(soap, (ns2__AssessmentsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PEMSIIOutcomesType:
		soap_serialize_PointerTons2__PEMSIIOutcomesType(soap, (ns2__PEMSIIOutcomesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OtherIDType:
		soap_serialize_PointerTons2__OtherIDType(soap, (ns2__OtherIDType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RemarkType:
		soap_serialize_PointerTons2__RemarkType(soap, (ns2__RemarkType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LocationInfoType:
		soap_serialize_PointerTons2__LocationInfoType(soap, (ns2__LocationInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FamilyMemberInfoType:
		soap_serialize_PointerTons2__FamilyMemberInfoType(soap, (ns2__FamilyMemberInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VehicleInfoType:
		soap_serialize_PointerTons2__VehicleInfoType(soap, (ns2__VehicleInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PEMSIIType:
		soap_serialize_PointerTons2__PEMSIIType(soap, (ns2__PEMSIIType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DescriptionType:
		soap_serialize_PointerTons2__DescriptionType(soap, (ns2__DescriptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TitleAliasIdInfoType:
		soap_serialize_PointerTons2__TitleAliasIdInfoType(soap, (ns2__TitleAliasIdInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContactInfoType:
		soap_serialize_PointerTons2__ContactInfoType(soap, (ns2__ContactInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CIDNE_USCOREPersonalInfoType:
		soap_serialize_PointerTons2__CIDNE_USCOREPersonalInfoType(soap, (ns2__CIDNE_USCOREPersonalInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NameInfoType:
		soap_serialize_PointerTons2__NameInfoType(soap, (ns2__NameInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PhysicalStatus2Type:
		soap_serialize_PointerTons2__PhysicalStatus2Type(soap, (enum ns2__PhysicalStatus2Type *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PhysicalStatusType:
		soap_serialize_PointerTons2__PhysicalStatusType(soap, (enum ns2__PhysicalStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DutyStatusType:
		soap_serialize_PointerTons2__DutyStatusType(soap, (enum ns2__DutyStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__GenderType:
		soap_serialize_PointerTons2__GenderType(soap, (enum ns2__GenderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RankType:
		soap_serialize_PointerTons2__RankType(soap, (enum ns2__RankType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PeopleType2Type:
		soap_serialize_PointerTons2__PeopleType2Type(soap, (enum ns2__PeopleType2Type *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PeopleTypeType:
		soap_serialize_PointerTons2__PeopleTypeType(soap, (enum ns2__PeopleTypeType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns2__union_LocationListType:
		soap_serialize_PointerTo__ns2__union_LocationListType(soap, (__ns2__union_LocationListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__PolygonType:
		soap_serialize_PointerTons3__PolygonType(soap, (ns3__PolygonType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__LinearRingType:
		soap_serialize_PointerTons3__LinearRingType(soap, (ns3__LinearRingType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__LineStringType:
		soap_serialize_PointerTons3__LineStringType(soap, (ns3__LineStringType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__PointType:
		soap_serialize_PointerTons3__PointType(soap, (ns3__PointType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ExternalIdType:
		soap_serialize_PointerTons2__ExternalIdType(soap, (ns2__ExternalIdType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UnitType:
		soap_serialize_PointerTons2__UnitType(soap, (ns2__UnitType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContentVersionInfoListType:
		soap_serialize_PointerTons2__ContentVersionInfoListType(soap, (ns2__ContentVersionInfoListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns2__union_AbstractContentReferenceListType:
		soap_serialize_PointerTo__ns2__union_AbstractContentReferenceListType(soap, (__ns2__union_AbstractContentReferenceListType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContentVersionInfoType:
		soap_serialize_PointerTons2__ContentVersionInfoType(soap, (ns2__ContentVersionInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UserInfoType:
		soap_serialize_PointerTons2__UserInfoType(soap, (ns2__UserInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContentAssociationModelType:
		soap_serialize_PointerTons2__ContentAssociationModelType(soap, (ns2__ContentAssociationModelType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__NMTOKEN:
		soap_serialize_PointerToxsd__NMTOKEN(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContentAssociationModelMemberType:
		soap_serialize_PointerTons2__ContentAssociationModelMemberType(soap, (ns2__ContentAssociationModelMemberType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		soap_serialize_PointerToxsd__nonNegativeInteger(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__ns2__union_GetResponseType:
		soap_serialize_PointerTo__ns2__union_GetResponseType(soap, (__ns2__union_GetResponseType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContentIdentifierReferenceType:
		soap_serialize_PointerTons2__ContentIdentifierReferenceType(soap, (ns2__ContentIdentifierReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DeletedType:
		soap_serialize_PointerTons2__DeletedType(soap, (ns2__DeletedType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ForumPostType:
		soap_serialize_PointerTons2__ForumPostType(soap, (ns2__ForumPostType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ForumTopicType:
		soap_serialize_PointerTons2__ForumTopicType(soap, (ns2__ForumTopicType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SpecialCollectionType:
		soap_serialize_PointerTons2__SpecialCollectionType(soap, (ns2__SpecialCollectionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CollectionType:
		soap_serialize_PointerTons2__CollectionType(soap, (ns2__CollectionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SpecialReportType:
		soap_serialize_PointerTons2__SpecialReportType(soap, (ns2__SpecialReportType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReportType:
		soap_serialize_PointerTons2__ReportType(soap, (ns2__ReportType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SpecialPlaceType:
		soap_serialize_PointerTons2__SpecialPlaceType(soap, (ns2__SpecialPlaceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PlaceType:
		soap_serialize_PointerTons2__PlaceType(soap, (ns2__PlaceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EventType:
		soap_serialize_PointerTons2__EventType(soap, (ns2__EventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ImageType:
		soap_serialize_PointerTons2__ImageType(soap, (ns2__ImageType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MediaType:
		soap_serialize_PointerTons2__MediaType(soap, (ns2__MediaType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AnnotationType:
		soap_serialize_PointerTons2__AnnotationType(soap, (ns2__AnnotationType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__From:
		soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemIRI:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__Action:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__To:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__wsa5__MessageID:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Security:
		soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureType:
		soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformType:
		soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DigestMethodType:
		soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformsType:
		soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__ReferenceType:
		soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509DataType:
		soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyValueType:
		soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyInfoType:
		soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignedInfoType:
		soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Reference:
		soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Password:
		soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE__wsu__Timestamp:
		return (void*)soap_instantiate__wsu__Timestamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__UsernameToken:
		return (void*)soap_instantiate__wsse__UsernameToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return (void*)soap_instantiate__wsse__BinarySecurityToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Reference:
		return (void*)soap_instantiate__wsse__Reference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Embedded:
		return (void*)soap_instantiate__wsse__Embedded(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return (void*)soap_instantiate__wsse__KeyIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return (void*)soap_instantiate__wsse__SecurityTokenReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignatureType:
		return (void*)soap_instantiate_ds__SignatureType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return (void*)soap_instantiate__c14n__InclusiveNamespaces(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__TransformType:
		return (void*)soap_instantiate_ds__TransformType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__KeyInfoType:
		return (void*)soap_instantiate_ds__KeyInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignedInfoType:
		return (void*)soap_instantiate_ds__SignedInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return (void*)soap_instantiate_ds__CanonicalizationMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignatureMethodType:
		return (void*)soap_instantiate_ds__SignatureMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__ReferenceType:
		return (void*)soap_instantiate_ds__ReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__TransformsType:
		return (void*)soap_instantiate_ds__TransformsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__DigestMethodType:
		return (void*)soap_instantiate_ds__DigestMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__KeyValueType:
		return (void*)soap_instantiate_ds__KeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__RetrievalMethodType:
		return (void*)soap_instantiate_ds__RetrievalMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__X509DataType:
		return (void*)soap_instantiate_ds__X509DataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return (void*)soap_instantiate_ds__X509IssuerSerialType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__DSAKeyValueType:
		return (void*)soap_instantiate_ds__DSAKeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__RSAKeyValueType:
		return (void*)soap_instantiate_ds__RSAKeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Security:
		return (void*)soap_instantiate__wsse__Security(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Password:
		return (void*)soap_instantiate__wsse__Password(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return (void*)soap_instantiate_wsa5__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return (void*)soap_instantiate_wsa5__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__MetadataType:
		return (void*)soap_instantiate_wsa5__MetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return (void*)soap_instantiate_wsa5__ProblemActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__RelatesToType:
		return (void*)soap_instantiate_wsa5__RelatesToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CreateResponseType:
		return (void*)soap_instantiate_ns2__CreateResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UpdateResponseType:
		return (void*)soap_instantiate_ns2__UpdateResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DeleteResponseType:
		return (void*)soap_instantiate_ns2__DeleteResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__union_GetResponseType:
		return (void*)soap_instantiate___ns2__union_GetResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__GetResponseType:
		return (void*)soap_instantiate_ns2__GetResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ContentAssociationModelType:
		return (void*)soap_instantiate_ns2__ContentAssociationModelType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ContentAssociationModelMemberType:
		return (void*)soap_instantiate_ns2__ContentAssociationModelMemberType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ContentAssociationModelListType:
		return (void*)soap_instantiate_ns2__ContentAssociationModelListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SecurityInfoListType:
		return (void*)soap_instantiate_ns2__SecurityInfoListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ExternalIdType:
		return (void*)soap_instantiate_ns2__ExternalIdType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UserInfoType:
		return (void*)soap_instantiate_ns2__UserInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ContentVersionInfoType:
		return (void*)soap_instantiate_ns2__ContentVersionInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ContentVersionInfoListType:
		return (void*)soap_instantiate_ns2__ContentVersionInfoListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AbstractContentReferenceType:
		return (void*)soap_instantiate_ns2__AbstractContentReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__union_AbstractContentReferenceListType:
		return (void*)soap_instantiate___ns2__union_AbstractContentReferenceListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AbstractContentReferenceListType:
		return (void*)soap_instantiate_ns2__AbstractContentReferenceListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AbstractContentReferenceHolderType:
		return (void*)soap_instantiate_ns2__AbstractContentReferenceHolderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AbstractContentType:
		return (void*)soap_instantiate_ns2__AbstractContentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AbstractContentUserPropertiesType:
		return (void*)soap_instantiate_ns2__AbstractContentUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__union_LocationListType:
		return (void*)soap_instantiate___ns2__union_LocationListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LocationListType:
		return (void*)soap_instantiate_ns2__LocationListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CategoryListType:
		return (void*)soap_instantiate_ns2__CategoryListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PeopleType:
		return (void*)soap_instantiate_ns2__PeopleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CIDNE_USCOREPersonType:
		return (void*)soap_instantiate_ns2__CIDNE_USCOREPersonType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NameInfoType:
		return (void*)soap_instantiate_ns2__NameInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType:
		return (void*)soap_instantiate_ns2__CIDNE_USCOREPersonalInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ContactInfoType:
		return (void*)soap_instantiate_ns2__ContactInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OtherIDType:
		return (void*)soap_instantiate_ns2__OtherIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TitleAliasIdInfoType:
		return (void*)soap_instantiate_ns2__TitleAliasIdInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DescriptionType:
		return (void*)soap_instantiate_ns2__DescriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PEMSIIType:
		return (void*)soap_instantiate_ns2__PEMSIIType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VehicleInfoType:
		return (void*)soap_instantiate_ns2__VehicleInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FamilyMemberInfoType:
		return (void*)soap_instantiate_ns2__FamilyMemberInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LocationInfoType:
		return (void*)soap_instantiate_ns2__LocationInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RemarkType:
		return (void*)soap_instantiate_ns2__RemarkType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HTSAreaAssessmentType:
		return (void*)soap_instantiate_ns2__HTSAreaAssessmentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType:
		return (void*)soap_instantiate_ns2__CIDNE_USCORECMODailyReportType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PEMSIIOutcomesType:
		return (void*)soap_instantiate_ns2__PEMSIIOutcomesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PEMSIIOutcomeType:
		return (void*)soap_instantiate_ns2__PEMSIIOutcomeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AssessmentsType:
		return (void*)soap_instantiate_ns2__AssessmentsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UpcomingEventsType:
		return (void*)soap_instantiate_ns2__UpcomingEventsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UpcomingEventType:
		return (void*)soap_instantiate_ns2__UpcomingEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DetailedPlaceInfoType:
		return (void*)soap_instantiate_ns2__DetailedPlaceInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OrganizationType:
		return (void*)soap_instantiate_ns2__OrganizationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__TimePeriodType:
		return (void*)soap_instantiate_ns3__TimePeriodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__BaseRequestType:
		return (void*)soap_instantiate_ns3__BaseRequestType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__BaseServiceCapabilitiesType:
		return (void*)soap_instantiate_ns3__BaseServiceCapabilitiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__EnvelopeType:
		return (void*)soap_instantiate_ns3__EnvelopeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__AbstractGeometryType:
		return (void*)soap_instantiate_ns3__AbstractGeometryType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CreateType:
		return (void*)soap_instantiate_ns2__CreateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UpdateType:
		return (void*)soap_instantiate_ns2__UpdateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DeleteType:
		return (void*)soap_instantiate_ns2__DeleteType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__GetType:
		return (void*)soap_instantiate_ns2__GetType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ContentServiceCapabilitiesType:
		return (void*)soap_instantiate_ns2__ContentServiceCapabilitiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UnitType:
		return (void*)soap_instantiate_ns2__UnitType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ContentIdentifierReferenceType:
		return (void*)soap_instantiate_ns2__ContentIdentifierReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AnnotationUserPropertiesType:
		return (void*)soap_instantiate_ns2__AnnotationUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AnnotationType:
		return (void*)soap_instantiate_ns2__AnnotationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MediaUserPropertiesType:
		return (void*)soap_instantiate_ns2__MediaUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MediaFileUrlType:
		return (void*)soap_instantiate_ns2__MediaFileUrlType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MediaType:
		return (void*)soap_instantiate_ns2__MediaType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__EventUserPropertiesType:
		return (void*)soap_instantiate_ns2__EventUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__EventType:
		return (void*)soap_instantiate_ns2__EventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PlaceUserPropertiesType:
		return (void*)soap_instantiate_ns2__PlaceUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PlaceType:
		return (void*)soap_instantiate_ns2__PlaceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ReportUserPropertiesType:
		return (void*)soap_instantiate_ns2__ReportUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ReportType:
		return (void*)soap_instantiate_ns2__ReportType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CollectionUserPropertiesType:
		return (void*)soap_instantiate_ns2__CollectionUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CollectionType:
		return (void*)soap_instantiate_ns2__CollectionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ForumTopicUserPropertiesType:
		return (void*)soap_instantiate_ns2__ForumTopicUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ForumTopicType:
		return (void*)soap_instantiate_ns2__ForumTopicType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ForumPostUserPropertiesType:
		return (void*)soap_instantiate_ns2__ForumPostUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ForumPostType:
		return (void*)soap_instantiate_ns2__ForumPostType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DeletedType:
		return (void*)soap_instantiate_ns2__DeletedType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__GetCapabilitiesType:
		return (void*)soap_instantiate_ns3__GetCapabilitiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__PointType:
		return (void*)soap_instantiate_ns3__PointType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__LineStringType:
		return (void*)soap_instantiate_ns3__LineStringType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__LinearRingType:
		return (void*)soap_instantiate_ns3__LinearRingType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__PolygonType:
		return (void*)soap_instantiate_ns3__PolygonType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ImageUserPropertiesType:
		return (void*)soap_instantiate_ns2__ImageUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ImageType:
		return (void*)soap_instantiate_ns2__ImageType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SpecialReportUserPropertiesType:
		return (void*)soap_instantiate_ns2__SpecialReportUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SpecialReportType:
		return (void*)soap_instantiate_ns2__SpecialReportType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType:
		return (void*)soap_instantiate_ns2__SpecialPlaceUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SpecialPlaceType:
		return (void*)soap_instantiate_ns2__SpecialPlaceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType:
		return (void*)soap_instantiate_ns2__SpecialCollectionUserPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SpecialCollectionType:
		return (void*)soap_instantiate_ns2__SpecialCollectionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__CreateOperation:
		return (void*)soap_instantiate___ns4__CreateOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetOperation:
		return (void*)soap_instantiate___ns4__GetOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__DeleteOperationResponse:
		return (void*)soap_instantiate___ns4__DeleteOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__DeleteOperation:
		return (void*)soap_instantiate___ns4__DeleteOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__UpdateOperationResponse:
		return (void*)soap_instantiate___ns4__UpdateOperationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__UpdateOperation:
		return (void*)soap_instantiate___ns4__UpdateOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__GetCapabilitiesOperation:
		return (void*)soap_instantiate___ns4__GetCapabilitiesOperation(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE__wsa5__EndpointReference:
		return (void*)soap_instantiate__wsa5__EndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return (void*)soap_instantiate__wsa5__ReferenceParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__Metadata:
		return (void*)soap_instantiate__wsa5__Metadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__RelatesTo:
		return (void*)soap_instantiate__wsa5__RelatesTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReplyTo:
		return (void*)soap_instantiate__wsa5__ReplyTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__From:
		return (void*)soap_instantiate__wsa5__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__FaultTo:
		return (void*)soap_instantiate__wsa5__FaultTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ProblemAction:
		return (void*)soap_instantiate__wsa5__ProblemAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NMTOKEN:
		return (void*)soap_instantiate_xsd__NMTOKEN(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__positiveInteger:
		return (void*)soap_instantiate_xsd__positiveInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__QNameListType:
		return (void*)soap_instantiate_ns3__QNameListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__URIListType:
		return (void*)soap_instantiate_ns3__URIListType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__CoordinatesType:
		return (void*)soap_instantiate_ns3__CoordinatesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__NonEmptyStringType:
		return (void*)soap_instantiate_ns3__NonEmptyStringType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__MimeType:
		return (void*)soap_instantiate_ns3__MimeType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__GuidType:
		return (void*)soap_instantiate_ns3__GuidType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__VersionType:
		return (void*)soap_instantiate_ns3__VersionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MediaFileUrlType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__MediaFileUrlType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns2__MinistryType:
		return (void*)soap_instantiate_std__vectorTemplateOfns2__MinistryType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns2__KeywordType:
		return (void*)soap_instantiate_std__vectorTemplateOfns2__KeywordType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns2__AnalyticalToolMethodType:
		return (void*)soap_instantiate_std__vectorTemplateOfns2__AnalyticalToolMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns2__DataCollectionMethodType:
		return (void*)soap_instantiate_std__vectorTemplateOfns2__DataCollectionMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OtherIDType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__OtherIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RemarkType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__RemarkType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__LocationInfoType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__LocationInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__VehicleInfoType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__VehicleInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns2__RoleType:
		return (void*)soap_instantiate_std__vectorTemplateOfns2__RoleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DescriptionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__DescriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ContentVersionInfoType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ContentAssociationModelType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE__wsu__Timestamp:
		if (p->size < 0)
			SOAP_DELETE((struct _wsu__Timestamp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsu__Timestamp*)p->ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__UsernameToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__UsernameToken*)p->ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__BinarySecurityToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__BinarySecurityToken*)p->ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__Reference*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__Reference*)p->ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__Embedded*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__Embedded*)p->ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__KeyIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__KeyIdentifier*)p->ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__SecurityTokenReference*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__SecurityTokenReference*)p->ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__SignatureType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__SignatureType*)p->ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		if (p->size < 0)
			SOAP_DELETE((struct _c14n__InclusiveNamespaces*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _c14n__InclusiveNamespaces*)p->ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__TransformType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__TransformType*)p->ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__KeyInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__KeyInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__SignedInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__SignedInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__CanonicalizationMethodType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__CanonicalizationMethodType*)p->ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__SignatureMethodType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__SignatureMethodType*)p->ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__ReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__ReferenceType*)p->ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__TransformsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__TransformsType*)p->ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__DigestMethodType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__DigestMethodType*)p->ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__KeyValueType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__KeyValueType*)p->ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__RetrievalMethodType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__RetrievalMethodType*)p->ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__X509DataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__X509DataType*)p->ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__X509IssuerSerialType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__X509IssuerSerialType*)p->ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__DSAKeyValueType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__DSAKeyValueType*)p->ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		if (p->size < 0)
			SOAP_DELETE((struct ds__RSAKeyValueType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ds__RSAKeyValueType*)p->ptr);
		break;
	case SOAP_TYPE__wsse__Security:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__Security*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__Security*)p->ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		if (p->size < 0)
			SOAP_DELETE((struct _wsse__Password*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct _wsse__Password*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__ReferenceParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__ReferenceParametersType*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__MetadataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__MetadataType*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__ProblemActionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__ProblemActionType*)p->ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__RelatesToType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__RelatesToType*)p->ptr);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CreateResponseType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CreateResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CreateResponseType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__UpdateResponseType:
		if (p->size < 0)
			SOAP_DELETE((ns2__UpdateResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__UpdateResponseType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DeleteResponseType:
		if (p->size < 0)
			SOAP_DELETE((ns2__DeleteResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DeleteResponseType*)p->ptr);
		break;
	case SOAP_TYPE___ns2__union_GetResponseType:
		if (p->size < 0)
			SOAP_DELETE((__ns2__union_GetResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__union_GetResponseType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__GetResponseType:
		if (p->size < 0)
			SOAP_DELETE((ns2__GetResponseType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GetResponseType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ContentAssociationModelType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ContentAssociationModelType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ContentAssociationModelType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ContentAssociationModelMemberType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ContentAssociationModelMemberType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ContentAssociationModelMemberType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ContentAssociationModelListType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ContentAssociationModelListType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ContentAssociationModelListType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SecurityInfoListType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SecurityInfoListType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SecurityInfoListType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ExternalIdType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ExternalIdType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ExternalIdType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__UserInfoType:
		if (p->size < 0)
			SOAP_DELETE((ns2__UserInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__UserInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ContentVersionInfoType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ContentVersionInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ContentVersionInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ContentVersionInfoListType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ContentVersionInfoListType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ContentVersionInfoListType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AbstractContentReferenceType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AbstractContentReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AbstractContentReferenceType*)p->ptr);
		break;
	case SOAP_TYPE___ns2__union_AbstractContentReferenceListType:
		if (p->size < 0)
			SOAP_DELETE((__ns2__union_AbstractContentReferenceListType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__union_AbstractContentReferenceListType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AbstractContentReferenceListType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AbstractContentReferenceListType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AbstractContentReferenceListType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AbstractContentReferenceHolderType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AbstractContentReferenceHolderType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AbstractContentReferenceHolderType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AbstractContentType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AbstractContentType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AbstractContentType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AbstractContentUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AbstractContentUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AbstractContentUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE___ns2__union_LocationListType:
		if (p->size < 0)
			SOAP_DELETE((__ns2__union_LocationListType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((__ns2__union_LocationListType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__LocationListType:
		if (p->size < 0)
			SOAP_DELETE((ns2__LocationListType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__LocationListType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CategoryListType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CategoryListType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CategoryListType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__PeopleType:
		if (p->size < 0)
			SOAP_DELETE((ns2__PeopleType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__PeopleType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CIDNE_USCOREPersonType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CIDNE_USCOREPersonType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CIDNE_USCOREPersonType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NameInfoType:
		if (p->size < 0)
			SOAP_DELETE((ns2__NameInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NameInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CIDNE_USCOREPersonalInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CIDNE_USCOREPersonalInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ContactInfoType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ContactInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ContactInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OtherIDType:
		if (p->size < 0)
			SOAP_DELETE((ns2__OtherIDType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OtherIDType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__TitleAliasIdInfoType:
		if (p->size < 0)
			SOAP_DELETE((ns2__TitleAliasIdInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__TitleAliasIdInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DescriptionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__DescriptionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DescriptionType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__PEMSIIType:
		if (p->size < 0)
			SOAP_DELETE((ns2__PEMSIIType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__PEMSIIType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__VehicleInfoType:
		if (p->size < 0)
			SOAP_DELETE((ns2__VehicleInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__VehicleInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FamilyMemberInfoType:
		if (p->size < 0)
			SOAP_DELETE((ns2__FamilyMemberInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FamilyMemberInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__LocationInfoType:
		if (p->size < 0)
			SOAP_DELETE((ns2__LocationInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__LocationInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RemarkType:
		if (p->size < 0)
			SOAP_DELETE((ns2__RemarkType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RemarkType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__HTSAreaAssessmentType:
		if (p->size < 0)
			SOAP_DELETE((ns2__HTSAreaAssessmentType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__HTSAreaAssessmentType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CIDNE_USCORECMODailyReportType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CIDNE_USCORECMODailyReportType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__PEMSIIOutcomesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__PEMSIIOutcomesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__PEMSIIOutcomesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__PEMSIIOutcomeType:
		if (p->size < 0)
			SOAP_DELETE((ns2__PEMSIIOutcomeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__PEMSIIOutcomeType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AssessmentsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AssessmentsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AssessmentsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__UpcomingEventsType:
		if (p->size < 0)
			SOAP_DELETE((ns2__UpcomingEventsType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__UpcomingEventsType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__UpcomingEventType:
		if (p->size < 0)
			SOAP_DELETE((ns2__UpcomingEventType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__UpcomingEventType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DetailedPlaceInfoType:
		if (p->size < 0)
			SOAP_DELETE((ns2__DetailedPlaceInfoType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DetailedPlaceInfoType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OrganizationType:
		if (p->size < 0)
			SOAP_DELETE((ns2__OrganizationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OrganizationType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__TimePeriodType:
		if (p->size < 0)
			SOAP_DELETE((ns3__TimePeriodType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__TimePeriodType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__BaseRequestType:
		if (p->size < 0)
			SOAP_DELETE((ns3__BaseRequestType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__BaseRequestType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__BaseServiceCapabilitiesType:
		if (p->size < 0)
			SOAP_DELETE((ns3__BaseServiceCapabilitiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__BaseServiceCapabilitiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__EnvelopeType:
		if (p->size < 0)
			SOAP_DELETE((ns3__EnvelopeType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__EnvelopeType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__AbstractGeometryType:
		if (p->size < 0)
			SOAP_DELETE((ns3__AbstractGeometryType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__AbstractGeometryType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CreateType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CreateType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CreateType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__UpdateType:
		if (p->size < 0)
			SOAP_DELETE((ns2__UpdateType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__UpdateType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DeleteType:
		if (p->size < 0)
			SOAP_DELETE((ns2__DeleteType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DeleteType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__GetType:
		if (p->size < 0)
			SOAP_DELETE((ns2__GetType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GetType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ContentServiceCapabilitiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ContentServiceCapabilitiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ContentServiceCapabilitiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__UnitType:
		if (p->size < 0)
			SOAP_DELETE((ns2__UnitType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__UnitType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ContentIdentifierReferenceType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ContentIdentifierReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ContentIdentifierReferenceType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AnnotationUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AnnotationUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AnnotationUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AnnotationType:
		if (p->size < 0)
			SOAP_DELETE((ns2__AnnotationType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AnnotationType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MediaUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MediaUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MediaUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MediaFileUrlType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MediaFileUrlType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MediaFileUrlType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MediaType:
		if (p->size < 0)
			SOAP_DELETE((ns2__MediaType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MediaType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__EventUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__EventUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__EventUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__EventType:
		if (p->size < 0)
			SOAP_DELETE((ns2__EventType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__EventType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__PlaceUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__PlaceUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__PlaceUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__PlaceType:
		if (p->size < 0)
			SOAP_DELETE((ns2__PlaceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__PlaceType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ReportUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ReportUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ReportUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ReportType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ReportType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ReportType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CollectionUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CollectionUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CollectionUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CollectionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__CollectionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CollectionType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ForumTopicUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ForumTopicUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ForumTopicUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ForumTopicType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ForumTopicType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ForumTopicType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ForumPostUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ForumPostUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ForumPostUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ForumPostType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ForumPostType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ForumPostType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DeletedType:
		if (p->size < 0)
			SOAP_DELETE((ns2__DeletedType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DeletedType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__GetCapabilitiesType:
		if (p->size < 0)
			SOAP_DELETE((ns3__GetCapabilitiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__GetCapabilitiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__PointType:
		if (p->size < 0)
			SOAP_DELETE((ns3__PointType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__PointType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__LineStringType:
		if (p->size < 0)
			SOAP_DELETE((ns3__LineStringType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__LineStringType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__LinearRingType:
		if (p->size < 0)
			SOAP_DELETE((ns3__LinearRingType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__LinearRingType*)p->ptr);
		break;
	case SOAP_TYPE_ns3__PolygonType:
		if (p->size < 0)
			SOAP_DELETE((ns3__PolygonType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__PolygonType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ImageUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ImageUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ImageUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ImageType:
		if (p->size < 0)
			SOAP_DELETE((ns2__ImageType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ImageType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SpecialReportUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SpecialReportUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SpecialReportUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SpecialReportType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SpecialReportType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SpecialReportType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SpecialPlaceUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SpecialPlaceUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SpecialPlaceType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SpecialPlaceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SpecialPlaceType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SpecialCollectionUserPropertiesType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SpecialCollectionUserPropertiesType*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SpecialCollectionType:
		if (p->size < 0)
			SOAP_DELETE((ns2__SpecialCollectionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SpecialCollectionType*)p->ptr);
		break;
	case SOAP_TYPE___ns4__CreateOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__CreateOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__CreateOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns4__DeleteOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__DeleteOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__DeleteOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns4__DeleteOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__DeleteOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__DeleteOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns4__UpdateOperationResponse:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__UpdateOperationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__UpdateOperationResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns4__UpdateOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__UpdateOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__UpdateOperation*)p->ptr);
		break;
	case SOAP_TYPE___ns4__GetCapabilitiesOperation:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__GetCapabilitiesOperation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__GetCapabilitiesOperation*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__ReferenceParametersType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__ReferenceParametersType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__MetadataType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__MetadataType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__RelatesToType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__RelatesToType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__EndpointReferenceType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__EndpointReferenceType*)p->ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		if (p->size < 0)
			SOAP_DELETE((struct wsa5__ProblemActionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct wsa5__ProblemActionType*)p->ptr);
		break;
	case SOAP_TYPE_xsd__NMTOKEN:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE((xsd__QName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__QName*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__positiveInteger:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns3__QNameListType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns3__URIListType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns3__CoordinatesType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns3__NonEmptyStringType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns3__MimeType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns3__GuidType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns3__VersionType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MediaFileUrlType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__MediaFileUrlType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__MediaFileUrlType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__MinistryType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum ns2__MinistryType >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum ns2__MinistryType >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__KeywordType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum ns2__KeywordType >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum ns2__KeywordType >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__AnalyticalToolMethodType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum ns2__AnalyticalToolMethodType >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum ns2__AnalyticalToolMethodType >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__DataCollectionMethodType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum ns2__DataCollectionMethodType >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum ns2__DataCollectionMethodType >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OtherIDType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__OtherIDType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__OtherIDType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RemarkType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__RemarkType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__RemarkType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__LocationInfoType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__LocationInfoType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__LocationInfoType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__FamilyMemberInfoType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__FamilyMemberInfoType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__VehicleInfoType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__VehicleInfoType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__VehicleInfoType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__RoleType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum ns2__RoleType >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum ns2__RoleType >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DescriptionType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__DescriptionType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__DescriptionType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ContentVersionInfoType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ContentVersionInfoType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ContentVersionInfoType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ContentAssociationModelType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__ContentAssociationModelType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__ContentAssociationModelType * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MediaFileUrlType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__MediaFileUrlType * >*)p)[len] = *(ns2__MediaFileUrlType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__MinistryType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum ns2__MinistryType >*)p)[len] = *(enum ns2__MinistryType *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__KeywordType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum ns2__KeywordType >*)p)[len] = *(enum ns2__KeywordType *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__AnalyticalToolMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum ns2__AnalyticalToolMethodType >*)p)[len] = *(enum ns2__AnalyticalToolMethodType *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__DataCollectionMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum ns2__DataCollectionMethodType >*)p)[len] = *(enum ns2__DataCollectionMethodType *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OtherIDType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__OtherIDType * >*)p)[len] = *(ns2__OtherIDType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RemarkType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__RemarkType * >*)p)[len] = *(ns2__RemarkType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__LocationInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__LocationInfoType * >*)p)[len] = *(ns2__LocationInfoType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__FamilyMemberInfoType * >*)p)[len] = *(ns2__FamilyMemberInfoType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__VehicleInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__VehicleInfoType * >*)p)[len] = *(ns2__VehicleInfoType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns2__RoleType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum ns2__RoleType >*)p)[len] = *(enum ns2__RoleType *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DescriptionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__DescriptionType * >*)p)[len] = *(ns2__DescriptionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ContentVersionInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ContentVersionInfoType * >*)p)[len] = *(ns2__ContentVersionInfoType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__ContentAssociationModelType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__ContentAssociationModelType * >*)p)[len] = *(ns2__ContentAssociationModelType **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
	p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__OrganizationType_UsageStatus(struct soap *soap, enum _ns2__OrganizationType_UsageStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns2__OrganizationType_UsageStatus
	*a = SOAP_DEFAULT__ns2__OrganizationType_UsageStatus;
#else
	*a = (enum _ns2__OrganizationType_UsageStatus)0;
#endif
}

static const struct soap_code_map soap_codes__ns2__OrganizationType_UsageStatus[] =
{	{ (long)_ns2__OrganizationType_UsageStatus__In_x0020action, "In action" },
	{ (long)_ns2__OrganizationType_UsageStatus__Out_x0020of_x0020action, "Out of action" },
	{ (long)_ns2__OrganizationType_UsageStatus__Not_x0020known, "Not known" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns2__OrganizationType_UsageStatus2s(struct soap *soap, enum _ns2__OrganizationType_UsageStatus n)
{	const char *s = soap_code_str(soap_codes__ns2__OrganizationType_UsageStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__OrganizationType_UsageStatus(struct soap *soap, const char *tag, int id, const enum _ns2__OrganizationType_UsageStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__OrganizationType_UsageStatus), type) || soap_send(soap, soap__ns2__OrganizationType_UsageStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns2__OrganizationType_UsageStatus(struct soap *soap, const char *s, enum _ns2__OrganizationType_UsageStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns2__OrganizationType_UsageStatus, s);
	if (map)
		*a = (enum _ns2__OrganizationType_UsageStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns2__OrganizationType_UsageStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns2__OrganizationType_UsageStatus * SOAP_FMAC4 soap_in__ns2__OrganizationType_UsageStatus(struct soap *soap, const char *tag, enum _ns2__OrganizationType_UsageStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns2__OrganizationType_UsageStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__OrganizationType_UsageStatus, sizeof(enum _ns2__OrganizationType_UsageStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns2__OrganizationType_UsageStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns2__OrganizationType_UsageStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__OrganizationType_UsageStatus, 0, sizeof(enum _ns2__OrganizationType_UsageStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__OrganizationType_UsageStatus(struct soap *soap, const enum _ns2__OrganizationType_UsageStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__OrganizationType_UsageStatus);
	if (soap_out__ns2__OrganizationType_UsageStatus(soap, tag?tag:"ns2:OrganizationType-UsageStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__OrganizationType_UsageStatus * SOAP_FMAC4 soap_get__ns2__OrganizationType_UsageStatus(struct soap *soap, enum _ns2__OrganizationType_UsageStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__OrganizationType_UsageStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__DetailedPlaceInfoType_UsageStatus(struct soap *soap, enum _ns2__DetailedPlaceInfoType_UsageStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns2__DetailedPlaceInfoType_UsageStatus
	*a = SOAP_DEFAULT__ns2__DetailedPlaceInfoType_UsageStatus;
#else
	*a = (enum _ns2__DetailedPlaceInfoType_UsageStatus)0;
#endif
}

static const struct soap_code_map soap_codes__ns2__DetailedPlaceInfoType_UsageStatus[] =
{	{ (long)_ns2__DetailedPlaceInfoType_UsageStatus__Activated, "Activated" },
	{ (long)_ns2__DetailedPlaceInfoType_UsageStatus__Deactivated, "Deactivated" },
	{ (long)_ns2__DetailedPlaceInfoType_UsageStatus__Not_x0020known, "Not known" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns2__DetailedPlaceInfoType_UsageStatus2s(struct soap *soap, enum _ns2__DetailedPlaceInfoType_UsageStatus n)
{	const char *s = soap_code_str(soap_codes__ns2__DetailedPlaceInfoType_UsageStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__DetailedPlaceInfoType_UsageStatus(struct soap *soap, const char *tag, int id, const enum _ns2__DetailedPlaceInfoType_UsageStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__DetailedPlaceInfoType_UsageStatus), type) || soap_send(soap, soap__ns2__DetailedPlaceInfoType_UsageStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns2__DetailedPlaceInfoType_UsageStatus(struct soap *soap, const char *s, enum _ns2__DetailedPlaceInfoType_UsageStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns2__DetailedPlaceInfoType_UsageStatus, s);
	if (map)
		*a = (enum _ns2__DetailedPlaceInfoType_UsageStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns2__DetailedPlaceInfoType_UsageStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns2__DetailedPlaceInfoType_UsageStatus * SOAP_FMAC4 soap_in__ns2__DetailedPlaceInfoType_UsageStatus(struct soap *soap, const char *tag, enum _ns2__DetailedPlaceInfoType_UsageStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns2__DetailedPlaceInfoType_UsageStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__DetailedPlaceInfoType_UsageStatus, sizeof(enum _ns2__DetailedPlaceInfoType_UsageStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns2__DetailedPlaceInfoType_UsageStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns2__DetailedPlaceInfoType_UsageStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__DetailedPlaceInfoType_UsageStatus, 0, sizeof(enum _ns2__DetailedPlaceInfoType_UsageStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__DetailedPlaceInfoType_UsageStatus(struct soap *soap, const enum _ns2__DetailedPlaceInfoType_UsageStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__DetailedPlaceInfoType_UsageStatus);
	if (soap_out__ns2__DetailedPlaceInfoType_UsageStatus(soap, tag?tag:"ns2:DetailedPlaceInfoType-UsageStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__DetailedPlaceInfoType_UsageStatus * SOAP_FMAC4 soap_get__ns2__DetailedPlaceInfoType_UsageStatus(struct soap *soap, enum _ns2__DetailedPlaceInfoType_UsageStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__DetailedPlaceInfoType_UsageStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__DeleteResponseType_status(struct soap *soap, enum _ns2__DeleteResponseType_status *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns2__DeleteResponseType_status
	*a = SOAP_DEFAULT__ns2__DeleteResponseType_status;
#else
	*a = (enum _ns2__DeleteResponseType_status)0;
#endif
}

static const struct soap_code_map soap_codes__ns2__DeleteResponseType_status[] =
{	{ (long)_ns2__DeleteResponseType_status__Success, "Success" },
	{ (long)_ns2__DeleteResponseType_status__Failed, "Failed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns2__DeleteResponseType_status2s(struct soap *soap, enum _ns2__DeleteResponseType_status n)
{	const char *s = soap_code_str(soap_codes__ns2__DeleteResponseType_status, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__DeleteResponseType_status(struct soap *soap, const char *tag, int id, const enum _ns2__DeleteResponseType_status *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__DeleteResponseType_status), type) || soap_send(soap, soap__ns2__DeleteResponseType_status2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns2__DeleteResponseType_status(struct soap *soap, const char *s, enum _ns2__DeleteResponseType_status *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns2__DeleteResponseType_status, s);
	if (map)
		*a = (enum _ns2__DeleteResponseType_status)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns2__DeleteResponseType_status)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns2__DeleteResponseType_status * SOAP_FMAC4 soap_in__ns2__DeleteResponseType_status(struct soap *soap, const char *tag, enum _ns2__DeleteResponseType_status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns2__DeleteResponseType_status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__DeleteResponseType_status, sizeof(enum _ns2__DeleteResponseType_status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns2__DeleteResponseType_status(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns2__DeleteResponseType_status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__DeleteResponseType_status, 0, sizeof(enum _ns2__DeleteResponseType_status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__DeleteResponseType_status(struct soap *soap, const enum _ns2__DeleteResponseType_status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__DeleteResponseType_status);
	if (soap_out__ns2__DeleteResponseType_status(soap, tag?tag:"ns2:DeleteResponseType-status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__DeleteResponseType_status * SOAP_FMAC4 soap_get__ns2__DeleteResponseType_status(struct soap *soap, enum _ns2__DeleteResponseType_status *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__DeleteResponseType_status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__UpdateResponseType_status(struct soap *soap, enum _ns2__UpdateResponseType_status *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__ns2__UpdateResponseType_status
	*a = SOAP_DEFAULT__ns2__UpdateResponseType_status;
#else
	*a = (enum _ns2__UpdateResponseType_status)0;
#endif
}

static const struct soap_code_map soap_codes__ns2__UpdateResponseType_status[] =
{	{ (long)_ns2__UpdateResponseType_status__Success, "Success" },
	{ (long)_ns2__UpdateResponseType_status__Failed, "Failed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__ns2__UpdateResponseType_status2s(struct soap *soap, enum _ns2__UpdateResponseType_status n)
{	const char *s = soap_code_str(soap_codes__ns2__UpdateResponseType_status, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__UpdateResponseType_status(struct soap *soap, const char *tag, int id, const enum _ns2__UpdateResponseType_status *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__UpdateResponseType_status), type) || soap_send(soap, soap__ns2__UpdateResponseType_status2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_ns2__UpdateResponseType_status(struct soap *soap, const char *s, enum _ns2__UpdateResponseType_status *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__ns2__UpdateResponseType_status, s);
	if (map)
		*a = (enum _ns2__UpdateResponseType_status)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _ns2__UpdateResponseType_status)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _ns2__UpdateResponseType_status * SOAP_FMAC4 soap_in__ns2__UpdateResponseType_status(struct soap *soap, const char *tag, enum _ns2__UpdateResponseType_status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _ns2__UpdateResponseType_status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__UpdateResponseType_status, sizeof(enum _ns2__UpdateResponseType_status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_ns2__UpdateResponseType_status(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _ns2__UpdateResponseType_status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__UpdateResponseType_status, 0, sizeof(enum _ns2__UpdateResponseType_status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__UpdateResponseType_status(struct soap *soap, const enum _ns2__UpdateResponseType_status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__UpdateResponseType_status);
	if (soap_out__ns2__UpdateResponseType_status(soap, tag?tag:"ns2:UpdateResponseType-status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__UpdateResponseType_status * SOAP_FMAC4 soap_get__ns2__UpdateResponseType_status(struct soap *soap, enum _ns2__UpdateResponseType_status *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__UpdateResponseType_status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns3__MediaFileFormType(struct soap *soap, enum ns3__MediaFileFormType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns3__MediaFileFormType
	*a = SOAP_DEFAULT_ns3__MediaFileFormType;
#else
	*a = (enum ns3__MediaFileFormType)0;
#endif
}

static const struct soap_code_map soap_codes_ns3__MediaFileFormType[] =
{	{ (long)ns3__MediaFileFormType__FullSize, "FullSize" },
	{ (long)ns3__MediaFileFormType__MediumSize, "MediumSize" },
	{ (long)ns3__MediaFileFormType__SmallSize, "SmallSize" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns3__MediaFileFormType2s(struct soap *soap, enum ns3__MediaFileFormType n)
{	const char *s = soap_code_str(soap_codes_ns3__MediaFileFormType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__MediaFileFormType(struct soap *soap, const char *tag, int id, const enum ns3__MediaFileFormType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__MediaFileFormType), type) || soap_send(soap, soap_ns3__MediaFileFormType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns3__MediaFileFormType(struct soap *soap, const char *s, enum ns3__MediaFileFormType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns3__MediaFileFormType, s);
	if (map)
		*a = (enum ns3__MediaFileFormType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns3__MediaFileFormType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns3__MediaFileFormType * SOAP_FMAC4 soap_in_ns3__MediaFileFormType(struct soap *soap, const char *tag, enum ns3__MediaFileFormType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns3__MediaFileFormType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__MediaFileFormType, sizeof(enum ns3__MediaFileFormType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns3__MediaFileFormType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns3__MediaFileFormType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__MediaFileFormType, 0, sizeof(enum ns3__MediaFileFormType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__MediaFileFormType(struct soap *soap, const enum ns3__MediaFileFormType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__MediaFileFormType);
	if (soap_out_ns3__MediaFileFormType(soap, tag?tag:"ns3:MediaFileFormType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__MediaFileFormType * SOAP_FMAC4 soap_get_ns3__MediaFileFormType(struct soap *soap, enum ns3__MediaFileFormType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__MediaFileFormType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ReinforcementStatusType(struct soap *soap, enum ns2__ReinforcementStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ReinforcementStatusType
	*a = SOAP_DEFAULT_ns2__ReinforcementStatusType;
#else
	*a = (enum ns2__ReinforcementStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ReinforcementStatusType[] =
{	{ (long)ns2__ReinforcementStatusType__Detached_x0020only, "Detached only" },
	{ (long)ns2__ReinforcementStatusType__Normal_x0020strength, "Normal strength" },
	{ (long)ns2__ReinforcementStatusType__Reinforced_x0020and_x0020detached, "Reinforced and detached" },
	{ (long)ns2__ReinforcementStatusType__Reinforced_x0020only, "Reinforced only" },
	{ (long)ns2__ReinforcementStatusType__Not_x0020known, "Not known" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ReinforcementStatusType2s(struct soap *soap, enum ns2__ReinforcementStatusType n)
{	const char *s = soap_code_str(soap_codes_ns2__ReinforcementStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReinforcementStatusType(struct soap *soap, const char *tag, int id, const enum ns2__ReinforcementStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReinforcementStatusType), type) || soap_send(soap, soap_ns2__ReinforcementStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ReinforcementStatusType(struct soap *soap, const char *s, enum ns2__ReinforcementStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ReinforcementStatusType, s);
	if (map)
		*a = (enum ns2__ReinforcementStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ReinforcementStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ReinforcementStatusType * SOAP_FMAC4 soap_in_ns2__ReinforcementStatusType(struct soap *soap, const char *tag, enum ns2__ReinforcementStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ReinforcementStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReinforcementStatusType, sizeof(enum ns2__ReinforcementStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ReinforcementStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ReinforcementStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReinforcementStatusType, 0, sizeof(enum ns2__ReinforcementStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ReinforcementStatusType(struct soap *soap, const enum ns2__ReinforcementStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ReinforcementStatusType);
	if (soap_out_ns2__ReinforcementStatusType(soap, tag?tag:"ns2:ReinforcementStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ReinforcementStatusType * SOAP_FMAC4 soap_get_ns2__ReinforcementStatusType(struct soap *soap, enum ns2__ReinforcementStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReinforcementStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TrainingStatusType(struct soap *soap, enum ns2__TrainingStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__TrainingStatusType
	*a = SOAP_DEFAULT_ns2__TrainingStatusType;
#else
	*a = (enum ns2__TrainingStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__TrainingStatusType[] =
{	{ (long)ns2__TrainingStatusType__Amber, "Amber" },
	{ (long)ns2__TrainingStatusType__Green, "Green" },
	{ (long)ns2__TrainingStatusType__Red, "Red" },
	{ (long)ns2__TrainingStatusType__Not_x0020known, "Not known" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__TrainingStatusType2s(struct soap *soap, enum ns2__TrainingStatusType n)
{	const char *s = soap_code_str(soap_codes_ns2__TrainingStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TrainingStatusType(struct soap *soap, const char *tag, int id, const enum ns2__TrainingStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TrainingStatusType), type) || soap_send(soap, soap_ns2__TrainingStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__TrainingStatusType(struct soap *soap, const char *s, enum ns2__TrainingStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__TrainingStatusType, s);
	if (map)
		*a = (enum ns2__TrainingStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__TrainingStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__TrainingStatusType * SOAP_FMAC4 soap_in_ns2__TrainingStatusType(struct soap *soap, const char *tag, enum ns2__TrainingStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__TrainingStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TrainingStatusType, sizeof(enum ns2__TrainingStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__TrainingStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__TrainingStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TrainingStatusType, 0, sizeof(enum ns2__TrainingStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TrainingStatusType(struct soap *soap, const enum ns2__TrainingStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__TrainingStatusType);
	if (soap_out_ns2__TrainingStatusType(soap, tag?tag:"ns2:TrainingStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__TrainingStatusType * SOAP_FMAC4 soap_get_ns2__TrainingStatusType(struct soap *soap, enum ns2__TrainingStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TrainingStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CBRNDressStatusType(struct soap *soap, enum ns2__CBRNDressStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CBRNDressStatusType
	*a = SOAP_DEFAULT_ns2__CBRNDressStatusType;
#else
	*a = (enum ns2__CBRNDressStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CBRNDressStatusType[] =
{	{ (long)ns2__CBRNDressStatusType__MOPP_x0020Ready, "MOPP Ready" },
	{ (long)ns2__CBRNDressStatusType__MOPP_x00200, "MOPP 0" },
	{ (long)ns2__CBRNDressStatusType__MOPP_x00201, "MOPP 1" },
	{ (long)ns2__CBRNDressStatusType__MOPP_x00202, "MOPP 2" },
	{ (long)ns2__CBRNDressStatusType__MOPP_x00203, "MOPP 3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CBRNDressStatusType2s(struct soap *soap, enum ns2__CBRNDressStatusType n)
{	const char *s = soap_code_str(soap_codes_ns2__CBRNDressStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CBRNDressStatusType(struct soap *soap, const char *tag, int id, const enum ns2__CBRNDressStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CBRNDressStatusType), type) || soap_send(soap, soap_ns2__CBRNDressStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CBRNDressStatusType(struct soap *soap, const char *s, enum ns2__CBRNDressStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CBRNDressStatusType, s);
	if (map)
		*a = (enum ns2__CBRNDressStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CBRNDressStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CBRNDressStatusType * SOAP_FMAC4 soap_in_ns2__CBRNDressStatusType(struct soap *soap, const char *tag, enum ns2__CBRNDressStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CBRNDressStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CBRNDressStatusType, sizeof(enum ns2__CBRNDressStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__CBRNDressStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CBRNDressStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CBRNDressStatusType, 0, sizeof(enum ns2__CBRNDressStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CBRNDressStatusType(struct soap *soap, const enum ns2__CBRNDressStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CBRNDressStatusType);
	if (soap_out_ns2__CBRNDressStatusType(soap, tag?tag:"ns2:CBRNDressStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CBRNDressStatusType * SOAP_FMAC4 soap_get_ns2__CBRNDressStatusType(struct soap *soap, enum ns2__CBRNDressStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CBRNDressStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ReadinessType(struct soap *soap, enum ns2__ReadinessType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ReadinessType
	*a = SOAP_DEFAULT_ns2__ReadinessType;
#else
	*a = (enum ns2__ReadinessType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ReadinessType[] =
{	{ (long)ns2__ReadinessType__Battle_x0020stations, "Battle stations" },
	{ (long)ns2__ReadinessType__Red, "Red" },
	{ (long)ns2__ReadinessType__Runaway_x0020alert, "Runaway alert" },
	{ (long)ns2__ReadinessType__White, "White" },
	{ (long)ns2__ReadinessType__Yellow, "Yellow" },
	{ (long)ns2__ReadinessType__Not_x0020otherwise_x0020specified, "Not otherwise specified" },
	{ (long)ns2__ReadinessType__Airborn_x0020alert, "Airborn alert" },
	{ (long)ns2__ReadinessType__Ground_x0020alert, "Ground alert" },
	{ (long)ns2__ReadinessType__Not_x0020ready_x0020within_x002012_x0020hours, "Not ready within 12 hours" },
	{ (long)ns2__ReadinessType__Ready_x0020within_x002010_x0020minutes, "Ready within 10 minutes" },
	{ (long)ns2__ReadinessType__Ready_x0020within_x002012_x0020hours, "Ready within 12 hours" },
	{ (long)ns2__ReadinessType__Ready_x0020within_x002015_x0020minutes, "Ready within 15 minutes" },
	{ (long)ns2__ReadinessType__Ready_x0020within_x00202_x0020hours, "Ready within 2 hours" },
	{ (long)ns2__ReadinessType__Ready_x0020within_x002020_x0020minutes_x0020_x0028US_x0029, "Ready within 20 minutes (US)" },
	{ (long)ns2__ReadinessType__Ready_x0020within_x00203_x0020hours, "Ready within 3 hours" },
	{ (long)ns2__ReadinessType__Ready_x0020within_x002030_x0020minutes, "Ready within 30 minutes" },
	{ (long)ns2__ReadinessType__Ready_x0020within_x00205_x0020minutes, "Ready within 5 minutes" },
	{ (long)ns2__ReadinessType__Ready_x0020within_x00206_x0020hours, "Ready within 6 hours" },
	{ (long)ns2__ReadinessType__Ready_x0020within_x002060_x0020minutes, "Ready within 60 minutes" },
	{ (long)ns2__ReadinessType__Ready_x0020within_x0020less_x0020than_x00205_x0020minutes, "Ready within less than 5 minutes" },
	{ (long)ns2__ReadinessType__Within_x002010_x0020days, "Within 10 days" },
	{ (long)ns2__ReadinessType__Within_x0020180_x0020days, "Within 180 days" },
	{ (long)ns2__ReadinessType__Within_x00202_x0020days, "Within 2 days" },
	{ (long)ns2__ReadinessType__Within_x002020_x0020days, "Within 20 days" },
	{ (long)ns2__ReadinessType__Within_x002030_x0020days, "Within 30 days" },
	{ (long)ns2__ReadinessType__Within_x0020365_x0020days, "Within 365 days" },
	{ (long)ns2__ReadinessType__Within_x00205_x0020days, "Within 5 days" },
	{ (long)ns2__ReadinessType__Within_x002060_x0020days, "Within 60 days" },
	{ (long)ns2__ReadinessType__Within_x002090_x0020days, "Within 90 days" },
	{ (long)ns2__ReadinessType__Not_x0020known, "Not known" },
	{ (long)ns2__ReadinessType__Readiness_x0020state_x00201, "Readiness state 1" },
	{ (long)ns2__ReadinessType__Readiness_x0020state_x00202, "Readiness state 2" },
	{ (long)ns2__ReadinessType__Readiness_x0020state_x00203, "Readiness state 3" },
	{ (long)ns2__ReadinessType__Readiness_x0020state_x00204, "Readiness state 4" },
	{ (long)ns2__ReadinessType__Readiness_x0020state_x00205, "Readiness state 5" },
	{ (long)ns2__ReadinessType__Readiness_x0020state_x00206, "Readiness state 6" },
	{ (long)ns2__ReadinessType__Readiness_x0020state_x00207, "Readiness state 7" },
	{ (long)ns2__ReadinessType__Readiness_x0020state_x00208, "Readiness state 8" },
	{ (long)ns2__ReadinessType__Readiness_x0020state_x00209, "Readiness state 9" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ReadinessType2s(struct soap *soap, enum ns2__ReadinessType n)
{	const char *s = soap_code_str(soap_codes_ns2__ReadinessType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReadinessType(struct soap *soap, const char *tag, int id, const enum ns2__ReadinessType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReadinessType), type) || soap_send(soap, soap_ns2__ReadinessType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ReadinessType(struct soap *soap, const char *s, enum ns2__ReadinessType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ReadinessType, s);
	if (map)
		*a = (enum ns2__ReadinessType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 38)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ReadinessType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ReadinessType * SOAP_FMAC4 soap_in_ns2__ReadinessType(struct soap *soap, const char *tag, enum ns2__ReadinessType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ReadinessType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReadinessType, sizeof(enum ns2__ReadinessType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ReadinessType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ReadinessType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReadinessType, 0, sizeof(enum ns2__ReadinessType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ReadinessType(struct soap *soap, const enum ns2__ReadinessType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ReadinessType);
	if (soap_out_ns2__ReadinessType(soap, tag?tag:"ns2:ReadinessType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ReadinessType * SOAP_FMAC4 soap_get_ns2__ReadinessType(struct soap *soap, enum ns2__ReadinessType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReadinessType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CommitmentStatusType(struct soap *soap, enum ns2__CommitmentStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CommitmentStatusType
	*a = SOAP_DEFAULT_ns2__CommitmentStatusType;
#else
	*a = (enum ns2__CommitmentStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CommitmentStatusType[] =
{	{ (long)ns2__CommitmentStatusType__Committed, "Committed" },
	{ (long)ns2__CommitmentStatusType__Uncommitted, "Uncommitted" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CommitmentStatusType2s(struct soap *soap, enum ns2__CommitmentStatusType n)
{	const char *s = soap_code_str(soap_codes_ns2__CommitmentStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CommitmentStatusType(struct soap *soap, const char *tag, int id, const enum ns2__CommitmentStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CommitmentStatusType), type) || soap_send(soap, soap_ns2__CommitmentStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CommitmentStatusType(struct soap *soap, const char *s, enum ns2__CommitmentStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CommitmentStatusType, s);
	if (map)
		*a = (enum ns2__CommitmentStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CommitmentStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CommitmentStatusType * SOAP_FMAC4 soap_in_ns2__CommitmentStatusType(struct soap *soap, const char *tag, enum ns2__CommitmentStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CommitmentStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CommitmentStatusType, sizeof(enum ns2__CommitmentStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__CommitmentStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CommitmentStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CommitmentStatusType, 0, sizeof(enum ns2__CommitmentStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CommitmentStatusType(struct soap *soap, const enum ns2__CommitmentStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CommitmentStatusType);
	if (soap_out_ns2__CommitmentStatusType(soap, tag?tag:"ns2:CommitmentStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CommitmentStatusType * SOAP_FMAC4 soap_get_ns2__CommitmentStatusType(struct soap *soap, enum ns2__CommitmentStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CommitmentStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AvailabilityType(struct soap *soap, enum ns2__AvailabilityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__AvailabilityType
	*a = SOAP_DEFAULT_ns2__AvailabilityType;
#else
	*a = (enum ns2__AvailabilityType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__AvailabilityType[] =
{	{ (long)ns2__AvailabilityType__After_x002030_x0020days, "After 30 days" },
	{ (long)ns2__AvailabilityType__Between_x002048_x0020hours_x0020and_x00204_x0020days, "Between 48 hours and 4 days" },
	{ (long)ns2__AvailabilityType__Between_x00205_x0020and_x002015_x0020days, "Between 5 and 15 days" },
	{ (long)ns2__AvailabilityType__Between_x002016_x0020and_x002030_x0020days, "Between 16 and 30 days" },
	{ (long)ns2__AvailabilityType__Within_x002048_x0020hours, "Within 48 hours" },
	{ (long)ns2__AvailabilityType__Not_x0020available, "Not available" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__AvailabilityType2s(struct soap *soap, enum ns2__AvailabilityType n)
{	const char *s = soap_code_str(soap_codes_ns2__AvailabilityType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AvailabilityType(struct soap *soap, const char *tag, int id, const enum ns2__AvailabilityType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AvailabilityType), type) || soap_send(soap, soap_ns2__AvailabilityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__AvailabilityType(struct soap *soap, const char *s, enum ns2__AvailabilityType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__AvailabilityType, s);
	if (map)
		*a = (enum ns2__AvailabilityType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__AvailabilityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__AvailabilityType * SOAP_FMAC4 soap_in_ns2__AvailabilityType(struct soap *soap, const char *tag, enum ns2__AvailabilityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__AvailabilityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AvailabilityType, sizeof(enum ns2__AvailabilityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__AvailabilityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__AvailabilityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AvailabilityType, 0, sizeof(enum ns2__AvailabilityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AvailabilityType(struct soap *soap, const enum ns2__AvailabilityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AvailabilityType);
	if (soap_out_ns2__AvailabilityType(soap, tag?tag:"ns2:AvailabilityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__AvailabilityType * SOAP_FMAC4 soap_get_ns2__AvailabilityType(struct soap *soap, enum ns2__AvailabilityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AvailabilityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__GroupPeopleType(struct soap *soap, enum ns2__GroupPeopleType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__GroupPeopleType
	*a = SOAP_DEFAULT_ns2__GroupPeopleType;
#else
	*a = (enum ns2__GroupPeopleType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__GroupPeopleType[] =
{	{ (long)ns2__GroupPeopleType__Displaced_x0020person, "Displaced person" },
	{ (long)ns2__GroupPeopleType__Gang, "Gang" },
	{ (long)ns2__GroupPeopleType__Intellectual, "Intellectual" },
	{ (long)ns2__GroupPeopleType__Journalist, "Journalist" },
	{ (long)ns2__GroupPeopleType__Landowner, "Landowner" },
	{ (long)ns2__GroupPeopleType__Police_x0020chief, "Police chief" },
	{ (long)ns2__GroupPeopleType__Merchant, "Merchant" },
	{ (long)ns2__GroupPeopleType__Prisoner_x0020of_x0020war, "Prisoner of war" },
	{ (long)ns2__GroupPeopleType__Media_x002c_x0020not_x0020otherwise_x0020specified, "Media, not otherwise specified" },
	{ (long)ns2__GroupPeopleType__Criminal, "Criminal" },
	{ (long)ns2__GroupPeopleType__Local_x0020inhabitant, "Local inhabitant" },
	{ (long)ns2__GroupPeopleType__Prisoner, "Prisoner" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__GroupPeopleType2s(struct soap *soap, enum ns2__GroupPeopleType n)
{	const char *s = soap_code_str(soap_codes_ns2__GroupPeopleType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__GroupPeopleType(struct soap *soap, const char *tag, int id, const enum ns2__GroupPeopleType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__GroupPeopleType), type) || soap_send(soap, soap_ns2__GroupPeopleType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__GroupPeopleType(struct soap *soap, const char *s, enum ns2__GroupPeopleType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__GroupPeopleType, s);
	if (map)
		*a = (enum ns2__GroupPeopleType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 11)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__GroupPeopleType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__GroupPeopleType * SOAP_FMAC4 soap_in_ns2__GroupPeopleType(struct soap *soap, const char *tag, enum ns2__GroupPeopleType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__GroupPeopleType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__GroupPeopleType, sizeof(enum ns2__GroupPeopleType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__GroupPeopleType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__GroupPeopleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__GroupPeopleType, 0, sizeof(enum ns2__GroupPeopleType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__GroupPeopleType(struct soap *soap, const enum ns2__GroupPeopleType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__GroupPeopleType);
	if (soap_out_ns2__GroupPeopleType(soap, tag?tag:"ns2:GroupPeopleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__GroupPeopleType * SOAP_FMAC4 soap_get_ns2__GroupPeopleType(struct soap *soap, enum ns2__GroupPeopleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__GroupPeopleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CommandAndControlType(struct soap *soap, enum ns2__CommandAndControlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CommandAndControlType
	*a = SOAP_DEFAULT_ns2__CommandAndControlType;
#else
	*a = (enum ns2__CommandAndControlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CommandAndControlType[] =
{	{ (long)ns2__CommandAndControlType__Command_x0020post, "Command post" },
	{ (long)ns2__CommandAndControlType__Coordination_x0020center, "Coordination center" },
	{ (long)ns2__CommandAndControlType__Headquarters, "Headquarters" },
	{ (long)ns2__CommandAndControlType__Operations_x0020center, "Operations center" },
	{ (long)ns2__CommandAndControlType__Not_x0020known, "Not known" },
	{ (long)ns2__CommandAndControlType__Not_x0020otherwise_x0020specified, "Not otherwise specified" },
	{ (long)ns2__CommandAndControlType__Air_x0020control_x0020center, "Air control center" },
	{ (long)ns2__CommandAndControlType__Air_x0020operations_x0020center, "Air operations center" },
	{ (long)ns2__CommandAndControlType__Air_x0020operations_x0020coordination_x0020center, "Air operations coordination center" },
	{ (long)ns2__CommandAndControlType__Air_x0020support_x0020operations_x0020center, "Air support operations center" },
	{ (long)ns2__CommandAndControlType__Airborne_x0020warning_x0020and_x0020control_x0020system, "Airborne warning and control system" },
	{ (long)ns2__CommandAndControlType__Combined_x0020air_x0020operations_x0020center, "Combined air operations center" },
	{ (long)ns2__CommandAndControlType__Control_x0020and_x0020reporting_x0020center, "Control and reporting center" },
	{ (long)ns2__CommandAndControlType__Control_x0020and_x0020reporting_x0020post, "Control and reporting post" },
	{ (long)ns2__CommandAndControlType__Direct_x0020air_x0020support_x0020center, "Direct air support center" },
	{ (long)ns2__CommandAndControlType__Direct_x0020air_x0020support_x0020center_x002c_x0020airborne, "Direct air support center, airborne" },
	{ (long)ns2__CommandAndControlType__Forward_x0020air_x0020control_x0020party, "Forward air control party" },
	{ (long)ns2__CommandAndControlType__Ground_x0020based_x0020air_x0020defence_x0020operations_x0020center, "Ground based air defence operations center" },
	{ (long)ns2__CommandAndControlType__Marine_x0020tactical_x0020air_x0020command_x0020center, "Marine tactical air command center" },
	{ (long)ns2__CommandAndControlType__Marine_x0020tactical_x0020air_x0020direction_x0020center, "Marine tactical air direction center" },
	{ (long)ns2__CommandAndControlType__Marine_x0020tactical_x0020air_x0020operations_x0020center, "Marine tactical air operations center" },
	{ (long)ns2__CommandAndControlType__Recognised_x0020air_x0020picture_x0020production_x0020center, "Recognised air picture production center" },
	{ (long)ns2__CommandAndControlType__Squadron_x0020operations_x0020center, "Squadron operations center" },
	{ (long)ns2__CommandAndControlType__Surface_to_air_x0020missile_operations_x0020center, "Surface-to-air missile-operations center" },
	{ (long)ns2__CommandAndControlType__Tactical_x0020air_x0020control_x0020party, "Tactical air control party" },
	{ (long)ns2__CommandAndControlType__Wing_x0020operations_x0020center, "Wing operations center" },
	{ (long)ns2__CommandAndControlType__Tactical_x0020operations_x0020center, "Tactical operations center" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CommandAndControlType2s(struct soap *soap, enum ns2__CommandAndControlType n)
{	const char *s = soap_code_str(soap_codes_ns2__CommandAndControlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CommandAndControlType(struct soap *soap, const char *tag, int id, const enum ns2__CommandAndControlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CommandAndControlType), type) || soap_send(soap, soap_ns2__CommandAndControlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CommandAndControlType(struct soap *soap, const char *s, enum ns2__CommandAndControlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CommandAndControlType, s);
	if (map)
		*a = (enum ns2__CommandAndControlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 26)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CommandAndControlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CommandAndControlType * SOAP_FMAC4 soap_in_ns2__CommandAndControlType(struct soap *soap, const char *tag, enum ns2__CommandAndControlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CommandAndControlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CommandAndControlType, sizeof(enum ns2__CommandAndControlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__CommandAndControlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CommandAndControlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CommandAndControlType, 0, sizeof(enum ns2__CommandAndControlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CommandAndControlType(struct soap *soap, const enum ns2__CommandAndControlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CommandAndControlType);
	if (soap_out_ns2__CommandAndControlType(soap, tag?tag:"ns2:CommandAndControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CommandAndControlType * SOAP_FMAC4 soap_get_ns2__CommandAndControlType(struct soap *soap, enum ns2__CommandAndControlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CommandAndControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SecurityStatusType(struct soap *soap, enum ns2__SecurityStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__SecurityStatusType
	*a = SOAP_DEFAULT_ns2__SecurityStatusType;
#else
	*a = (enum ns2__SecurityStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__SecurityStatusType[] =
{	{ (long)ns2__SecurityStatusType__Guarded, "Guarded" },
	{ (long)ns2__SecurityStatusType__None, "None" },
	{ (long)ns2__SecurityStatusType__Secured, "Secured" },
	{ (long)ns2__SecurityStatusType__Not_x0020known, "Not known" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__SecurityStatusType2s(struct soap *soap, enum ns2__SecurityStatusType n)
{	const char *s = soap_code_str(soap_codes_ns2__SecurityStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SecurityStatusType(struct soap *soap, const char *tag, int id, const enum ns2__SecurityStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SecurityStatusType), type) || soap_send(soap, soap_ns2__SecurityStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__SecurityStatusType(struct soap *soap, const char *s, enum ns2__SecurityStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__SecurityStatusType, s);
	if (map)
		*a = (enum ns2__SecurityStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__SecurityStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__SecurityStatusType * SOAP_FMAC4 soap_in_ns2__SecurityStatusType(struct soap *soap, const char *tag, enum ns2__SecurityStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__SecurityStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SecurityStatusType, sizeof(enum ns2__SecurityStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__SecurityStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__SecurityStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SecurityStatusType, 0, sizeof(enum ns2__SecurityStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SecurityStatusType(struct soap *soap, const enum ns2__SecurityStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SecurityStatusType);
	if (soap_out_ns2__SecurityStatusType(soap, tag?tag:"ns2:SecurityStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__SecurityStatusType * SOAP_FMAC4 soap_get_ns2__SecurityStatusType(struct soap *soap, enum ns2__SecurityStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SecurityStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__EnemyActivityPresentType(struct soap *soap, enum ns2__EnemyActivityPresentType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__EnemyActivityPresentType
	*a = SOAP_DEFAULT_ns2__EnemyActivityPresentType;
#else
	*a = (enum ns2__EnemyActivityPresentType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__EnemyActivityPresentType[] =
{	{ (long)ns2__EnemyActivityPresentType__Hot, "Hot" },
	{ (long)ns2__EnemyActivityPresentType__Cold, "Cold" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__EnemyActivityPresentType2s(struct soap *soap, enum ns2__EnemyActivityPresentType n)
{	const char *s = soap_code_str(soap_codes_ns2__EnemyActivityPresentType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EnemyActivityPresentType(struct soap *soap, const char *tag, int id, const enum ns2__EnemyActivityPresentType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EnemyActivityPresentType), type) || soap_send(soap, soap_ns2__EnemyActivityPresentType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__EnemyActivityPresentType(struct soap *soap, const char *s, enum ns2__EnemyActivityPresentType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__EnemyActivityPresentType, s);
	if (map)
		*a = (enum ns2__EnemyActivityPresentType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__EnemyActivityPresentType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__EnemyActivityPresentType * SOAP_FMAC4 soap_in_ns2__EnemyActivityPresentType(struct soap *soap, const char *tag, enum ns2__EnemyActivityPresentType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__EnemyActivityPresentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EnemyActivityPresentType, sizeof(enum ns2__EnemyActivityPresentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__EnemyActivityPresentType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__EnemyActivityPresentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EnemyActivityPresentType, 0, sizeof(enum ns2__EnemyActivityPresentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__EnemyActivityPresentType(struct soap *soap, const enum ns2__EnemyActivityPresentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__EnemyActivityPresentType);
	if (soap_out_ns2__EnemyActivityPresentType(soap, tag?tag:"ns2:EnemyActivityPresentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__EnemyActivityPresentType * SOAP_FMAC4 soap_get_ns2__EnemyActivityPresentType(struct soap *soap, enum ns2__EnemyActivityPresentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EnemyActivityPresentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConstructionType(struct soap *soap, enum ns2__ConstructionType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ConstructionType
	*a = SOAP_DEFAULT_ns2__ConstructionType;
#else
	*a = (enum ns2__ConstructionType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ConstructionType[] =
{	{ (long)ns2__ConstructionType__Asphalt, "Asphalt" },
	{ (long)ns2__ConstructionType__Bitumen, "Bitumen" },
	{ (long)ns2__ConstructionType__Brick_x002fMasonry, "Brick/Masonry" },
	{ (long)ns2__ConstructionType__Clay, "Clay" },
	{ (long)ns2__ConstructionType__Cobblestone, "Cobblestone" },
	{ (long)ns2__ConstructionType__Composite_x002c_x0020permanent, "Composite, permanent" },
	{ (long)ns2__ConstructionType__Composite_x002c_x0020soft, "Composite, soft" },
	{ (long)ns2__ConstructionType__Concrete, "Concrete" },
	{ (long)ns2__ConstructionType__Concrete_x0020Block, "Concrete Block" },
	{ (long)ns2__ConstructionType__Coral, "Coral" },
	{ (long)ns2__ConstructionType__Earth, "Earth" },
	{ (long)ns2__ConstructionType__Gravel, "Gravel" },
	{ (long)ns2__ConstructionType__Ice, "Ice" },
	{ (long)ns2__ConstructionType__Laterite, "Laterite" },
	{ (long)ns2__ConstructionType__Macadam, "Macadam" },
	{ (long)ns2__ConstructionType__Membrane, "Membrane" },
	{ (long)ns2__ConstructionType__Metal, "Metal" },
	{ (long)ns2__ConstructionType__Mix, "Mix" },
	{ (long)ns2__ConstructionType__Pebble, "Pebble" },
	{ (long)ns2__ConstructionType__Permanent_x0020surface, "Permanent surface" },
	{ (long)ns2__ConstructionType__Permanent_x0020surface_x0020mix, "Permanent surface mix" },
	{ (long)ns2__ConstructionType__Pierced_x0020steel, "Pierced steel" },
	{ (long)ns2__ConstructionType__Pre_stressed_x0020concrete, "Pre-stressed concrete" },
	{ (long)ns2__ConstructionType__Rock, "Rock" },
	{ (long)ns2__ConstructionType__Rolled_x0020earth, "Rolled earth" },
	{ (long)ns2__ConstructionType__Sand, "Sand" },
	{ (long)ns2__ConstructionType__Silt, "Silt" },
	{ (long)ns2__ConstructionType__Snow, "Snow" },
	{ (long)ns2__ConstructionType__Steel_x0020mat, "Steel mat" },
	{ (long)ns2__ConstructionType__Wood_x002ftimber, "Wood/timber" },
	{ (long)ns2__ConstructionType__Not_x0020known, "Not known" },
	{ (long)ns2__ConstructionType__Not_x0020otherwise_x0020specified, "Not otherwise specified" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ConstructionType2s(struct soap *soap, enum ns2__ConstructionType n)
{	const char *s = soap_code_str(soap_codes_ns2__ConstructionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConstructionType(struct soap *soap, const char *tag, int id, const enum ns2__ConstructionType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConstructionType), type) || soap_send(soap, soap_ns2__ConstructionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ConstructionType(struct soap *soap, const char *s, enum ns2__ConstructionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ConstructionType, s);
	if (map)
		*a = (enum ns2__ConstructionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 31)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ConstructionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ConstructionType * SOAP_FMAC4 soap_in_ns2__ConstructionType(struct soap *soap, const char *tag, enum ns2__ConstructionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ConstructionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConstructionType, sizeof(enum ns2__ConstructionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ConstructionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ConstructionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConstructionType, 0, sizeof(enum ns2__ConstructionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConstructionType(struct soap *soap, const enum ns2__ConstructionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConstructionType);
	if (soap_out_ns2__ConstructionType(soap, tag?tag:"ns2:ConstructionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ConstructionType * SOAP_FMAC4 soap_get_ns2__ConstructionType(struct soap *soap, enum ns2__ConstructionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConstructionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__OccupationStatusType(struct soap *soap, enum ns2__OccupationStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__OccupationStatusType
	*a = SOAP_DEFAULT_ns2__OccupationStatusType;
#else
	*a = (enum ns2__OccupationStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__OccupationStatusType[] =
{	{ (long)ns2__OccupationStatusType__Breached, "Breached" },
	{ (long)ns2__OccupationStatusType__Burned_x0020out, "Burned out" },
	{ (long)ns2__OccupationStatusType__Covered_x0020by_x0020fire, "Covered by fire" },
	{ (long)ns2__OccupationStatusType__Denied, "Denied" },
	{ (long)ns2__OccupationStatusType__Destroyed, "Destroyed" },
	{ (long)ns2__OccupationStatusType__Disassembled, "Disassembled" },
	{ (long)ns2__OccupationStatusType__Heavily_x0020Damaged, "Heavily Damaged" },
	{ (long)ns2__OccupationStatusType__In_x0020maintenance, "In maintenance" },
	{ (long)ns2__OccupationStatusType__Lacking_x0020vital_x0020resources, "Lacking vital resources" },
	{ (long)ns2__OccupationStatusType__Lightly_x0020damaged, "Lightly damaged" },
	{ (long)ns2__OccupationStatusType__Lost_x002fCaptured, "Lost/Captured" },
	{ (long)ns2__OccupationStatusType__Marked, "Marked" },
	{ (long)ns2__OccupationStatusType__Moderately_x0020damaged, "Moderately damaged" },
	{ (long)ns2__OccupationStatusType__Partly_x0020Dismantled, "Partly Dismantled" },
	{ (long)ns2__OccupationStatusType__Passable, "Passable" },
	{ (long)ns2__OccupationStatusType__Under_x0020construction, "Under construction" },
	{ (long)ns2__OccupationStatusType__Not_x0020known, "Not known" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__OccupationStatusType2s(struct soap *soap, enum ns2__OccupationStatusType n)
{	const char *s = soap_code_str(soap_codes_ns2__OccupationStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OccupationStatusType(struct soap *soap, const char *tag, int id, const enum ns2__OccupationStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OccupationStatusType), type) || soap_send(soap, soap_ns2__OccupationStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__OccupationStatusType(struct soap *soap, const char *s, enum ns2__OccupationStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__OccupationStatusType, s);
	if (map)
		*a = (enum ns2__OccupationStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 16)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__OccupationStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__OccupationStatusType * SOAP_FMAC4 soap_in_ns2__OccupationStatusType(struct soap *soap, const char *tag, enum ns2__OccupationStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__OccupationStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OccupationStatusType, sizeof(enum ns2__OccupationStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__OccupationStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__OccupationStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OccupationStatusType, 0, sizeof(enum ns2__OccupationStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__OccupationStatusType(struct soap *soap, const enum ns2__OccupationStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__OccupationStatusType);
	if (soap_out_ns2__OccupationStatusType(soap, tag?tag:"ns2:OccupationStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__OccupationStatusType * SOAP_FMAC4 soap_get_ns2__OccupationStatusType(struct soap *soap, enum ns2__OccupationStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OccupationStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MinistryType(struct soap *soap, enum ns2__MinistryType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__MinistryType
	*a = SOAP_DEFAULT_ns2__MinistryType;
#else
	*a = (enum ns2__MinistryType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__MinistryType[] =
{	{ (long)ns2__MinistryType__Governor, "Governor" },
	{ (long)ns2__MinistryType__Foreign_x0020Affairs, "Foreign Affairs" },
	{ (long)ns2__MinistryType__Interior, "Interior" },
	{ (long)ns2__MinistryType__Finance, "Finance" },
	{ (long)ns2__MinistryType__Culture_x0020and_x0020Youth, "Culture and Youth" },
	{ (long)ns2__MinistryType__Commerce, "Commerce" },
	{ (long)ns2__MinistryType__Water_x0020and_x0020Energy, "Water and Energy" },
	{ (long)ns2__MinistryType__Transport, "Transport" },
	{ (long)ns2__MinistryType__Womens_x0020Affairs, "Womens Affairs" },
	{ (long)ns2__MinistryType__Hajj_x0020and_x0020Islamic_x0020Affairs, "Hajj and Islamic Affairs" },
	{ (long)ns2__MinistryType__Public_x0020Welfare, "Public Welfare" },
	{ (long)ns2__MinistryType__Public_x0020Health, "Public Health" },
	{ (long)ns2__MinistryType__Agriculture, "Agriculture" },
	{ (long)ns2__MinistryType__Mines, "Mines" },
	{ (long)ns2__MinistryType__Communication, "Communication" },
	{ (long)ns2__MinistryType__MRRD, "MRRD" },
	{ (long)ns2__MinistryType__Work_x002c_x0020Social_x0020Affairs_x002c_x0020Martyred, "Work, Social Affairs, Martyred" },
	{ (long)ns2__MinistryType__Borders_x0020and_x0020Tribal_x0020Affairs, "Borders and Tribal Affairs" },
	{ (long)ns2__MinistryType__Urban_x0020Development, "Urban Development" },
	{ (long)ns2__MinistryType__Anti_Narcotics, "Anti-Narcotics" },
	{ (long)ns2__MinistryType__Refugees, "Refugees" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__MinistryType2s(struct soap *soap, enum ns2__MinistryType n)
{	const char *s = soap_code_str(soap_codes_ns2__MinistryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MinistryType(struct soap *soap, const char *tag, int id, const enum ns2__MinistryType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MinistryType), type) || soap_send(soap, soap_ns2__MinistryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__MinistryType(struct soap *soap, const char *s, enum ns2__MinistryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__MinistryType, s);
	if (map)
		*a = (enum ns2__MinistryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 20)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__MinistryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__MinistryType * SOAP_FMAC4 soap_in_ns2__MinistryType(struct soap *soap, const char *tag, enum ns2__MinistryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__MinistryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MinistryType, sizeof(enum ns2__MinistryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__MinistryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__MinistryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MinistryType, 0, sizeof(enum ns2__MinistryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MinistryType(struct soap *soap, const enum ns2__MinistryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MinistryType);
	if (soap_out_ns2__MinistryType(soap, tag?tag:"ns2:MinistryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__MinistryType * SOAP_FMAC4 soap_get_ns2__MinistryType(struct soap *soap, enum ns2__MinistryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MinistryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__LineOfOperationType(struct soap *soap, enum ns2__LineOfOperationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__LineOfOperationType
	*a = SOAP_DEFAULT_ns2__LineOfOperationType;
#else
	*a = (enum ns2__LineOfOperationType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__LineOfOperationType[] =
{	{ (long)ns2__LineOfOperationType__Governance, "Governance" },
	{ (long)ns2__LineOfOperationType__Development, "Development" },
	{ (long)ns2__LineOfOperationType__Security, "Security" },
	{ (long)ns2__LineOfOperationType__IO, "IO" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__LineOfOperationType2s(struct soap *soap, enum ns2__LineOfOperationType n)
{	const char *s = soap_code_str(soap_codes_ns2__LineOfOperationType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LineOfOperationType(struct soap *soap, const char *tag, int id, const enum ns2__LineOfOperationType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LineOfOperationType), type) || soap_send(soap, soap_ns2__LineOfOperationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__LineOfOperationType(struct soap *soap, const char *s, enum ns2__LineOfOperationType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__LineOfOperationType, s);
	if (map)
		*a = (enum ns2__LineOfOperationType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__LineOfOperationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__LineOfOperationType * SOAP_FMAC4 soap_in_ns2__LineOfOperationType(struct soap *soap, const char *tag, enum ns2__LineOfOperationType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__LineOfOperationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LineOfOperationType, sizeof(enum ns2__LineOfOperationType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__LineOfOperationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__LineOfOperationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LineOfOperationType, 0, sizeof(enum ns2__LineOfOperationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__LineOfOperationType(struct soap *soap, const enum ns2__LineOfOperationType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__LineOfOperationType);
	if (soap_out_ns2__LineOfOperationType(soap, tag?tag:"ns2:LineOfOperationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__LineOfOperationType * SOAP_FMAC4 soap_get_ns2__LineOfOperationType(struct soap *soap, enum ns2__LineOfOperationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LineOfOperationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MissionType(struct soap *soap, enum ns2__MissionType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__MissionType
	*a = SOAP_DEFAULT_ns2__MissionType;
#else
	*a = (enum ns2__MissionType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__MissionType[] =
{	{ (long)ns2__MissionType__Key_x0020Leader_x0020Engagements, "Key Leader Engagements" },
	{ (long)ns2__MissionType__Assessment, "Assessment" },
	{ (long)ns2__MissionType__Assessment_x005cDistrict, "Assessment\\District" },
	{ (long)ns2__MissionType__Assessment_x005cVillage, "Assessment\\Village" },
	{ (long)ns2__MissionType__Assessment_x005cInfrastructure_x0020_x0028QA_x002fQC_x0029, "Assessment\\Infrastructure (QA/QC)" },
	{ (long)ns2__MissionType__Ceremonial, "Ceremonial" },
	{ (long)ns2__MissionType__Meeting, "Meeting" },
	{ (long)ns2__MissionType__Meeting_x005cCoordination, "Meeting\\Coordination" },
	{ (long)ns2__MissionType__Meeting_x005cShura, "Meeting\\Shura" },
	{ (long)ns2__MissionType__Meeting_x005cInformation_x0020Only_x002fAttendee, "Meeting\\Information Only/Attendee" },
	{ (long)ns2__MissionType__HA, "HA" },
	{ (long)ns2__MissionType__HA_x002fMEDCAP_x002fVETCAP, "HA/MEDCAP/VETCAP" },
	{ (long)ns2__MissionType__MCIDNE_USCORECMO, "MCIDNE_CMO" },
	{ (long)ns2__MissionType__Other, "Other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__MissionType2s(struct soap *soap, enum ns2__MissionType n)
{	const char *s = soap_code_str(soap_codes_ns2__MissionType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MissionType(struct soap *soap, const char *tag, int id, const enum ns2__MissionType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MissionType), type) || soap_send(soap, soap_ns2__MissionType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__MissionType(struct soap *soap, const char *s, enum ns2__MissionType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__MissionType, s);
	if (map)
		*a = (enum ns2__MissionType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 13)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__MissionType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__MissionType * SOAP_FMAC4 soap_in_ns2__MissionType(struct soap *soap, const char *tag, enum ns2__MissionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__MissionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MissionType, sizeof(enum ns2__MissionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__MissionType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__MissionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MissionType, 0, sizeof(enum ns2__MissionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MissionType(struct soap *soap, const enum ns2__MissionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MissionType);
	if (soap_out_ns2__MissionType(soap, tag?tag:"ns2:MissionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__MissionType * SOAP_FMAC4 soap_get_ns2__MissionType(struct soap *soap, enum ns2__MissionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MissionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__KeywordType(struct soap *soap, enum ns2__KeywordType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__KeywordType
	*a = SOAP_DEFAULT_ns2__KeywordType;
#else
	*a = (enum ns2__KeywordType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__KeywordType[] =
{	{ (long)ns2__KeywordType__Key_x0020Leaders, "Key Leaders" },
	{ (long)ns2__KeywordType__Geography, "Geography" },
	{ (long)ns2__KeywordType__Geography_x005cPhysical_x0020Geography, "Geography\\Physical Geography" },
	{ (long)ns2__KeywordType__Geography_x005cHuman_x0020Geography, "Geography\\Human Geography" },
	{ (long)ns2__KeywordType__Geography_x005cHuman_x0020Geography_x005cSettlement_x0020Geography, "Geography\\Human Geography\\Settlement Geography" },
	{ (long)ns2__KeywordType__Geography_x005cHuman_x0020Geography_x005cMigration_x0020Patterns, "Geography\\Human Geography\\Migration Patterns" },
	{ (long)ns2__KeywordType__Green_x0020Significant_x0020Activities, "Green Significant Activities" },
	{ (long)ns2__KeywordType__Green_x0020Significant_x0020Activities_x005cBlue_x0020on_x0020Green, "Green Significant Activities\\Blue on Green" },
	{ (long)ns2__KeywordType__Green_x0020Significant_x0020Activities_x005cRed_x0020on_x0020Green, "Green Significant Activities\\Red on Green" },
	{ (long)ns2__KeywordType__Green_x0020Significant_x0020Activities_x005cGreen_x0020on_x0020Green, "Green Significant Activities\\Green on Green" },
	{ (long)ns2__KeywordType__Green_x0020Significant_x0020Activities_x005cGreen_x0020on_x0020Green_x005cConflict, "Green Significant Activities\\Green on Green\\Conflict" },
	{ (long)ns2__KeywordType__Green_x0020Significant_x0020Activities_x005cGreen_x0020on_x0020Green_x005cCrime, "Green Significant Activities\\Green on Green\\Crime" },
	{ (long)ns2__KeywordType__Green_x0020Significant_x0020Activities_x005cGreen_x0020on_x0020Green_x005cCrime_x005cEconomic, "Green Significant Activities\\Green on Green\\Crime\\Economic" },
	{ (long)ns2__KeywordType__Green_x0020Significant_x0020Activities_x005cGreen_x0020on_x0020Green_x005cCrime_x005cEconomic_x005cBlack_x0020Market, "Green Significant Activities\\Green on Green\\Crime\\Economic\\Black Market" },
	{ (long)ns2__KeywordType__Green_x0020Significant_x0020Activities_x005cGreen_x0020on_x0020Green_x005cCrime_x005cEconomic_x005cSmuggling, "Green Significant Activities\\Green on Green\\Crime\\Economic\\Smuggling" },
	{ (long)ns2__KeywordType__Green_x0020Significant_x0020Activities_x005cGreen_x0020on_x0020Green_x005cCrime_x005cEconomic_x005cCorruption, "Green Significant Activities\\Green on Green\\Crime\\Economic\\Corruption" },
	{ (long)ns2__KeywordType__Political_x0020System, "Political System" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties, "Political System\\Parties" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cInstitutions, "Political System\\Parties\\Institutions" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cInstitutions_x005cExecutive, "Political System\\Parties\\Institutions\\Executive" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cInstitutions_x005cExecutive_x005cMinistry_x002fDepartment, "Political System\\Parties\\Institutions\\Executive\\Ministry/Department" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cInstitutions_x005cDeliberative, "Political System\\Parties\\Institutions\\Deliberative" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cInstitutions_x005cDeliberative_x005cLawmaking, "Political System\\Parties\\Institutions\\Deliberative\\Lawmaking" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cInstitutions_x005cDeliberative_x005cAdjudicative, "Political System\\Parties\\Institutions\\Deliberative\\Adjudicative" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cNon_state_x0020Actors, "Political System\\Parties\\Non-state Actors" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cNon_state_x0020Actors_x005cNGOs, "Political System\\Parties\\Non-state Actors\\NGOs" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cNon_state_x0020Actors_x005cInterest_x0020Group, "Political System\\Parties\\Non-state Actors\\Interest Group" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cLegal_x0020System, "Political System\\Parties\\Legal System" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cLegal_x0020System_x005cLaws, "Political System\\Parties\\Legal System\\Laws" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cLegal_x0020System_x005cPolicies, "Political System\\Parties\\Legal System\\Policies" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cLegal_x0020System_x005cSanction, "Political System\\Parties\\Legal System\\Sanction" },
	{ (long)ns2__KeywordType__Political_x0020System_x005cParties_x005cLegal_x0020System_x005cConflict_x0020Resolution, "Political System\\Parties\\Legal System\\Conflict Resolution" },
	{ (long)ns2__KeywordType__Economics, "Economics" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators, "Economics\\Indicators" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cNatural_x0020Resources, "Economics\\Indicators\\Natural Resources" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cNatural_x0020Resources_x005cLand, "Economics\\Indicators\\Natural Resources\\Land" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cNatural_x0020Resources_x005cWater, "Economics\\Indicators\\Natural Resources\\Water" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cNatural_x0020Resources_x005cVegetation, "Economics\\Indicators\\Natural Resources\\Vegetation" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle, "Economics\\Indicators\\Economic Cycle" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cProduction, "Economics\\Indicators\\Economic Cycle\\Production" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cProduction_x005cSectors, "Economics\\Indicators\\Economic Cycle\\Production\\Sectors" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cProduction_x005cSectors_x005cAgriculture, "Economics\\Indicators\\Economic Cycle\\Production\\Sectors\\Agriculture" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cProduction_x005cSectors_x005cMining_x002fExtraction, "Economics\\Indicators\\Economic Cycle\\Production\\Sectors\\Mining/Extraction" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cProduction_x005cSectors_x005cManufacturing, "Economics\\Indicators\\Economic Cycle\\Production\\Sectors\\Manufacturing" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cProduction_x005cSectors_x005cServices, "Economics\\Indicators\\Economic Cycle\\Production\\Sectors\\Services" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cProduction_x005cSectors_x005cFinance_x002fExchange, "Economics\\Indicators\\Economic Cycle\\Production\\Sectors\\Finance/Exchange" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cProduction_x005cLabor, "Economics\\Indicators\\Economic Cycle\\Production\\Labor" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cProduction_x005cLabor_x005cWages, "Economics\\Indicators\\Economic Cycle\\Production\\Labor\\Wages" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cProduction_x005cLabor_x005cEmployment, "Economics\\Indicators\\Economic Cycle\\Production\\Labor\\Employment" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cProduction_x005cLabor_x005cGender_x0020Division, "Economics\\Indicators\\Economic Cycle\\Production\\Labor\\Gender Division" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cDistribution, "Economics\\Indicators\\Economic Cycle\\Distribution" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cDistribution_x005cPorts, "Economics\\Indicators\\Economic Cycle\\Distribution\\Ports" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cDistribution_x005cWarehousing, "Economics\\Indicators\\Economic Cycle\\Distribution\\Warehousing" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cDistribution_x005cMarketplaces_x002fRetail, "Economics\\Indicators\\Economic Cycle\\Distribution\\Marketplaces/Retail" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cDistribution_x005cRoads_x0020and_x0020Rails, "Economics\\Indicators\\Economic Cycle\\Distribution\\Roads and Rails" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cDistribution_x005cWaterways, "Economics\\Indicators\\Economic Cycle\\Distribution\\Waterways" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cConsumption, "Economics\\Indicators\\Economic Cycle\\Consumption" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cConsumption_x005cHousehold_x0020Economy, "Economics\\Indicators\\Economic Cycle\\Consumption\\Household Economy" },
	{ (long)ns2__KeywordType__Economics_x005cIndicators_x005cEconomic_x0020Cycle_x005cConsumption_x005cCommodities_x0020Pricing, "Economics\\Indicators\\Economic Cycle\\Consumption\\Commodities Pricing" },
	{ (long)ns2__KeywordType__Society, "Society" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure, "Society\\Social Structure" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cReligous_x0020Groups, "Society\\Social Structure\\Religous Groups" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cTribal_x0020System, "Society\\Social Structure\\Tribal System" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cDescent_x0020Group, "Society\\Social Structure\\Descent Group" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cFamily_x002fHousehold, "Society\\Social Structure\\Family/Household" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cEthnic_x0020Group, "Society\\Social Structure\\Ethnic Group" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cSocio_economic_x0020Class, "Society\\Social Structure\\Socio-economic Class" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cInformal_x0020Networks, "Society\\Social Structure\\Informal Networks" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cCaste, "Society\\Social Structure\\Caste" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cGender_x0020Group, "Society\\Social Structure\\Gender Group" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cTrade_x002fEconomic_x0020Group, "Society\\Social Structure\\Trade/Economic Group" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cMilitia_x002fArmed_x0020Group, "Society\\Social Structure\\Militia/Armed Group" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cRegional_x002fLocal_x0020Community, "Society\\Social Structure\\Regional/Local Community" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cAge_x0020Grade, "Society\\Social Structure\\Age Grade" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cNational_x0020Identity_x0020Group, "Society\\Social Structure\\National Identity Group" },
	{ (long)ns2__KeywordType__Society_x005cSocial_x0020Structure_x005cRefugees_x002fIDPs, "Society\\Social Structure\\Refugees/IDPs" },
	{ (long)ns2__KeywordType__Society_x005cCulture, "Society\\Culture" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cBelief_x0020Systems, "Society\\Culture\\Belief Systems" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cBelief_x0020Systems_x005cIdeology, "Society\\Culture\\Belief Systems\\Ideology" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cBelief_x0020Systems_x005cReligion, "Society\\Culture\\Belief Systems\\Religion" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cBelief_x0020Systems_x005cEthical_x0020Codes, "Society\\Culture\\Belief Systems\\Ethical Codes" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cBelief_x0020Systems_x005cValues, "Society\\Culture\\Belief Systems\\Values" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cBelief_x0020Systems_x005cIdentity_x0020_x0028Collective_x0020and_x0020Individual_x0029, "Society\\Culture\\Belief Systems\\Identity (Collective and Individual)" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cBelief_x0020Systems_x005cEducation_x0020_x0028Social_x0020Learning_x002fEnculturation_x0029, "Society\\Culture\\Belief Systems\\Education (Social Learning/Enculturation)" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cBelief_x0020Systems_x005cHealth_x002fWell_being_x0020_x0028Local_x0020Perception_x0020and_x0020Understanding_x0029, "Society\\Culture\\Belief Systems\\Health/Well-being (Local Perception and Understanding)" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cCultural_x0020Forms, "Society\\Culture\\Cultural Forms" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cCultural_x0020Forms_x005cSymbols, "Society\\Culture\\Cultural Forms\\Symbols" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cCultural_x0020Forms_x005cNarratives, "Society\\Culture\\Cultural Forms\\Narratives" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cCultural_x0020Forms_x005cThe_x0020Arts, "Society\\Culture\\Cultural Forms\\The Arts" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cCultural_x0020Forms_x005cTraditions, "Society\\Culture\\Cultural Forms\\Traditions" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cCultural_x0020Forms_x005cHolidays_x002fObservance, "Society\\Culture\\Cultural Forms\\Holidays/Observance" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cCultural_x0020Forms_x005cNorm, "Society\\Culture\\Cultural Forms\\Norm" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cCultural_x0020Forms_x005cStatus_x0020and_x0020Role, "Society\\Culture\\Cultural Forms\\Status and Role" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cCultural_x0020Forms_x005cApparel, "Society\\Culture\\Cultural Forms\\Apparel" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cCultural_x0020Forms_x005cHousing, "Society\\Culture\\Cultural Forms\\Housing" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cCultural_x0020Forms_x005cRecreation_x005cLeisure_x005cSports, "Society\\Culture\\Cultural Forms\\Recreation\\Leisure\\Sports" },
	{ (long)ns2__KeywordType__Society_x005cCulture_x005cCultural_x0020Forms_x005cRecreation_x005cLeisure_x005couth_x0020Activities, "Society\\Culture\\Cultural Forms\\Recreation\\Leisure\\outh Activities" },
	{ (long)ns2__KeywordType__Society_x005cCommunications, "Society\\Communications" },
	{ (long)ns2__KeywordType__Society_x005cCommunications_x005cLanguage, "Society\\Communications\\Language" },
	{ (long)ns2__KeywordType__Society_x005cCommunications_x005cNon_verbal, "Society\\Communications\\Non-verbal" },
	{ (long)ns2__KeywordType__Interests, "Interests" },
	{ (long)ns2__KeywordType__Interests_x005cPolitical, "Interests\\Political" },
	{ (long)ns2__KeywordType__Interests_x005cSocial, "Interests\\Social" },
	{ (long)ns2__KeywordType__Interests_x005cEconomic, "Interests\\Economic" },
	{ (long)ns2__KeywordType__Interests_x005cResource, "Interests\\Resource" },
	{ (long)ns2__KeywordType__Interests_x005cTerritorial, "Interests\\Territorial" },
	{ (long)ns2__KeywordType__Interests_x005cSecurity_x002fSafety, "Interests\\Security/Safety" },
	{ (long)ns2__KeywordType__Grievances, "Grievances" },
	{ (long)ns2__KeywordType__Grievances_x005cPolitical, "Grievances\\Political" },
	{ (long)ns2__KeywordType__Grievances_x005cSocial, "Grievances\\Social" },
	{ (long)ns2__KeywordType__Grievances_x005cEconomic, "Grievances\\Economic" },
	{ (long)ns2__KeywordType__Grievances_x005cResource, "Grievances\\Resource" },
	{ (long)ns2__KeywordType__Power, "Power" },
	{ (long)ns2__KeywordType__Power_x005cCoercion, "Power\\Coercion" },
	{ (long)ns2__KeywordType__Power_x005cEconomic, "Power\\Economic" },
	{ (long)ns2__KeywordType__Power_x005cSocial_x0020Capital_x0020_x0028Trust_x0029, "Power\\Social Capital (Trust)" },
	{ (long)ns2__KeywordType__Power_x005cAuthority_x0020_x0028Patronage_x0020Networks_x0029, "Power\\Authority (Patronage Networks)" },
	{ (long)ns2__KeywordType__Information_x0020Environment, "Information Environment" },
	{ (long)ns2__KeywordType__Information_x0020Environment_x005cSource, "Information Environment\\Source" },
	{ (long)ns2__KeywordType__Information_x0020Environment_x005cContent, "Information Environment\\Content" },
	{ (long)ns2__KeywordType__Information_x0020Environment_x005cMeans_x0020of_x0020Delivery, "Information Environment\\Means of Delivery" },
	{ (long)ns2__KeywordType__Capabilities, "Capabilities" },
	{ (long)ns2__KeywordType__Capabilities_x005cPublic_x0020Safety, "Capabilities\\Public Safety" },
	{ (long)ns2__KeywordType__Capabilities_x005cPublic_x0020Safety_x005cMilitary, "Capabilities\\Public Safety\\Military" },
	{ (long)ns2__KeywordType__Capabilities_x005cPublic_x0020Safety_x005cBorder, "Capabilities\\Public Safety\\Border" },
	{ (long)ns2__KeywordType__Capabilities_x005cPublic_x0020Safety_x005cPolice, "Capabilities\\Public Safety\\Police" },
	{ (long)ns2__KeywordType__Capabilities_x005cPublic_x0020Safety_x005cIntelligence_x0020Organizations, "Capabilities\\Public Safety\\Intelligence Organizations" },
	{ (long)ns2__KeywordType__Capabilities_x005cPublic_x0020Health, "Capabilities\\Public Health" },
	{ (long)ns2__KeywordType__Capabilities_x005cPublic_x0020Health_x005cClinics, "Capabilities\\Public Health\\Clinics" },
	{ (long)ns2__KeywordType__Capabilities_x005cPublic_x0020Health_x005cHospitals, "Capabilities\\Public Health\\Hospitals" },
	{ (long)ns2__KeywordType__Capabilities_x005cPublic_x0020Health_x005cVeterinary, "Capabilities\\Public Health\\Veterinary" },
	{ (long)ns2__KeywordType__Capabilities_x005cFood, "Capabilities\\Food" },
	{ (long)ns2__KeywordType__Capabilities_x005cWater, "Capabilities\\Water" },
	{ (long)ns2__KeywordType__Capabilities_x005cWater_x005cIrrigation, "Capabilities\\Water\\Irrigation" },
	{ (long)ns2__KeywordType__Capabilities_x005cWater_x005cWell_x002fAqueducts, "Capabilities\\Water\\Well/Aqueducts" },
	{ (long)ns2__KeywordType__Capabilities_x005cSanitation, "Capabilities\\Sanitation" },
	{ (long)ns2__KeywordType__Capabilities_x005cSanitation_x005cSewage, "Capabilities\\Sanitation\\Sewage" },
	{ (long)ns2__KeywordType__Capabilities_x005cSanitation_x005cTrash, "Capabilities\\Sanitation\\Trash" },
	{ (long)ns2__KeywordType__Capabilities_x005cTransportation, "Capabilities\\Transportation" },
	{ (long)ns2__KeywordType__Capabilities_x005cEnergy, "Capabilities\\Energy" },
	{ (long)ns2__KeywordType__Capabilities_x005cEnergy_x005cElectricity, "Capabilities\\Energy\\Electricity" },
	{ (long)ns2__KeywordType__Capabilities_x005cEducation, "Capabilities\\Education" },
	{ (long)ns2__KeywordType__Capabilities_x005cEducation_x005cLiteracy, "Capabilities\\Education\\Literacy" },
	{ (long)ns2__KeywordType__Capabilities_x005cEducation_x005cSchools, "Capabilities\\Education\\Schools" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__KeywordType2s(struct soap *soap, enum ns2__KeywordType n)
{	const char *s = soap_code_str(soap_codes_ns2__KeywordType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__KeywordType(struct soap *soap, const char *tag, int id, const enum ns2__KeywordType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__KeywordType), type) || soap_send(soap, soap_ns2__KeywordType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__KeywordType(struct soap *soap, const char *s, enum ns2__KeywordType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__KeywordType, s);
	if (map)
		*a = (enum ns2__KeywordType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 143)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__KeywordType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__KeywordType * SOAP_FMAC4 soap_in_ns2__KeywordType(struct soap *soap, const char *tag, enum ns2__KeywordType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__KeywordType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__KeywordType, sizeof(enum ns2__KeywordType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__KeywordType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__KeywordType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__KeywordType, 0, sizeof(enum ns2__KeywordType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__KeywordType(struct soap *soap, const enum ns2__KeywordType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__KeywordType);
	if (soap_out_ns2__KeywordType(soap, tag?tag:"ns2:KeywordType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__KeywordType * SOAP_FMAC4 soap_get_ns2__KeywordType(struct soap *soap, enum ns2__KeywordType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__KeywordType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AnalyticalToolMethodType(struct soap *soap, enum ns2__AnalyticalToolMethodType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__AnalyticalToolMethodType
	*a = SOAP_DEFAULT_ns2__AnalyticalToolMethodType;
#else
	*a = (enum ns2__AnalyticalToolMethodType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__AnalyticalToolMethodType[] =
{	{ (long)ns2__AnalyticalToolMethodType__Cultural_x0020Domain_x0020Analysis, "Cultural Domain Analysis" },
	{ (long)ns2__AnalyticalToolMethodType__Text_x0020Analysis, "Text Analysis" },
	{ (long)ns2__AnalyticalToolMethodType__Structural_x0020Analysis, "Structural Analysis" },
	{ (long)ns2__AnalyticalToolMethodType__Quantitative_x0020Analysis, "Quantitative Analysis" },
	{ (long)ns2__AnalyticalToolMethodType__Inference_x002fProbable_x0020Cause_x0020Analysis, "Inference/Probable Cause Analysis" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__AnalyticalToolMethodType2s(struct soap *soap, enum ns2__AnalyticalToolMethodType n)
{	const char *s = soap_code_str(soap_codes_ns2__AnalyticalToolMethodType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AnalyticalToolMethodType(struct soap *soap, const char *tag, int id, const enum ns2__AnalyticalToolMethodType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AnalyticalToolMethodType), type) || soap_send(soap, soap_ns2__AnalyticalToolMethodType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__AnalyticalToolMethodType(struct soap *soap, const char *s, enum ns2__AnalyticalToolMethodType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__AnalyticalToolMethodType, s);
	if (map)
		*a = (enum ns2__AnalyticalToolMethodType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__AnalyticalToolMethodType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__AnalyticalToolMethodType * SOAP_FMAC4 soap_in_ns2__AnalyticalToolMethodType(struct soap *soap, const char *tag, enum ns2__AnalyticalToolMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__AnalyticalToolMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AnalyticalToolMethodType, sizeof(enum ns2__AnalyticalToolMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__AnalyticalToolMethodType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__AnalyticalToolMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AnalyticalToolMethodType, 0, sizeof(enum ns2__AnalyticalToolMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AnalyticalToolMethodType(struct soap *soap, const enum ns2__AnalyticalToolMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AnalyticalToolMethodType);
	if (soap_out_ns2__AnalyticalToolMethodType(soap, tag?tag:"ns2:AnalyticalToolMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__AnalyticalToolMethodType * SOAP_FMAC4 soap_get_ns2__AnalyticalToolMethodType(struct soap *soap, enum ns2__AnalyticalToolMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AnalyticalToolMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DataCollectionMethodType(struct soap *soap, enum ns2__DataCollectionMethodType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DataCollectionMethodType
	*a = SOAP_DEFAULT_ns2__DataCollectionMethodType;
#else
	*a = (enum ns2__DataCollectionMethodType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__DataCollectionMethodType[] =
{	{ (long)ns2__DataCollectionMethodType__Secondary_x0020Source, "Secondary Source" },
	{ (long)ns2__DataCollectionMethodType__Direct_x0020Observation, "Direct Observation" },
	{ (long)ns2__DataCollectionMethodType__Visual_x0020Ethnography, "Visual Ethnography" },
	{ (long)ns2__DataCollectionMethodType__Key_x0020Leader_x0020Engagement, "Key Leader Engagement" },
	{ (long)ns2__DataCollectionMethodType__Participant_x0020Observation, "Participant Observation" },
	{ (long)ns2__DataCollectionMethodType__Depth_x0020Interviews, "Depth Interviews" },
	{ (long)ns2__DataCollectionMethodType__Group_x0020Interviews_x002fFocus_x0020Groups, "Group Interviews/Focus Groups" },
	{ (long)ns2__DataCollectionMethodType__Surveys, "Surveys" },
	{ (long)ns2__DataCollectionMethodType__Mixed_x0020Method_x0020Approaches, "Mixed Method Approaches" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__DataCollectionMethodType2s(struct soap *soap, enum ns2__DataCollectionMethodType n)
{	const char *s = soap_code_str(soap_codes_ns2__DataCollectionMethodType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DataCollectionMethodType(struct soap *soap, const char *tag, int id, const enum ns2__DataCollectionMethodType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DataCollectionMethodType), type) || soap_send(soap, soap_ns2__DataCollectionMethodType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DataCollectionMethodType(struct soap *soap, const char *s, enum ns2__DataCollectionMethodType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__DataCollectionMethodType, s);
	if (map)
		*a = (enum ns2__DataCollectionMethodType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__DataCollectionMethodType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__DataCollectionMethodType * SOAP_FMAC4 soap_in_ns2__DataCollectionMethodType(struct soap *soap, const char *tag, enum ns2__DataCollectionMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__DataCollectionMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DataCollectionMethodType, sizeof(enum ns2__DataCollectionMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__DataCollectionMethodType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__DataCollectionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DataCollectionMethodType, 0, sizeof(enum ns2__DataCollectionMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DataCollectionMethodType(struct soap *soap, const enum ns2__DataCollectionMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DataCollectionMethodType);
	if (soap_out_ns2__DataCollectionMethodType(soap, tag?tag:"ns2:DataCollectionMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DataCollectionMethodType * SOAP_FMAC4 soap_get_ns2__DataCollectionMethodType(struct soap *soap, enum ns2__DataCollectionMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DataCollectionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ProductType(struct soap *soap, enum ns2__ProductType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ProductType
	*a = SOAP_DEFAULT_ns2__ProductType;
#else
	*a = (enum ns2__ProductType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ProductType[] =
{	{ (long)ns2__ProductType__Effects_x0020Assessment, "Effects Assessment" },
	{ (long)ns2__ProductType__Research_x0020and_x0020Analysis_x0020Process_x0020Assessment, "Research and Analysis Process Assessment" },
	{ (long)ns2__ProductType__Research_x0020Plan, "Research Plan" },
	{ (long)ns2__ProductType__Research_x0020Project_x0020Design, "Research Project Design" },
	{ (long)ns2__ProductType__Raw_x0020Material, "Raw Material" },
	{ (long)ns2__ProductType__Intermediate_x0020Material, "Intermediate Material" },
	{ (long)ns2__ProductType__Finished_x0020Product, "Finished Product" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ProductType2s(struct soap *soap, enum ns2__ProductType n)
{	const char *s = soap_code_str(soap_codes_ns2__ProductType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ProductType(struct soap *soap, const char *tag, int id, const enum ns2__ProductType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ProductType), type) || soap_send(soap, soap_ns2__ProductType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ProductType(struct soap *soap, const char *s, enum ns2__ProductType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ProductType, s);
	if (map)
		*a = (enum ns2__ProductType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ProductType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ProductType * SOAP_FMAC4 soap_in_ns2__ProductType(struct soap *soap, const char *tag, enum ns2__ProductType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ProductType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ProductType, sizeof(enum ns2__ProductType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ProductType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ProductType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ProductType, 0, sizeof(enum ns2__ProductType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ProductType(struct soap *soap, const enum ns2__ProductType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ProductType);
	if (soap_out_ns2__ProductType(soap, tag?tag:"ns2:ProductType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ProductType * SOAP_FMAC4 soap_get_ns2__ProductType(struct soap *soap, enum ns2__ProductType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ProductType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__SomaliaProvinceType(struct soap *soap, enum ns2__SomaliaProvinceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__SomaliaProvinceType
	*a = SOAP_DEFAULT_ns2__SomaliaProvinceType;
#else
	*a = (enum ns2__SomaliaProvinceType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__SomaliaProvinceType[] =
{	{ (long)ns2__SomaliaProvinceType__Galmudug, "Galmudug" },
	{ (long)ns2__SomaliaProvinceType__Islamic_x0020Courts_x0020Union, "Islamic Courts Union" },
	{ (long)ns2__SomaliaProvinceType__Jubaland, "Jubaland" },
	{ (long)ns2__SomaliaProvinceType__Maakhir, "Maakhir" },
	{ (long)ns2__SomaliaProvinceType__Northland_x0020State, "Northland State" },
	{ (long)ns2__SomaliaProvinceType__Puntland, "Puntland" },
	{ (long)ns2__SomaliaProvinceType__Somalia, "Somalia" },
	{ (long)ns2__SomaliaProvinceType__Somaliland, "Somaliland" },
	{ (long)ns2__SomaliaProvinceType__Southwestern_x0020Somalia, "Southwestern Somalia" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__SomaliaProvinceType2s(struct soap *soap, enum ns2__SomaliaProvinceType n)
{	const char *s = soap_code_str(soap_codes_ns2__SomaliaProvinceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SomaliaProvinceType(struct soap *soap, const char *tag, int id, const enum ns2__SomaliaProvinceType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SomaliaProvinceType), type) || soap_send(soap, soap_ns2__SomaliaProvinceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__SomaliaProvinceType(struct soap *soap, const char *s, enum ns2__SomaliaProvinceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__SomaliaProvinceType, s);
	if (map)
		*a = (enum ns2__SomaliaProvinceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__SomaliaProvinceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__SomaliaProvinceType * SOAP_FMAC4 soap_in_ns2__SomaliaProvinceType(struct soap *soap, const char *tag, enum ns2__SomaliaProvinceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__SomaliaProvinceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SomaliaProvinceType, sizeof(enum ns2__SomaliaProvinceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__SomaliaProvinceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__SomaliaProvinceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SomaliaProvinceType, 0, sizeof(enum ns2__SomaliaProvinceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__SomaliaProvinceType(struct soap *soap, const enum ns2__SomaliaProvinceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__SomaliaProvinceType);
	if (soap_out_ns2__SomaliaProvinceType(soap, tag?tag:"ns2:SomaliaProvinceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__SomaliaProvinceType * SOAP_FMAC4 soap_get_ns2__SomaliaProvinceType(struct soap *soap, enum ns2__SomaliaProvinceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SomaliaProvinceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__EthiopiaProvinceType(struct soap *soap, enum ns2__EthiopiaProvinceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__EthiopiaProvinceType
	*a = SOAP_DEFAULT_ns2__EthiopiaProvinceType;
#else
	*a = (enum ns2__EthiopiaProvinceType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__EthiopiaProvinceType[] =
{	{ (long)ns2__EthiopiaProvinceType__Addis_x0020Ababa, "Addis Ababa" },
	{ (long)ns2__EthiopiaProvinceType__Afar, "Afar" },
	{ (long)ns2__EthiopiaProvinceType__Amhara, "Amhara" },
	{ (long)ns2__EthiopiaProvinceType__Benishangul_Gumuz, "Benishangul-Gumuz" },
	{ (long)ns2__EthiopiaProvinceType__Dire_x0020Dawa, "Dire Dawa" },
	{ (long)ns2__EthiopiaProvinceType__Gambela, "Gambela" },
	{ (long)ns2__EthiopiaProvinceType__Harari, "Harari" },
	{ (long)ns2__EthiopiaProvinceType__Oromia, "Oromia" },
	{ (long)ns2__EthiopiaProvinceType__Somali, "Somali" },
	{ (long)ns2__EthiopiaProvinceType__Tigray, "Tigray" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__EthiopiaProvinceType2s(struct soap *soap, enum ns2__EthiopiaProvinceType n)
{	const char *s = soap_code_str(soap_codes_ns2__EthiopiaProvinceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EthiopiaProvinceType(struct soap *soap, const char *tag, int id, const enum ns2__EthiopiaProvinceType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EthiopiaProvinceType), type) || soap_send(soap, soap_ns2__EthiopiaProvinceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__EthiopiaProvinceType(struct soap *soap, const char *s, enum ns2__EthiopiaProvinceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__EthiopiaProvinceType, s);
	if (map)
		*a = (enum ns2__EthiopiaProvinceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__EthiopiaProvinceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__EthiopiaProvinceType * SOAP_FMAC4 soap_in_ns2__EthiopiaProvinceType(struct soap *soap, const char *tag, enum ns2__EthiopiaProvinceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__EthiopiaProvinceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EthiopiaProvinceType, sizeof(enum ns2__EthiopiaProvinceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__EthiopiaProvinceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__EthiopiaProvinceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EthiopiaProvinceType, 0, sizeof(enum ns2__EthiopiaProvinceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__EthiopiaProvinceType(struct soap *soap, const enum ns2__EthiopiaProvinceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__EthiopiaProvinceType);
	if (soap_out_ns2__EthiopiaProvinceType(soap, tag?tag:"ns2:EthiopiaProvinceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__EthiopiaProvinceType * SOAP_FMAC4 soap_get_ns2__EthiopiaProvinceType(struct soap *soap, enum ns2__EthiopiaProvinceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EthiopiaProvinceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DijiboutiProvinceType(struct soap *soap, enum ns2__DijiboutiProvinceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DijiboutiProvinceType
	*a = SOAP_DEFAULT_ns2__DijiboutiProvinceType;
#else
	*a = (enum ns2__DijiboutiProvinceType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__DijiboutiProvinceType[] =
{	{ (long)ns2__DijiboutiProvinceType__Ali_x0020Sabieh_x0020Region, "Ali Sabieh Region" },
	{ (long)ns2__DijiboutiProvinceType__Arta_x0020Region, "Arta Region" },
	{ (long)ns2__DijiboutiProvinceType__Dikhil, "Dikhil" },
	{ (long)ns2__DijiboutiProvinceType__Djibouti, "Djibouti" },
	{ (long)ns2__DijiboutiProvinceType__Obock_x0020Region, "Obock Region" },
	{ (long)ns2__DijiboutiProvinceType__Tadjourah_x0020Region, "Tadjourah Region" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__DijiboutiProvinceType2s(struct soap *soap, enum ns2__DijiboutiProvinceType n)
{	const char *s = soap_code_str(soap_codes_ns2__DijiboutiProvinceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DijiboutiProvinceType(struct soap *soap, const char *tag, int id, const enum ns2__DijiboutiProvinceType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DijiboutiProvinceType), type) || soap_send(soap, soap_ns2__DijiboutiProvinceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DijiboutiProvinceType(struct soap *soap, const char *s, enum ns2__DijiboutiProvinceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__DijiboutiProvinceType, s);
	if (map)
		*a = (enum ns2__DijiboutiProvinceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__DijiboutiProvinceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__DijiboutiProvinceType * SOAP_FMAC4 soap_in_ns2__DijiboutiProvinceType(struct soap *soap, const char *tag, enum ns2__DijiboutiProvinceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__DijiboutiProvinceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DijiboutiProvinceType, sizeof(enum ns2__DijiboutiProvinceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__DijiboutiProvinceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__DijiboutiProvinceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DijiboutiProvinceType, 0, sizeof(enum ns2__DijiboutiProvinceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DijiboutiProvinceType(struct soap *soap, const enum ns2__DijiboutiProvinceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DijiboutiProvinceType);
	if (soap_out_ns2__DijiboutiProvinceType(soap, tag?tag:"ns2:DijiboutiProvinceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DijiboutiProvinceType * SOAP_FMAC4 soap_get_ns2__DijiboutiProvinceType(struct soap *soap, enum ns2__DijiboutiProvinceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DijiboutiProvinceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__EritreaProvinceType(struct soap *soap, enum ns2__EritreaProvinceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__EritreaProvinceType
	*a = SOAP_DEFAULT_ns2__EritreaProvinceType;
#else
	*a = (enum ns2__EritreaProvinceType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__EritreaProvinceType[] =
{	{ (long)ns2__EritreaProvinceType__Central, "Central" },
	{ (long)ns2__EritreaProvinceType__Southern, "Southern" },
	{ (long)ns2__EritreaProvinceType__Gash_Barka, "Gash-Barka" },
	{ (long)ns2__EritreaProvinceType__Anseba, "Anseba" },
	{ (long)ns2__EritreaProvinceType__Northern_x0020Red_x0020Sea, "Northern Red Sea" },
	{ (long)ns2__EritreaProvinceType__Southern_x0020Red_x0020Sea, "Southern Red Sea" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__EritreaProvinceType2s(struct soap *soap, enum ns2__EritreaProvinceType n)
{	const char *s = soap_code_str(soap_codes_ns2__EritreaProvinceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EritreaProvinceType(struct soap *soap, const char *tag, int id, const enum ns2__EritreaProvinceType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EritreaProvinceType), type) || soap_send(soap, soap_ns2__EritreaProvinceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__EritreaProvinceType(struct soap *soap, const char *s, enum ns2__EritreaProvinceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__EritreaProvinceType, s);
	if (map)
		*a = (enum ns2__EritreaProvinceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__EritreaProvinceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__EritreaProvinceType * SOAP_FMAC4 soap_in_ns2__EritreaProvinceType(struct soap *soap, const char *tag, enum ns2__EritreaProvinceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__EritreaProvinceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EritreaProvinceType, sizeof(enum ns2__EritreaProvinceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__EritreaProvinceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__EritreaProvinceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EritreaProvinceType, 0, sizeof(enum ns2__EritreaProvinceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__EritreaProvinceType(struct soap *soap, const enum ns2__EritreaProvinceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__EritreaProvinceType);
	if (soap_out_ns2__EritreaProvinceType(soap, tag?tag:"ns2:EritreaProvinceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__EritreaProvinceType * SOAP_FMAC4 soap_get_ns2__EritreaProvinceType(struct soap *soap, enum ns2__EritreaProvinceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EritreaProvinceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__IraqProvinceType(struct soap *soap, enum ns2__IraqProvinceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__IraqProvinceType
	*a = SOAP_DEFAULT_ns2__IraqProvinceType;
#else
	*a = (enum ns2__IraqProvinceType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__IraqProvinceType[] =
{	{ (long)ns2__IraqProvinceType__Baghdad, "Baghdad" },
	{ (long)ns2__IraqProvinceType__Salah_x0020ad_x0020Din, "Salah ad Din" },
	{ (long)ns2__IraqProvinceType__Diyala, "Diyala" },
	{ (long)ns2__IraqProvinceType__Wasit, "Wasit" },
	{ (long)ns2__IraqProvinceType__Maysan, "Maysan" },
	{ (long)ns2__IraqProvinceType__Al_x0020Basrah, "Al Basrah" },
	{ (long)ns2__IraqProvinceType__Dhi_x0020Qar, "Dhi Qar" },
	{ (long)ns2__IraqProvinceType__Al_x0020Muthanna, "Al Muthanna" },
	{ (long)ns2__IraqProvinceType__Al_Q_x00c4_x0081disiyyah, "Al-QÄdisiyyah" },
	{ (long)ns2__IraqProvinceType__Babil, "Babil" },
	{ (long)ns2__IraqProvinceType__Karbala, "Karbala" },
	{ (long)ns2__IraqProvinceType__An_x0020Najaf, "An Najaf" },
	{ (long)ns2__IraqProvinceType__Al_x0020Anbar, "Al Anbar" },
	{ (long)ns2__IraqProvinceType__Ninawa, "Ninawa" },
	{ (long)ns2__IraqProvinceType__Dahuk, "Dahuk" },
	{ (long)ns2__IraqProvinceType__Arbil, "Arbil" },
	{ (long)ns2__IraqProvinceType__Kirkuk, "Kirkuk" },
	{ (long)ns2__IraqProvinceType__Sulaymaniyah, "Sulaymaniyah" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__IraqProvinceType2s(struct soap *soap, enum ns2__IraqProvinceType n)
{	const char *s = soap_code_str(soap_codes_ns2__IraqProvinceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IraqProvinceType(struct soap *soap, const char *tag, int id, const enum ns2__IraqProvinceType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IraqProvinceType), type) || soap_send(soap, soap_ns2__IraqProvinceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__IraqProvinceType(struct soap *soap, const char *s, enum ns2__IraqProvinceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__IraqProvinceType, s);
	if (map)
		*a = (enum ns2__IraqProvinceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 17)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__IraqProvinceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__IraqProvinceType * SOAP_FMAC4 soap_in_ns2__IraqProvinceType(struct soap *soap, const char *tag, enum ns2__IraqProvinceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__IraqProvinceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IraqProvinceType, sizeof(enum ns2__IraqProvinceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__IraqProvinceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__IraqProvinceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IraqProvinceType, 0, sizeof(enum ns2__IraqProvinceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__IraqProvinceType(struct soap *soap, const enum ns2__IraqProvinceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__IraqProvinceType);
	if (soap_out_ns2__IraqProvinceType(soap, tag?tag:"ns2:IraqProvinceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__IraqProvinceType * SOAP_FMAC4 soap_get_ns2__IraqProvinceType(struct soap *soap, enum ns2__IraqProvinceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IraqProvinceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__AfghanistanProvinceType(struct soap *soap, enum ns2__AfghanistanProvinceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__AfghanistanProvinceType
	*a = SOAP_DEFAULT_ns2__AfghanistanProvinceType;
#else
	*a = (enum ns2__AfghanistanProvinceType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__AfghanistanProvinceType[] =
{	{ (long)ns2__AfghanistanProvinceType__Badakhshan, "Badakhshan" },
	{ (long)ns2__AfghanistanProvinceType__Badghis, "Badghis" },
	{ (long)ns2__AfghanistanProvinceType__Baghlan, "Baghlan" },
	{ (long)ns2__AfghanistanProvinceType__Balkh, "Balkh" },
	{ (long)ns2__AfghanistanProvinceType__Bamian, "Bamian" },
	{ (long)ns2__AfghanistanProvinceType__Daikondi, "Daikondi" },
	{ (long)ns2__AfghanistanProvinceType__Farah, "Farah" },
	{ (long)ns2__AfghanistanProvinceType__Faryab, "Faryab" },
	{ (long)ns2__AfghanistanProvinceType__Ghazni, "Ghazni" },
	{ (long)ns2__AfghanistanProvinceType__Ghowr, "Ghowr" },
	{ (long)ns2__AfghanistanProvinceType__Helmand, "Helmand" },
	{ (long)ns2__AfghanistanProvinceType__Herat, "Herat" },
	{ (long)ns2__AfghanistanProvinceType__Jowzjan, "Jowzjan" },
	{ (long)ns2__AfghanistanProvinceType__Kabul, "Kabul" },
	{ (long)ns2__AfghanistanProvinceType__Kandahar, "Kandahar" },
	{ (long)ns2__AfghanistanProvinceType__Kapisa, "Kapisa" },
	{ (long)ns2__AfghanistanProvinceType__Khost, "Khost" },
	{ (long)ns2__AfghanistanProvinceType__Konar, "Konar" },
	{ (long)ns2__AfghanistanProvinceType__Kunduz, "Kunduz" },
	{ (long)ns2__AfghanistanProvinceType__Laghman, "Laghman" },
	{ (long)ns2__AfghanistanProvinceType__Lowgar, "Lowgar" },
	{ (long)ns2__AfghanistanProvinceType__Nangarhar, "Nangarhar" },
	{ (long)ns2__AfghanistanProvinceType__Nimruz, "Nimruz" },
	{ (long)ns2__AfghanistanProvinceType__Zaranj, "Zaranj" },
	{ (long)ns2__AfghanistanProvinceType__Nuristan, "Nuristan" },
	{ (long)ns2__AfghanistanProvinceType__Panjshir, "Panjshir" },
	{ (long)ns2__AfghanistanProvinceType__Paktia, "Paktia" },
	{ (long)ns2__AfghanistanProvinceType__Parwan, "Parwan" },
	{ (long)ns2__AfghanistanProvinceType__Samangan, "Samangan" },
	{ (long)ns2__AfghanistanProvinceType__Sar_iPol, "Sar-iPol" },
	{ (long)ns2__AfghanistanProvinceType__Takhar, "Takhar" },
	{ (long)ns2__AfghanistanProvinceType__Uruzgan, "Uruzgan" },
	{ (long)ns2__AfghanistanProvinceType__Wardak, "Wardak" },
	{ (long)ns2__AfghanistanProvinceType__Zabol, "Zabol" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__AfghanistanProvinceType2s(struct soap *soap, enum ns2__AfghanistanProvinceType n)
{	const char *s = soap_code_str(soap_codes_ns2__AfghanistanProvinceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AfghanistanProvinceType(struct soap *soap, const char *tag, int id, const enum ns2__AfghanistanProvinceType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AfghanistanProvinceType), type) || soap_send(soap, soap_ns2__AfghanistanProvinceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__AfghanistanProvinceType(struct soap *soap, const char *s, enum ns2__AfghanistanProvinceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__AfghanistanProvinceType, s);
	if (map)
		*a = (enum ns2__AfghanistanProvinceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 33)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__AfghanistanProvinceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__AfghanistanProvinceType * SOAP_FMAC4 soap_in_ns2__AfghanistanProvinceType(struct soap *soap, const char *tag, enum ns2__AfghanistanProvinceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__AfghanistanProvinceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AfghanistanProvinceType, sizeof(enum ns2__AfghanistanProvinceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__AfghanistanProvinceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__AfghanistanProvinceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AfghanistanProvinceType, 0, sizeof(enum ns2__AfghanistanProvinceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__AfghanistanProvinceType(struct soap *soap, const enum ns2__AfghanistanProvinceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__AfghanistanProvinceType);
	if (soap_out_ns2__AfghanistanProvinceType(soap, tag?tag:"ns2:AfghanistanProvinceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__AfghanistanProvinceType * SOAP_FMAC4 soap_get_ns2__AfghanistanProvinceType(struct soap *soap, enum ns2__AfghanistanProvinceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AfghanistanProvinceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CountryType(struct soap *soap, enum ns2__CountryType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CountryType
	*a = SOAP_DEFAULT_ns2__CountryType;
#else
	*a = (enum ns2__CountryType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CountryType[] =
{	{ (long)ns2__CountryType__Afghanistan, "Afghanistan" },
	{ (long)ns2__CountryType__Iraq, "Iraq" },
	{ (long)ns2__CountryType__Dijibouti, "Dijibouti" },
	{ (long)ns2__CountryType__Ethiopia, "Ethiopia" },
	{ (long)ns2__CountryType__Somalia, "Somalia" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CountryType2s(struct soap *soap, enum ns2__CountryType n)
{	const char *s = soap_code_str(soap_codes_ns2__CountryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CountryType(struct soap *soap, const char *tag, int id, const enum ns2__CountryType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CountryType), type) || soap_send(soap, soap_ns2__CountryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CountryType(struct soap *soap, const char *s, enum ns2__CountryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CountryType, s);
	if (map)
		*a = (enum ns2__CountryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CountryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CountryType * SOAP_FMAC4 soap_in_ns2__CountryType(struct soap *soap, const char *tag, enum ns2__CountryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CountryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CountryType, sizeof(enum ns2__CountryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__CountryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CountryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CountryType, 0, sizeof(enum ns2__CountryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CountryType(struct soap *soap, const enum ns2__CountryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CountryType);
	if (soap_out_ns2__CountryType(soap, tag?tag:"ns2:CountryType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CountryType * SOAP_FMAC4 soap_get_ns2__CountryType(struct soap *soap, enum ns2__CountryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CountryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__JustificationType(struct soap *soap, enum ns2__JustificationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__JustificationType
	*a = SOAP_DEFAULT_ns2__JustificationType;
#else
	*a = (enum ns2__JustificationType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__JustificationType[] =
{	{ (long)ns2__JustificationType__Command_x0020Request, "Command Request" },
	{ (long)ns2__JustificationType__Team_x0020Initiated, "Team Initiated" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__JustificationType2s(struct soap *soap, enum ns2__JustificationType n)
{	const char *s = soap_code_str(soap_codes_ns2__JustificationType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__JustificationType(struct soap *soap, const char *tag, int id, const enum ns2__JustificationType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__JustificationType), type) || soap_send(soap, soap_ns2__JustificationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__JustificationType(struct soap *soap, const char *s, enum ns2__JustificationType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__JustificationType, s);
	if (map)
		*a = (enum ns2__JustificationType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__JustificationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__JustificationType * SOAP_FMAC4 soap_in_ns2__JustificationType(struct soap *soap, const char *tag, enum ns2__JustificationType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__JustificationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__JustificationType, sizeof(enum ns2__JustificationType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__JustificationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__JustificationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__JustificationType, 0, sizeof(enum ns2__JustificationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__JustificationType(struct soap *soap, const enum ns2__JustificationType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__JustificationType);
	if (soap_out_ns2__JustificationType(soap, tag?tag:"ns2:JustificationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__JustificationType * SOAP_FMAC4 soap_get_ns2__JustificationType(struct soap *soap, enum ns2__JustificationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__JustificationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RoleType(struct soap *soap, enum ns2__RoleType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__RoleType
	*a = SOAP_DEFAULT_ns2__RoleType;
#else
	*a = (enum ns2__RoleType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__RoleType[] =
{	{ (long)ns2__RoleType__Facilitator, "Facilitator" },
	{ (long)ns2__RoleType__Financier, "Financier" },
	{ (long)ns2__RoleType__Insurgent_x0020Leader, "Insurgent Leader" },
	{ (long)ns2__RoleType__Insurgent_x0020Operative, "Insurgent Operative" },
	{ (long)ns2__RoleType__Military, "Military" },
	{ (long)ns2__RoleType__Military_x0020Leader, "Military Leader" },
	{ (long)ns2__RoleType__National_x0020Government, "National Government" },
	{ (long)ns2__RoleType__Police, "Police" },
	{ (long)ns2__RoleType__Provincial_x0020Leader, "Provincial Leader" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__RoleType2s(struct soap *soap, enum ns2__RoleType n)
{	const char *s = soap_code_str(soap_codes_ns2__RoleType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RoleType(struct soap *soap, const char *tag, int id, const enum ns2__RoleType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RoleType), type) || soap_send(soap, soap_ns2__RoleType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__RoleType(struct soap *soap, const char *s, enum ns2__RoleType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__RoleType, s);
	if (map)
		*a = (enum ns2__RoleType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__RoleType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__RoleType * SOAP_FMAC4 soap_in_ns2__RoleType(struct soap *soap, const char *tag, enum ns2__RoleType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__RoleType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RoleType, sizeof(enum ns2__RoleType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__RoleType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__RoleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RoleType, 0, sizeof(enum ns2__RoleType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RoleType(struct soap *soap, const enum ns2__RoleType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RoleType);
	if (soap_out_ns2__RoleType(soap, tag?tag:"ns2:RoleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__RoleType * SOAP_FMAC4 soap_get_ns2__RoleType(struct soap *soap, enum ns2__RoleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RoleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__WritingHandType(struct soap *soap, enum ns2__WritingHandType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__WritingHandType
	*a = SOAP_DEFAULT_ns2__WritingHandType;
#else
	*a = (enum ns2__WritingHandType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__WritingHandType[] =
{	{ (long)ns2__WritingHandType__Left, "Left" },
	{ (long)ns2__WritingHandType__Right, "Right" },
	{ (long)ns2__WritingHandType__None, "None" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__WritingHandType2s(struct soap *soap, enum ns2__WritingHandType n)
{	const char *s = soap_code_str(soap_codes_ns2__WritingHandType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WritingHandType(struct soap *soap, const char *tag, int id, const enum ns2__WritingHandType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WritingHandType), type) || soap_send(soap, soap_ns2__WritingHandType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__WritingHandType(struct soap *soap, const char *s, enum ns2__WritingHandType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__WritingHandType, s);
	if (map)
		*a = (enum ns2__WritingHandType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__WritingHandType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__WritingHandType * SOAP_FMAC4 soap_in_ns2__WritingHandType(struct soap *soap, const char *tag, enum ns2__WritingHandType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__WritingHandType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WritingHandType, sizeof(enum ns2__WritingHandType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__WritingHandType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__WritingHandType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WritingHandType, 0, sizeof(enum ns2__WritingHandType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__WritingHandType(struct soap *soap, const enum ns2__WritingHandType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__WritingHandType);
	if (soap_out_ns2__WritingHandType(soap, tag?tag:"ns2:WritingHandType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__WritingHandType * SOAP_FMAC4 soap_get_ns2__WritingHandType(struct soap *soap, enum ns2__WritingHandType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WritingHandType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MannerOfDressType(struct soap *soap, enum ns2__MannerOfDressType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__MannerOfDressType
	*a = SOAP_DEFAULT_ns2__MannerOfDressType;
#else
	*a = (enum ns2__MannerOfDressType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__MannerOfDressType[] =
{	{ (long)ns2__MannerOfDressType__Arab, "Arab" },
	{ (long)ns2__MannerOfDressType__Western, "Western" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__MannerOfDressType2s(struct soap *soap, enum ns2__MannerOfDressType n)
{	const char *s = soap_code_str(soap_codes_ns2__MannerOfDressType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MannerOfDressType(struct soap *soap, const char *tag, int id, const enum ns2__MannerOfDressType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MannerOfDressType), type) || soap_send(soap, soap_ns2__MannerOfDressType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__MannerOfDressType(struct soap *soap, const char *s, enum ns2__MannerOfDressType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__MannerOfDressType, s);
	if (map)
		*a = (enum ns2__MannerOfDressType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__MannerOfDressType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__MannerOfDressType * SOAP_FMAC4 soap_in_ns2__MannerOfDressType(struct soap *soap, const char *tag, enum ns2__MannerOfDressType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__MannerOfDressType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MannerOfDressType, sizeof(enum ns2__MannerOfDressType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__MannerOfDressType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__MannerOfDressType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MannerOfDressType, 0, sizeof(enum ns2__MannerOfDressType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MannerOfDressType(struct soap *soap, const enum ns2__MannerOfDressType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MannerOfDressType);
	if (soap_out_ns2__MannerOfDressType(soap, tag?tag:"ns2:MannerOfDressType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__MannerOfDressType * SOAP_FMAC4 soap_get_ns2__MannerOfDressType(struct soap *soap, enum ns2__MannerOfDressType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MannerOfDressType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__BuildType(struct soap *soap, enum ns2__BuildType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__BuildType
	*a = SOAP_DEFAULT_ns2__BuildType;
#else
	*a = (enum ns2__BuildType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__BuildType[] =
{	{ (long)ns2__BuildType__Athletic, "Athletic" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__BuildType2s(struct soap *soap, enum ns2__BuildType n)
{	const char *s = soap_code_str(soap_codes_ns2__BuildType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BuildType(struct soap *soap, const char *tag, int id, const enum ns2__BuildType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BuildType), type) || soap_send(soap, soap_ns2__BuildType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__BuildType(struct soap *soap, const char *s, enum ns2__BuildType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__BuildType, s);
	if (map)
		*a = (enum ns2__BuildType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__BuildType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__BuildType * SOAP_FMAC4 soap_in_ns2__BuildType(struct soap *soap, const char *tag, enum ns2__BuildType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__BuildType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BuildType, sizeof(enum ns2__BuildType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__BuildType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__BuildType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BuildType, 0, sizeof(enum ns2__BuildType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__BuildType(struct soap *soap, const enum ns2__BuildType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__BuildType);
	if (soap_out_ns2__BuildType(soap, tag?tag:"ns2:BuildType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__BuildType * SOAP_FMAC4 soap_get_ns2__BuildType(struct soap *soap, enum ns2__BuildType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BuildType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__HairColorType(struct soap *soap, enum ns2__HairColorType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__HairColorType
	*a = SOAP_DEFAULT_ns2__HairColorType;
#else
	*a = (enum ns2__HairColorType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__HairColorType[] =
{	{ (long)ns2__HairColorType__Black, "Black" },
	{ (long)ns2__HairColorType__Blond, "Blond" },
	{ (long)ns2__HairColorType__Brown, "Brown" },
	{ (long)ns2__HairColorType__Red, "Red" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__HairColorType2s(struct soap *soap, enum ns2__HairColorType n)
{	const char *s = soap_code_str(soap_codes_ns2__HairColorType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HairColorType(struct soap *soap, const char *tag, int id, const enum ns2__HairColorType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HairColorType), type) || soap_send(soap, soap_ns2__HairColorType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__HairColorType(struct soap *soap, const char *s, enum ns2__HairColorType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__HairColorType, s);
	if (map)
		*a = (enum ns2__HairColorType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__HairColorType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__HairColorType * SOAP_FMAC4 soap_in_ns2__HairColorType(struct soap *soap, const char *tag, enum ns2__HairColorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__HairColorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HairColorType, sizeof(enum ns2__HairColorType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__HairColorType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__HairColorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HairColorType, 0, sizeof(enum ns2__HairColorType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__HairColorType(struct soap *soap, const enum ns2__HairColorType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__HairColorType);
	if (soap_out_ns2__HairColorType(soap, tag?tag:"ns2:HairColorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__HairColorType * SOAP_FMAC4 soap_get_ns2__HairColorType(struct soap *soap, enum ns2__HairColorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HairColorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__EyeColorType(struct soap *soap, enum ns2__EyeColorType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__EyeColorType
	*a = SOAP_DEFAULT_ns2__EyeColorType;
#else
	*a = (enum ns2__EyeColorType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__EyeColorType[] =
{	{ (long)ns2__EyeColorType__Brown, "Brown" },
	{ (long)ns2__EyeColorType__Blue, "Blue" },
	{ (long)ns2__EyeColorType__Green, "Green" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__EyeColorType2s(struct soap *soap, enum ns2__EyeColorType n)
{	const char *s = soap_code_str(soap_codes_ns2__EyeColorType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EyeColorType(struct soap *soap, const char *tag, int id, const enum ns2__EyeColorType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EyeColorType), type) || soap_send(soap, soap_ns2__EyeColorType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__EyeColorType(struct soap *soap, const char *s, enum ns2__EyeColorType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__EyeColorType, s);
	if (map)
		*a = (enum ns2__EyeColorType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__EyeColorType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__EyeColorType * SOAP_FMAC4 soap_in_ns2__EyeColorType(struct soap *soap, const char *tag, enum ns2__EyeColorType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__EyeColorType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EyeColorType, sizeof(enum ns2__EyeColorType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__EyeColorType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__EyeColorType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EyeColorType, 0, sizeof(enum ns2__EyeColorType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__EyeColorType(struct soap *soap, const enum ns2__EyeColorType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__EyeColorType);
	if (soap_out_ns2__EyeColorType(soap, tag?tag:"ns2:EyeColorType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__EyeColorType * SOAP_FMAC4 soap_get_ns2__EyeColorType(struct soap *soap, enum ns2__EyeColorType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EyeColorType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PoliticalStanceType(struct soap *soap, enum ns2__PoliticalStanceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__PoliticalStanceType
	*a = SOAP_DEFAULT_ns2__PoliticalStanceType;
#else
	*a = (enum ns2__PoliticalStanceType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__PoliticalStanceType[] =
{	{ (long)ns2__PoliticalStanceType__Neutral, "Neutral" },
	{ (long)ns2__PoliticalStanceType__Anti_Coalition, "Anti-Coalition" },
	{ (long)ns2__PoliticalStanceType__Anti_Government, "Anti-Government" },
	{ (long)ns2__PoliticalStanceType__Pro_Coalition, "Pro-Coalition" },
	{ (long)ns2__PoliticalStanceType__Pro_Government, "Pro-Government" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__PoliticalStanceType2s(struct soap *soap, enum ns2__PoliticalStanceType n)
{	const char *s = soap_code_str(soap_codes_ns2__PoliticalStanceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PoliticalStanceType(struct soap *soap, const char *tag, int id, const enum ns2__PoliticalStanceType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PoliticalStanceType), type) || soap_send(soap, soap_ns2__PoliticalStanceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__PoliticalStanceType(struct soap *soap, const char *s, enum ns2__PoliticalStanceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__PoliticalStanceType, s);
	if (map)
		*a = (enum ns2__PoliticalStanceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__PoliticalStanceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__PoliticalStanceType * SOAP_FMAC4 soap_in_ns2__PoliticalStanceType(struct soap *soap, const char *tag, enum ns2__PoliticalStanceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__PoliticalStanceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PoliticalStanceType, sizeof(enum ns2__PoliticalStanceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__PoliticalStanceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__PoliticalStanceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PoliticalStanceType, 0, sizeof(enum ns2__PoliticalStanceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PoliticalStanceType(struct soap *soap, const enum ns2__PoliticalStanceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PoliticalStanceType);
	if (soap_out_ns2__PoliticalStanceType(soap, tag?tag:"ns2:PoliticalStanceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PoliticalStanceType * SOAP_FMAC4 soap_get_ns2__PoliticalStanceType(struct soap *soap, enum ns2__PoliticalStanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PoliticalStanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PhysicalStatus2Type(struct soap *soap, enum ns2__PhysicalStatus2Type *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__PhysicalStatus2Type
	*a = SOAP_DEFAULT_ns2__PhysicalStatus2Type;
#else
	*a = (enum ns2__PhysicalStatus2Type)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__PhysicalStatus2Type[] =
{	{ (long)ns2__PhysicalStatus2Type__Ill_x002c_x0020contagious, "Ill, contagious" },
	{ (long)ns2__PhysicalStatus2Type__Ill_x002c_x0020non_contagious, "Ill, non-contagious" },
	{ (long)ns2__PhysicalStatus2Type__Ill_x002c_x0020unknown_x0020disease, "Ill, unknown disease" },
	{ (long)ns2__PhysicalStatus2Type__Injured, "Injured" },
	{ (long)ns2__PhysicalStatus2Type__Pregnant, "Pregnant" },
	{ (long)ns2__PhysicalStatus2Type__Wounded, "Wounded" },
	{ (long)ns2__PhysicalStatus2Type__Not_x0020known, "Not known" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__PhysicalStatus2Type2s(struct soap *soap, enum ns2__PhysicalStatus2Type n)
{	const char *s = soap_code_str(soap_codes_ns2__PhysicalStatus2Type, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PhysicalStatus2Type(struct soap *soap, const char *tag, int id, const enum ns2__PhysicalStatus2Type *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PhysicalStatus2Type), type) || soap_send(soap, soap_ns2__PhysicalStatus2Type2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__PhysicalStatus2Type(struct soap *soap, const char *s, enum ns2__PhysicalStatus2Type *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__PhysicalStatus2Type, s);
	if (map)
		*a = (enum ns2__PhysicalStatus2Type)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__PhysicalStatus2Type)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__PhysicalStatus2Type * SOAP_FMAC4 soap_in_ns2__PhysicalStatus2Type(struct soap *soap, const char *tag, enum ns2__PhysicalStatus2Type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__PhysicalStatus2Type *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PhysicalStatus2Type, sizeof(enum ns2__PhysicalStatus2Type), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__PhysicalStatus2Type(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__PhysicalStatus2Type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PhysicalStatus2Type, 0, sizeof(enum ns2__PhysicalStatus2Type), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PhysicalStatus2Type(struct soap *soap, const enum ns2__PhysicalStatus2Type *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PhysicalStatus2Type);
	if (soap_out_ns2__PhysicalStatus2Type(soap, tag?tag:"ns2:PhysicalStatus2Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PhysicalStatus2Type * SOAP_FMAC4 soap_get_ns2__PhysicalStatus2Type(struct soap *soap, enum ns2__PhysicalStatus2Type *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PhysicalStatus2Type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PhysicalStatusType(struct soap *soap, enum ns2__PhysicalStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__PhysicalStatusType
	*a = SOAP_DEFAULT_ns2__PhysicalStatusType;
#else
	*a = (enum ns2__PhysicalStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__PhysicalStatusType[] =
{	{ (long)ns2__PhysicalStatusType__Fit, "Fit" },
	{ (long)ns2__PhysicalStatusType__Incapacitated_x002c_x0020not_x0020walking, "Incapacitated, not walking" },
	{ (long)ns2__PhysicalStatusType__Incapacitated_x002c_x0020walking, "Incapacitated, walking" },
	{ (long)ns2__PhysicalStatusType__SI, "SI" },
	{ (long)ns2__PhysicalStatusType__Not_x0020known, "Not known" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__PhysicalStatusType2s(struct soap *soap, enum ns2__PhysicalStatusType n)
{	const char *s = soap_code_str(soap_codes_ns2__PhysicalStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PhysicalStatusType(struct soap *soap, const char *tag, int id, const enum ns2__PhysicalStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PhysicalStatusType), type) || soap_send(soap, soap_ns2__PhysicalStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__PhysicalStatusType(struct soap *soap, const char *s, enum ns2__PhysicalStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__PhysicalStatusType, s);
	if (map)
		*a = (enum ns2__PhysicalStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__PhysicalStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__PhysicalStatusType * SOAP_FMAC4 soap_in_ns2__PhysicalStatusType(struct soap *soap, const char *tag, enum ns2__PhysicalStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__PhysicalStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PhysicalStatusType, sizeof(enum ns2__PhysicalStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__PhysicalStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__PhysicalStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PhysicalStatusType, 0, sizeof(enum ns2__PhysicalStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PhysicalStatusType(struct soap *soap, const enum ns2__PhysicalStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PhysicalStatusType);
	if (soap_out_ns2__PhysicalStatusType(soap, tag?tag:"ns2:PhysicalStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PhysicalStatusType * SOAP_FMAC4 soap_get_ns2__PhysicalStatusType(struct soap *soap, enum ns2__PhysicalStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PhysicalStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__DutyStatusType(struct soap *soap, enum ns2__DutyStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__DutyStatusType
	*a = SOAP_DEFAULT_ns2__DutyStatusType;
#else
	*a = (enum ns2__DutyStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__DutyStatusType[] =
{	{ (long)ns2__DutyStatusType__Absent, "Absent" },
	{ (long)ns2__DutyStatusType__Arrested, "Arrested" },
	{ (long)ns2__DutyStatusType__Assumed_x0020killed_x0020in_x0020action, "Assumed killed in action" },
	{ (long)ns2__DutyStatusType__At_x0020duty, "At duty" },
	{ (long)ns2__DutyStatusType__Deceased, "Deceased" },
	{ (long)ns2__DutyStatusType__Deserted, "Deserted" },
	{ (long)ns2__DutyStatusType__Hospitalized, "Hospitalized" },
	{ (long)ns2__DutyStatusType__Hostage, "Hostage" },
	{ (long)ns2__DutyStatusType__Missing, "Missing" },
	{ (long)ns2__DutyStatusType__On_x0020leave, "On leave" },
	{ (long)ns2__DutyStatusType__Prisoner_x0020of_x0020war, "Prisoner of war" },
	{ (long)ns2__DutyStatusType__Not_x0020known, "Not known" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__DutyStatusType2s(struct soap *soap, enum ns2__DutyStatusType n)
{	const char *s = soap_code_str(soap_codes_ns2__DutyStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DutyStatusType(struct soap *soap, const char *tag, int id, const enum ns2__DutyStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DutyStatusType), type) || soap_send(soap, soap_ns2__DutyStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__DutyStatusType(struct soap *soap, const char *s, enum ns2__DutyStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__DutyStatusType, s);
	if (map)
		*a = (enum ns2__DutyStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 11)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__DutyStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__DutyStatusType * SOAP_FMAC4 soap_in_ns2__DutyStatusType(struct soap *soap, const char *tag, enum ns2__DutyStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__DutyStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DutyStatusType, sizeof(enum ns2__DutyStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__DutyStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__DutyStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DutyStatusType, 0, sizeof(enum ns2__DutyStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__DutyStatusType(struct soap *soap, const enum ns2__DutyStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__DutyStatusType);
	if (soap_out_ns2__DutyStatusType(soap, tag?tag:"ns2:DutyStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DutyStatusType * SOAP_FMAC4 soap_get_ns2__DutyStatusType(struct soap *soap, enum ns2__DutyStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DutyStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__RankType(struct soap *soap, enum ns2__RankType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__RankType
	*a = SOAP_DEFAULT_ns2__RankType;
#else
	*a = (enum ns2__RankType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__RankType[] =
{	{ (long)ns2__RankType__Enlisted_x0020private, "Enlisted private" },
	{ (long)ns2__RankType__NCO_x002c_x0020not_x0020otherwise_x0020specified, "NCO, not otherwise specified" },
	{ (long)ns2__RankType__OF_1, "OF-1" },
	{ (long)ns2__RankType__OF_10, "OF-10" },
	{ (long)ns2__RankType__OF_2, "OF-2" },
	{ (long)ns2__RankType__OF_3, "OF-3" },
	{ (long)ns2__RankType__OF_4, "OF-4" },
	{ (long)ns2__RankType__OF_5, "OF-5" },
	{ (long)ns2__RankType__OF_6, "OF-6" },
	{ (long)ns2__RankType__OF_7, "OF-7" },
	{ (long)ns2__RankType__OF_8, "OF-8" },
	{ (long)ns2__RankType__OF_9, "OF-9" },
	{ (long)ns2__RankType__Officer_x002c_x0020not_x0020otherwise_x0020specified, "Officer, not otherwise specified" },
	{ (long)ns2__RankType__OR_1, "OR-1" },
	{ (long)ns2__RankType__OR_2, "OR-2" },
	{ (long)ns2__RankType__OR_3, "OR-3" },
	{ (long)ns2__RankType__OR_4, "OR-4" },
	{ (long)ns2__RankType__OR_5, "OR-5" },
	{ (long)ns2__RankType__OR_6, "OR-6" },
	{ (long)ns2__RankType__OR_7, "OR-7" },
	{ (long)ns2__RankType__OR_8, "OR-8" },
	{ (long)ns2__RankType__OR_9, "OR-9" },
	{ (long)ns2__RankType__Other_x0020ranks, "Other ranks" },
	{ (long)ns2__RankType__Not_x0020known, "Not known" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__RankType2s(struct soap *soap, enum ns2__RankType n)
{	const char *s = soap_code_str(soap_codes_ns2__RankType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RankType(struct soap *soap, const char *tag, int id, const enum ns2__RankType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RankType), type) || soap_send(soap, soap_ns2__RankType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__RankType(struct soap *soap, const char *s, enum ns2__RankType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__RankType, s);
	if (map)
		*a = (enum ns2__RankType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 23)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__RankType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__RankType * SOAP_FMAC4 soap_in_ns2__RankType(struct soap *soap, const char *tag, enum ns2__RankType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__RankType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RankType, sizeof(enum ns2__RankType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__RankType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__RankType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RankType, 0, sizeof(enum ns2__RankType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__RankType(struct soap *soap, const enum ns2__RankType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__RankType);
	if (soap_out_ns2__RankType(soap, tag?tag:"ns2:RankType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__RankType * SOAP_FMAC4 soap_get_ns2__RankType(struct soap *soap, enum ns2__RankType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RankType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PeopleType2Type(struct soap *soap, enum ns2__PeopleType2Type *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__PeopleType2Type
	*a = SOAP_DEFAULT_ns2__PeopleType2Type;
#else
	*a = (enum ns2__PeopleType2Type)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__PeopleType2Type[] =
{	{ (long)ns2__PeopleType2Type__Defector, "Defector" },
	{ (long)ns2__PeopleType2Type__Deserter, "Deserter" },
	{ (long)ns2__PeopleType2Type__Detainee, "Detainee" },
	{ (long)ns2__PeopleType2Type__Displaced_x0020person, "Displaced person" },
	{ (long)ns2__PeopleType2Type__Engineer, "Engineer" },
	{ (long)ns2__PeopleType2Type__Government_x0020employee, "Government employee" },
	{ (long)ns2__PeopleType2Type__Intellectual, "Intellectual" },
	{ (long)ns2__PeopleType2Type__Journalist, "Journalist" },
	{ (long)ns2__PeopleType2Type__Landowner, "Landowner" },
	{ (long)ns2__PeopleType2Type__Media_x002c_x0020international, "Media, international" },
	{ (long)ns2__PeopleType2Type__Media_x002c_x0020local, "Media, local" },
	{ (long)ns2__PeopleType2Type__Media_x002c_x0020national, "Media, national" },
	{ (long)ns2__PeopleType2Type__Media_x002c_x0020not_x0020otherwise_x0020specified, "Media, not otherwise specified" },
	{ (long)ns2__PeopleType2Type__Medical, "Medical" },
	{ (long)ns2__PeopleType2Type__Merchant, "Merchant" },
	{ (long)ns2__PeopleType2Type__Messenger, "Messenger" },
	{ (long)ns2__PeopleType2Type__Missionary, "Missionary" },
	{ (long)ns2__PeopleType2Type__Non_government_x0020eployee, "Non-government eployee" },
	{ (long)ns2__PeopleType2Type__Pararescue_x0020jumper, "Pararescue jumper" },
	{ (long)ns2__PeopleType2Type__Partisan, "Partisan" },
	{ (long)ns2__PeopleType2Type__Pilot, "Pilot" },
	{ (long)ns2__PeopleType2Type__Police_x0020chief, "Police chief" },
	{ (long)ns2__PeopleType2Type__Policeman, "Policeman" },
	{ (long)ns2__PeopleType2Type__Prisoner, "Prisoner" },
	{ (long)ns2__PeopleType2Type__Prisoner_x0020of_x0020war, "Prisoner of war" },
	{ (long)ns2__PeopleType2Type__Refugee, "Refugee" },
	{ (long)ns2__PeopleType2Type__Repatriate, "Repatriate" },
	{ (long)ns2__PeopleType2Type__Saboteur, "Saboteur" },
	{ (long)ns2__PeopleType2Type__Spy, "Spy" },
	{ (long)ns2__PeopleType2Type__Terrorist, "Terrorist" },
	{ (long)ns2__PeopleType2Type__Unlawful_x0020combatant, "Unlawful combatant" },
	{ (long)ns2__PeopleType2Type__Village_x0020elder, "Village elder" },
	{ (long)ns2__PeopleType2Type__Writer, "Writer" },
	{ (long)ns2__PeopleType2Type__Not_x0020known, "Not known" },
	{ (long)ns2__PeopleType2Type__Not_x0020otherwise_x0020specified, "Not otherwise specified" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__PeopleType2Type2s(struct soap *soap, enum ns2__PeopleType2Type n)
{	const char *s = soap_code_str(soap_codes_ns2__PeopleType2Type, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PeopleType2Type(struct soap *soap, const char *tag, int id, const enum ns2__PeopleType2Type *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PeopleType2Type), type) || soap_send(soap, soap_ns2__PeopleType2Type2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__PeopleType2Type(struct soap *soap, const char *s, enum ns2__PeopleType2Type *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__PeopleType2Type, s);
	if (map)
		*a = (enum ns2__PeopleType2Type)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 34)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__PeopleType2Type)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__PeopleType2Type * SOAP_FMAC4 soap_in_ns2__PeopleType2Type(struct soap *soap, const char *tag, enum ns2__PeopleType2Type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__PeopleType2Type *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PeopleType2Type, sizeof(enum ns2__PeopleType2Type), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__PeopleType2Type(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__PeopleType2Type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PeopleType2Type, 0, sizeof(enum ns2__PeopleType2Type), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PeopleType2Type(struct soap *soap, const enum ns2__PeopleType2Type *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PeopleType2Type);
	if (soap_out_ns2__PeopleType2Type(soap, tag?tag:"ns2:PeopleType2Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PeopleType2Type * SOAP_FMAC4 soap_get_ns2__PeopleType2Type(struct soap *soap, enum ns2__PeopleType2Type *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PeopleType2Type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__PeopleTypeType(struct soap *soap, enum ns2__PeopleTypeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__PeopleTypeType
	*a = SOAP_DEFAULT_ns2__PeopleTypeType;
#else
	*a = (enum ns2__PeopleTypeType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__PeopleTypeType[] =
{	{ (long)ns2__PeopleTypeType__Civilian, "Civilian" },
	{ (long)ns2__PeopleTypeType__Military, "Military" },
	{ (long)ns2__PeopleTypeType__Paramilitary, "Paramilitary" },
	{ (long)ns2__PeopleTypeType__Not_x0020known, "Not known" },
	{ (long)ns2__PeopleTypeType__Not_x0020otherwise_x0020specified, "Not otherwise specified" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__PeopleTypeType2s(struct soap *soap, enum ns2__PeopleTypeType n)
{	const char *s = soap_code_str(soap_codes_ns2__PeopleTypeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PeopleTypeType(struct soap *soap, const char *tag, int id, const enum ns2__PeopleTypeType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PeopleTypeType), type) || soap_send(soap, soap_ns2__PeopleTypeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__PeopleTypeType(struct soap *soap, const char *s, enum ns2__PeopleTypeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__PeopleTypeType, s);
	if (map)
		*a = (enum ns2__PeopleTypeType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__PeopleTypeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__PeopleTypeType * SOAP_FMAC4 soap_in_ns2__PeopleTypeType(struct soap *soap, const char *tag, enum ns2__PeopleTypeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__PeopleTypeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PeopleTypeType, sizeof(enum ns2__PeopleTypeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__PeopleTypeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__PeopleTypeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PeopleTypeType, 0, sizeof(enum ns2__PeopleTypeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__PeopleTypeType(struct soap *soap, const enum ns2__PeopleTypeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__PeopleTypeType);
	if (soap_out_ns2__PeopleTypeType(soap, tag?tag:"ns2:PeopleTypeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PeopleTypeType * SOAP_FMAC4 soap_get_ns2__PeopleTypeType(struct soap *soap, enum ns2__PeopleTypeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PeopleTypeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__GenderType(struct soap *soap, enum ns2__GenderType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__GenderType
	*a = SOAP_DEFAULT_ns2__GenderType;
#else
	*a = (enum ns2__GenderType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__GenderType[] =
{	{ (long)ns2__GenderType__Male, "Male" },
	{ (long)ns2__GenderType__Female, "Female" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__GenderType2s(struct soap *soap, enum ns2__GenderType n)
{	const char *s = soap_code_str(soap_codes_ns2__GenderType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__GenderType(struct soap *soap, const char *tag, int id, const enum ns2__GenderType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__GenderType), type) || soap_send(soap, soap_ns2__GenderType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__GenderType(struct soap *soap, const char *s, enum ns2__GenderType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__GenderType, s);
	if (map)
		*a = (enum ns2__GenderType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__GenderType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__GenderType * SOAP_FMAC4 soap_in_ns2__GenderType(struct soap *soap, const char *tag, enum ns2__GenderType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__GenderType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__GenderType, sizeof(enum ns2__GenderType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__GenderType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__GenderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__GenderType, 0, sizeof(enum ns2__GenderType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__GenderType(struct soap *soap, const enum ns2__GenderType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__GenderType);
	if (soap_out_ns2__GenderType(soap, tag?tag:"ns2:GenderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__GenderType * SOAP_FMAC4 soap_get_ns2__GenderType(struct soap *soap, enum ns2__GenderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__GenderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__YesNoType(struct soap *soap, enum ns2__YesNoType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__YesNoType
	*a = SOAP_DEFAULT_ns2__YesNoType;
#else
	*a = (enum ns2__YesNoType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__YesNoType[] =
{	{ (long)ns2__YesNoType__Yes, "Yes" },
	{ (long)ns2__YesNoType__No, "No" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__YesNoType2s(struct soap *soap, enum ns2__YesNoType n)
{	const char *s = soap_code_str(soap_codes_ns2__YesNoType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__YesNoType(struct soap *soap, const char *tag, int id, const enum ns2__YesNoType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__YesNoType), type) || soap_send(soap, soap_ns2__YesNoType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__YesNoType(struct soap *soap, const char *s, enum ns2__YesNoType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__YesNoType, s);
	if (map)
		*a = (enum ns2__YesNoType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__YesNoType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__YesNoType * SOAP_FMAC4 soap_in_ns2__YesNoType(struct soap *soap, const char *tag, enum ns2__YesNoType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__YesNoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__YesNoType, sizeof(enum ns2__YesNoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__YesNoType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__YesNoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__YesNoType, 0, sizeof(enum ns2__YesNoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__YesNoType(struct soap *soap, const enum ns2__YesNoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__YesNoType);
	if (soap_out_ns2__YesNoType(soap, tag?tag:"ns2:YesNoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__YesNoType * SOAP_FMAC4 soap_get_ns2__YesNoType(struct soap *soap, enum ns2__YesNoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__YesNoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__OperationalStatus2Type(struct soap *soap, enum ns2__OperationalStatus2Type *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__OperationalStatus2Type
	*a = SOAP_DEFAULT_ns2__OperationalStatus2Type;
#else
	*a = (enum ns2__OperationalStatus2Type)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__OperationalStatus2Type[] =
{	{ (long)ns2__OperationalStatus2Type__Destroyed, "Destroyed" },
	{ (long)ns2__OperationalStatus2Type__Heavily_x0020Damaged, "Heavily Damaged" },
	{ (long)ns2__OperationalStatus2Type__Lacking_x0020vital_x0020resources, "Lacking vital resources" },
	{ (long)ns2__OperationalStatus2Type__Lightly_x0020damaged, "Lightly damaged" },
	{ (long)ns2__OperationalStatus2Type__Lost, "Lost" },
	{ (long)ns2__OperationalStatus2Type__Moderately_x0020damaged, "Moderately damaged" },
	{ (long)ns2__OperationalStatus2Type__Not_x0020known, "Not known" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__OperationalStatus2Type2s(struct soap *soap, enum ns2__OperationalStatus2Type n)
{	const char *s = soap_code_str(soap_codes_ns2__OperationalStatus2Type, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OperationalStatus2Type(struct soap *soap, const char *tag, int id, const enum ns2__OperationalStatus2Type *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OperationalStatus2Type), type) || soap_send(soap, soap_ns2__OperationalStatus2Type2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__OperationalStatus2Type(struct soap *soap, const char *s, enum ns2__OperationalStatus2Type *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__OperationalStatus2Type, s);
	if (map)
		*a = (enum ns2__OperationalStatus2Type)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__OperationalStatus2Type)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__OperationalStatus2Type * SOAP_FMAC4 soap_in_ns2__OperationalStatus2Type(struct soap *soap, const char *tag, enum ns2__OperationalStatus2Type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__OperationalStatus2Type *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OperationalStatus2Type, sizeof(enum ns2__OperationalStatus2Type), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__OperationalStatus2Type(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__OperationalStatus2Type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OperationalStatus2Type, 0, sizeof(enum ns2__OperationalStatus2Type), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__OperationalStatus2Type(struct soap *soap, const enum ns2__OperationalStatus2Type *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__OperationalStatus2Type);
	if (soap_out_ns2__OperationalStatus2Type(soap, tag?tag:"ns2:OperationalStatus2Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__OperationalStatus2Type * SOAP_FMAC4 soap_get_ns2__OperationalStatus2Type(struct soap *soap, enum ns2__OperationalStatus2Type *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OperationalStatus2Type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__OperationalStatusType(struct soap *soap, enum ns2__OperationalStatusType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__OperationalStatusType
	*a = SOAP_DEFAULT_ns2__OperationalStatusType;
#else
	*a = (enum ns2__OperationalStatusType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__OperationalStatusType[] =
{	{ (long)ns2__OperationalStatusType__Operational, "Operational" },
	{ (long)ns2__OperationalStatusType__Marginally_x0020operational, "Marginally operational" },
	{ (long)ns2__OperationalStatusType__Not_x0020operational, "Not operational" },
	{ (long)ns2__OperationalStatusType__Substantially_x0020operational, "Substantially operational" },
	{ (long)ns2__OperationalStatusType__Temporarily_x0020not_x0020operational, "Temporarily not operational" },
	{ (long)ns2__OperationalStatusType__Not_x0020known, "Not known" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__OperationalStatusType2s(struct soap *soap, enum ns2__OperationalStatusType n)
{	const char *s = soap_code_str(soap_codes_ns2__OperationalStatusType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OperationalStatusType(struct soap *soap, const char *tag, int id, const enum ns2__OperationalStatusType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OperationalStatusType), type) || soap_send(soap, soap_ns2__OperationalStatusType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__OperationalStatusType(struct soap *soap, const char *s, enum ns2__OperationalStatusType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__OperationalStatusType, s);
	if (map)
		*a = (enum ns2__OperationalStatusType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__OperationalStatusType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__OperationalStatusType * SOAP_FMAC4 soap_in_ns2__OperationalStatusType(struct soap *soap, const char *tag, enum ns2__OperationalStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__OperationalStatusType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OperationalStatusType, sizeof(enum ns2__OperationalStatusType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__OperationalStatusType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__OperationalStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OperationalStatusType, 0, sizeof(enum ns2__OperationalStatusType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__OperationalStatusType(struct soap *soap, const enum ns2__OperationalStatusType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__OperationalStatusType);
	if (soap_out_ns2__OperationalStatusType(soap, tag?tag:"ns2:OperationalStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__OperationalStatusType * SOAP_FMAC4 soap_get_ns2__OperationalStatusType(struct soap *soap, enum ns2__OperationalStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OperationalStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ReleasabilityType(struct soap *soap, enum ns2__ReleasabilityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ReleasabilityType
	*a = SOAP_DEFAULT_ns2__ReleasabilityType;
#else
	*a = (enum ns2__ReleasabilityType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ReleasabilityType[] =
{	{ (long)ns2__ReleasabilityType__REL_x0020TO_x0020USA_x002c_x0020AFG, "REL TO USA, AFG" },
	{ (long)ns2__ReleasabilityType__REL_x0020TO_x0020USA_x002c_x0020AFG_x002c_x0020GCTF_x002c_x0020ISAF_x002c_x0020NATO, "REL TO USA, AFG, GCTF, ISAF, NATO" },
	{ (long)ns2__ReleasabilityType__REL_x0020TO_x0020USA_x002c_x0020AUS_x002c_x0020CAN_x002c_x0020GBR, "REL TO USA, AUS, CAN, GBR" },
	{ (long)ns2__ReleasabilityType__REL_x0020TO_x0020USA_x002c_x0020AUS_x002c_x0020CAN_x002c_x0020GBR_x002c_x0020NLD_x002c_x0020NZL, "REL TO USA, AUS, CAN, GBR, NLD, NZL" },
	{ (long)ns2__ReleasabilityType__REL_x0020TO_x0020USA_x002c_x0020GCTF_x002c_x0020ISAF_x002c_x0020NATO, "REL TO USA, GCTF, ISAF, NATO" },
	{ (long)ns2__ReleasabilityType__REL_x0020TO_x0020USA_x002c_x0020MCFI, "REL TO USA, MCFI" },
	{ (long)ns2__ReleasabilityType__REL_x0020TO_x0020USA_x002c_x0020NATO, "REL TO USA, NATO" },
	{ (long)ns2__ReleasabilityType__NONE, "NONE" },
	{ (long)ns2__ReleasabilityType__FOR_x0020OFFICIAL_x0020USE_x0020ONLY, "FOR OFFICIAL USE ONLY" },
	{ (long)ns2__ReleasabilityType__REL_x0020TO_x0020USA_x002c_x0020ISAF_x002c_x0020NATO, "REL TO USA, ISAF, NATO" },
	{ (long)ns2__ReleasabilityType__NOFORN, "NOFORN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ReleasabilityType2s(struct soap *soap, enum ns2__ReleasabilityType n)
{	const char *s = soap_code_str(soap_codes_ns2__ReleasabilityType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReleasabilityType(struct soap *soap, const char *tag, int id, const enum ns2__ReleasabilityType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReleasabilityType), type) || soap_send(soap, soap_ns2__ReleasabilityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ReleasabilityType(struct soap *soap, const char *s, enum ns2__ReleasabilityType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ReleasabilityType, s);
	if (map)
		*a = (enum ns2__ReleasabilityType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ReleasabilityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ReleasabilityType * SOAP_FMAC4 soap_in_ns2__ReleasabilityType(struct soap *soap, const char *tag, enum ns2__ReleasabilityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ReleasabilityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReleasabilityType, sizeof(enum ns2__ReleasabilityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ReleasabilityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ReleasabilityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReleasabilityType, 0, sizeof(enum ns2__ReleasabilityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ReleasabilityType(struct soap *soap, const enum ns2__ReleasabilityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ReleasabilityType);
	if (soap_out_ns2__ReleasabilityType(soap, tag?tag:"ns2:ReleasabilityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ReleasabilityType * SOAP_FMAC4 soap_get_ns2__ReleasabilityType(struct soap *soap, enum ns2__ReleasabilityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReleasabilityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ClassificationType(struct soap *soap, enum ns2__ClassificationType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ClassificationType
	*a = SOAP_DEFAULT_ns2__ClassificationType;
#else
	*a = (enum ns2__ClassificationType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ClassificationType[] =
{	{ (long)ns2__ClassificationType__CONFIDENTIAL, "CONFIDENTIAL" },
	{ (long)ns2__ClassificationType__SECRET, "SECRET" },
	{ (long)ns2__ClassificationType__UNCLASSIFIED, "UNCLASSIFIED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ClassificationType2s(struct soap *soap, enum ns2__ClassificationType n)
{	const char *s = soap_code_str(soap_codes_ns2__ClassificationType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ClassificationType(struct soap *soap, const char *tag, int id, const enum ns2__ClassificationType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ClassificationType), type) || soap_send(soap, soap_ns2__ClassificationType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ClassificationType(struct soap *soap, const char *s, enum ns2__ClassificationType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ClassificationType, s);
	if (map)
		*a = (enum ns2__ClassificationType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ClassificationType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ClassificationType * SOAP_FMAC4 soap_in_ns2__ClassificationType(struct soap *soap, const char *tag, enum ns2__ClassificationType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ClassificationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ClassificationType, sizeof(enum ns2__ClassificationType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ClassificationType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ClassificationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ClassificationType, 0, sizeof(enum ns2__ClassificationType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ClassificationType(struct soap *soap, const enum ns2__ClassificationType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ClassificationType);
	if (soap_out_ns2__ClassificationType(soap, tag?tag:"ns2:ClassificationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ClassificationType * SOAP_FMAC4 soap_get_ns2__ClassificationType(struct soap *soap, enum ns2__ClassificationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ClassificationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CategoryValueType(struct soap *soap, enum ns2__CategoryValueType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CategoryValueType
	*a = SOAP_DEFAULT_ns2__CategoryValueType;
#else
	*a = (enum ns2__CategoryValueType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CategoryValueType[] =
{	{ (long)ns2__CategoryValueType__Guid, "Guid" },
	{ (long)ns2__CategoryValueType__Name, "Name" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CategoryValueType2s(struct soap *soap, enum ns2__CategoryValueType n)
{	const char *s = soap_code_str(soap_codes_ns2__CategoryValueType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CategoryValueType(struct soap *soap, const char *tag, int id, const enum ns2__CategoryValueType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CategoryValueType), type) || soap_send(soap, soap_ns2__CategoryValueType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CategoryValueType(struct soap *soap, const char *s, enum ns2__CategoryValueType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CategoryValueType, s);
	if (map)
		*a = (enum ns2__CategoryValueType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CategoryValueType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CategoryValueType * SOAP_FMAC4 soap_in_ns2__CategoryValueType(struct soap *soap, const char *tag, enum ns2__CategoryValueType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CategoryValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CategoryValueType, sizeof(enum ns2__CategoryValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__CategoryValueType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CategoryValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CategoryValueType, 0, sizeof(enum ns2__CategoryValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CategoryValueType(struct soap *soap, const enum ns2__CategoryValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CategoryValueType);
	if (soap_out_ns2__CategoryValueType(soap, tag?tag:"ns2:CategoryValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CategoryValueType * SOAP_FMAC4 soap_get_ns2__CategoryValueType(struct soap *soap, enum ns2__CategoryValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CategoryValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__UnitValueType(struct soap *soap, enum ns2__UnitValueType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__UnitValueType
	*a = SOAP_DEFAULT_ns2__UnitValueType;
#else
	*a = (enum ns2__UnitValueType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__UnitValueType[] =
{	{ (long)ns2__UnitValueType__Guid, "Guid" },
	{ (long)ns2__UnitValueType__Name, "Name" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__UnitValueType2s(struct soap *soap, enum ns2__UnitValueType n)
{	const char *s = soap_code_str(soap_codes_ns2__UnitValueType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UnitValueType(struct soap *soap, const char *tag, int id, const enum ns2__UnitValueType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UnitValueType), type) || soap_send(soap, soap_ns2__UnitValueType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__UnitValueType(struct soap *soap, const char *s, enum ns2__UnitValueType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__UnitValueType, s);
	if (map)
		*a = (enum ns2__UnitValueType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__UnitValueType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__UnitValueType * SOAP_FMAC4 soap_in_ns2__UnitValueType(struct soap *soap, const char *tag, enum ns2__UnitValueType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__UnitValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UnitValueType, sizeof(enum ns2__UnitValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__UnitValueType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__UnitValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UnitValueType, 0, sizeof(enum ns2__UnitValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__UnitValueType(struct soap *soap, const enum ns2__UnitValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__UnitValueType);
	if (soap_out_ns2__UnitValueType(soap, tag?tag:"ns2:UnitValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__UnitValueType * SOAP_FMAC4 soap_get_ns2__UnitValueType(struct soap *soap, enum ns2__UnitValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UnitValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CardinalityType(struct soap *soap, enum ns2__CardinalityType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__CardinalityType
	*a = SOAP_DEFAULT_ns2__CardinalityType;
#else
	*a = (enum ns2__CardinalityType)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__CardinalityType[] =
{	{ (long)ns2__CardinalityType__ZeroOrOne, "ZeroOrOne" },
	{ (long)ns2__CardinalityType__One, "One" },
	{ (long)ns2__CardinalityType__Many, "Many" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__CardinalityType2s(struct soap *soap, enum ns2__CardinalityType n)
{	const char *s = soap_code_str(soap_codes_ns2__CardinalityType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CardinalityType(struct soap *soap, const char *tag, int id, const enum ns2__CardinalityType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CardinalityType), type) || soap_send(soap, soap_ns2__CardinalityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__CardinalityType(struct soap *soap, const char *s, enum ns2__CardinalityType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__CardinalityType, s);
	if (map)
		*a = (enum ns2__CardinalityType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__CardinalityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__CardinalityType * SOAP_FMAC4 soap_in_ns2__CardinalityType(struct soap *soap, const char *tag, enum ns2__CardinalityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__CardinalityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CardinalityType, sizeof(enum ns2__CardinalityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__CardinalityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__CardinalityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CardinalityType, 0, sizeof(enum ns2__CardinalityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CardinalityType(struct soap *soap, const enum ns2__CardinalityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CardinalityType);
	if (soap_out_ns2__CardinalityType(soap, tag?tag:"ns2:CardinalityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CardinalityType * SOAP_FMAC4 soap_get_ns2__CardinalityType(struct soap *soap, enum ns2__CardinalityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CardinalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__wsa5__IsReferenceParameter
	*a = SOAP_DEFAULT__wsa5__IsReferenceParameter;
#else
	*a = (enum _wsa5__IsReferenceParameter)0;
#endif
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (long)wsa5__false, "wsa5:false" },
	{ (long)wsa5__true, "wsa5:true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, t);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, 0, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa5__IsReferenceParameter);
	if (soap_out__wsa5__IsReferenceParameter(soap, tag?tag:"wsa5:IsReferenceParameter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__FaultCodesType
	*a = SOAP_DEFAULT_wsa5__FaultCodesType;
#else
	*a = (enum wsa5__FaultCodesType)0;
#endif
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (long)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (long)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (long)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (long)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (long)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (long)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (long)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (long)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (long)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (long)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (long)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, 0, sizeof(enum wsa5__FaultCodesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__FaultCodesType);
	if (soap_out_wsa5__FaultCodesType(soap, tag?tag:"wsa5:FaultCodesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsa5__RelationshipType
	*a = SOAP_DEFAULT_wsa5__RelationshipType;
#else
	*a = (enum wsa5__RelationshipType)0;
#endif
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (long)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsa5__RelationshipType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, 0, sizeof(enum wsa5__RelationshipType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelationshipType);
	if (soap_out_wsa5__RelationshipType(soap, tag?tag:"wsa5:RelationshipType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsse__FaultcodeEnum
	*a = SOAP_DEFAULT_wsse__FaultcodeEnum;
#else
	*a = (enum wsse__FaultcodeEnum)0;
#endif
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (long)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (long)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (long)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (long)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (long)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (long)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (long)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, 0, sizeof(enum wsse__FaultcodeEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsse__FaultcodeEnum);
	if (soap_out_wsse__FaultcodeEnum(soap, tag?tag:"wsse:FaultcodeEnum", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsu__tTimestampFault
	*a = SOAP_DEFAULT_wsu__tTimestampFault;
#else
	*a = (enum wsu__tTimestampFault)0;
#endif
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (long)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsu__tTimestampFault(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, 0, sizeof(enum wsu__tTimestampFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsu__tTimestampFault);
	if (soap_out_wsu__tTimestampFault(soap, tag?tag:"wsu:tTimestampFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void __ns2__union_LocationListType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns2__union_LocationListType::__unionAbstractGeometry = 0;
}

void __ns2__union_LocationListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_LocationListType(soap, this->__ns2__union_LocationListType::__unionAbstractGeometry, &this->__ns2__union_LocationListType::__union_LocationListType);
}

int __ns2__union_LocationListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__union_LocationListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__union_LocationListType(struct soap *soap, const char *tag, int id, const __ns2__union_LocationListType *a, const char *type)
{
	if (soap_out__ns2__union_LocationListType(soap, a->__ns2__union_LocationListType::__unionAbstractGeometry, &a->__ns2__union_LocationListType::__union_LocationListType))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_LocationListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__union_LocationListType(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__union_LocationListType * SOAP_FMAC4 soap_in___ns2__union_LocationListType(struct soap *soap, const char *tag, __ns2__union_LocationListType *a, const char *type)
{
	a = (__ns2__union_LocationListType *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__union_LocationListType, sizeof(__ns2__union_LocationListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE___ns2__union_LocationListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (__ns2__union_LocationListType *)a->soap_in(soap, tag, type);
		}
	}
		if (!soap_in__ns2__union_LocationListType(soap, &a->__unionAbstractGeometry, &a->__union_LocationListType))
			return NULL;
	return a;
}

int __ns2__union_LocationListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:union-LocationListType", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_LocationListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__union_LocationListType(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__union_LocationListType * SOAP_FMAC4 soap_get___ns2__union_LocationListType(struct soap *soap, __ns2__union_LocationListType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__union_LocationListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__union_LocationListType * SOAP_FMAC2 soap_instantiate___ns2__union_LocationListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__union_LocationListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__union_LocationListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__union_LocationListType);
		if (size)
			*size = sizeof(__ns2__union_LocationListType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__ns2__union_LocationListType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__ns2__union_LocationListType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__ns2__union_LocationListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__union_LocationListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__union_LocationListType %p -> %p\n", q, p));
	*(__ns2__union_LocationListType*)p = *(__ns2__union_LocationListType*)q;
}

void __ns2__union_AbstractContentReferenceListType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns2__union_AbstractContentReferenceListType::__unionAbstractContentReference = 0;
}

void __ns2__union_AbstractContentReferenceListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_AbstractContentReferenceListType(soap, this->__ns2__union_AbstractContentReferenceListType::__unionAbstractContentReference, &this->__ns2__union_AbstractContentReferenceListType::__union_AbstractContentReferenceListType);
}

int __ns2__union_AbstractContentReferenceListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__union_AbstractContentReferenceListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__union_AbstractContentReferenceListType(struct soap *soap, const char *tag, int id, const __ns2__union_AbstractContentReferenceListType *a, const char *type)
{
	if (soap_out__ns2__union_AbstractContentReferenceListType(soap, a->__ns2__union_AbstractContentReferenceListType::__unionAbstractContentReference, &a->__ns2__union_AbstractContentReferenceListType::__union_AbstractContentReferenceListType))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_AbstractContentReferenceListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__union_AbstractContentReferenceListType(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__union_AbstractContentReferenceListType * SOAP_FMAC4 soap_in___ns2__union_AbstractContentReferenceListType(struct soap *soap, const char *tag, __ns2__union_AbstractContentReferenceListType *a, const char *type)
{
	a = (__ns2__union_AbstractContentReferenceListType *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__union_AbstractContentReferenceListType, sizeof(__ns2__union_AbstractContentReferenceListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE___ns2__union_AbstractContentReferenceListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (__ns2__union_AbstractContentReferenceListType *)a->soap_in(soap, tag, type);
		}
	}
		if (!soap_in__ns2__union_AbstractContentReferenceListType(soap, &a->__unionAbstractContentReference, &a->__union_AbstractContentReferenceListType))
			return NULL;
	return a;
}

int __ns2__union_AbstractContentReferenceListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:union-AbstractContentReferenceListType", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_AbstractContentReferenceListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__union_AbstractContentReferenceListType(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__union_AbstractContentReferenceListType * SOAP_FMAC4 soap_get___ns2__union_AbstractContentReferenceListType(struct soap *soap, __ns2__union_AbstractContentReferenceListType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__union_AbstractContentReferenceListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__union_AbstractContentReferenceListType * SOAP_FMAC2 soap_instantiate___ns2__union_AbstractContentReferenceListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__union_AbstractContentReferenceListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__union_AbstractContentReferenceListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__union_AbstractContentReferenceListType);
		if (size)
			*size = sizeof(__ns2__union_AbstractContentReferenceListType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__ns2__union_AbstractContentReferenceListType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__ns2__union_AbstractContentReferenceListType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__ns2__union_AbstractContentReferenceListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__union_AbstractContentReferenceListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__union_AbstractContentReferenceListType %p -> %p\n", q, p));
	*(__ns2__union_AbstractContentReferenceListType*)p = *(__ns2__union_AbstractContentReferenceListType*)q;
}

void __ns2__union_GetResponseType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ns2__union_GetResponseType::__union_GetResponseType = 0;
}

void __ns2__union_GetResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_GetResponseType(soap, this->__ns2__union_GetResponseType::__union_GetResponseType, &this->__ns2__union_GetResponseType::union_GetResponseType);
}

int __ns2__union_GetResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___ns2__union_GetResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__union_GetResponseType(struct soap *soap, const char *tag, int id, const __ns2__union_GetResponseType *a, const char *type)
{
	if (soap_out__ns2__union_GetResponseType(soap, a->__ns2__union_GetResponseType::__union_GetResponseType, &a->__ns2__union_GetResponseType::union_GetResponseType))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_GetResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___ns2__union_GetResponseType(soap, tag, this, type);
}

SOAP_FMAC3 __ns2__union_GetResponseType * SOAP_FMAC4 soap_in___ns2__union_GetResponseType(struct soap *soap, const char *tag, __ns2__union_GetResponseType *a, const char *type)
{
	a = (__ns2__union_GetResponseType *)soap_class_id_enter(soap, "", a, SOAP_TYPE___ns2__union_GetResponseType, sizeof(__ns2__union_GetResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE___ns2__union_GetResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (__ns2__union_GetResponseType *)a->soap_in(soap, tag, type);
		}
	}
		if (!soap_in__ns2__union_GetResponseType(soap, &a->__union_GetResponseType, &a->union_GetResponseType))
			return NULL;
	return a;
}

int __ns2__union_GetResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag?tag:"-ns2:union-GetResponseType", id, type))
		return soap->error;
	return SOAP_OK;
}

void *__ns2__union_GetResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___ns2__union_GetResponseType(soap, this, tag, type);
}

SOAP_FMAC3 __ns2__union_GetResponseType * SOAP_FMAC4 soap_get___ns2__union_GetResponseType(struct soap *soap, __ns2__union_GetResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__union_GetResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 __ns2__union_GetResponseType * SOAP_FMAC2 soap_instantiate___ns2__union_GetResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__union_GetResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__union_GetResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(__ns2__union_GetResponseType);
		if (size)
			*size = sizeof(__ns2__union_GetResponseType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(__ns2__union_GetResponseType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__ns2__union_GetResponseType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__ns2__union_GetResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__union_GetResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __ns2__union_GetResponseType %p -> %p\n", q, p));
	*(__ns2__union_GetResponseType*)p = *(__ns2__union_GetResponseType*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__VersionType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns3__VersionType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns3__VersionType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__VersionType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__VersionType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns3__VersionType, 0, sizeof(std::string), 0, soap_copy_ns3__VersionType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__VersionType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__VersionType);
	if (soap_out_ns3__VersionType(soap, tag?tag:"ns3:VersionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns3__VersionType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__VersionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__GuidType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns3__GuidType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns3__GuidType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__GuidType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__GuidType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns3__GuidType, 0, sizeof(std::string), 0, soap_copy_ns3__GuidType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__GuidType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__GuidType);
	if (soap_out_ns3__GuidType(soap, tag?tag:"ns3:GuidType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns3__GuidType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__GuidType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__MimeType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns3__MimeType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns3__MimeType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__MimeType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__MimeType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns3__MimeType, 0, sizeof(std::string), 0, soap_copy_ns3__MimeType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__MimeType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__MimeType);
	if (soap_out_ns3__MimeType(soap, tag?tag:"ns3:MimeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns3__MimeType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__MimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__NonEmptyStringType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns3__NonEmptyStringType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns3__NonEmptyStringType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__NonEmptyStringType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, 1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__NonEmptyStringType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns3__NonEmptyStringType, 0, sizeof(std::string), 0, soap_copy_ns3__NonEmptyStringType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__NonEmptyStringType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__NonEmptyStringType);
	if (soap_out_ns3__NonEmptyStringType(soap, tag?tag:"ns3:NonEmptyStringType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns3__NonEmptyStringType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__NonEmptyStringType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__CoordinatesType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns3__CoordinatesType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns3__CoordinatesType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__CoordinatesType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__CoordinatesType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns3__CoordinatesType, 0, sizeof(std::string), 0, soap_copy_ns3__CoordinatesType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__CoordinatesType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__CoordinatesType);
	if (soap_out_ns3__CoordinatesType(soap, tag?tag:"ns3:CoordinatesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns3__CoordinatesType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__CoordinatesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__URIListType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns3__URIListType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns3__URIListType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__URIListType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__URIListType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns3__URIListType, 0, sizeof(std::string), 0, soap_copy_ns3__URIListType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__URIListType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__URIListType);
	if (soap_out_ns3__URIListType(soap, tag?tag:"ns3:URIListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns3__URIListType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__URIListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__QNameListType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns3__QNameListType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns3__QNameListType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__QNameListType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__QNameListType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns3__QNameListType, 0, sizeof(std::string), 0, soap_copy_ns3__QNameListType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__QNameListType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__QNameListType);
	if (soap_out_ns3__QNameListType(soap, tag?tag:"ns3:QNameListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns3__QNameListType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__QNameListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__PolygonType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__PolygonType::exterior = NULL;
	this->ns3__PolygonType::interior = NULL;
	this->ns3__AbstractGeometryType::crs = NULL;
	/* transient soap skipped */
}

void ns3__PolygonType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__LinearRingType(soap, &this->ns3__PolygonType::exterior);
	soap_serialize_PointerTons3__LinearRingType(soap, &this->ns3__PolygonType::interior);
	/* transient soap skipped */
}

int ns3__PolygonType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__PolygonType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__PolygonType(struct soap *soap, const char *tag, int id, const ns3__PolygonType *a, const char *type)
{
	if (((ns3__AbstractGeometryType*)a)->crs)
		soap_set_attr(soap, "crs", ((ns3__AbstractGeometryType*)a)->crs->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__PolygonType), "ns3:PolygonType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons3__LinearRingType(soap, "ns3:exterior", -1, &(a->ns3__PolygonType::exterior), ""))
		return soap->error;
	if (soap_out_PointerTons3__LinearRingType(soap, "ns3:interior", -1, &(a->ns3__PolygonType::interior), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__PolygonType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__PolygonType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__PolygonType * SOAP_FMAC4 soap_in_ns3__PolygonType(struct soap *soap, const char *tag, ns3__PolygonType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__PolygonType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__PolygonType, sizeof(ns3__PolygonType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__PolygonType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__PolygonType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "crs", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((ns3__AbstractGeometryType*)a)->crs = soap_new_std__string(soap, -1);
				((ns3__AbstractGeometryType*)a)->crs->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_exterior1 = 1;
	size_t soap_flag_interior1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_exterior1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__LinearRingType(soap, "ns3:exterior", &(a->ns3__PolygonType::exterior), "ns3:LinearRingType"))
				{	soap_flag_exterior1--;
					continue;
				}
			if (soap_flag_interior1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__LinearRingType(soap, "ns3:interior", &(a->ns3__PolygonType::interior), "ns3:LinearRingType"))
				{	soap_flag_interior1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__PolygonType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__PolygonType, 0, sizeof(ns3__PolygonType), 0, soap_copy_ns3__PolygonType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_exterior1 > 0 || soap_flag_interior1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__PolygonType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__PolygonType);
	if (this->soap_out(soap, tag?tag:"ns3:PolygonType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__PolygonType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__PolygonType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__PolygonType * SOAP_FMAC4 soap_get_ns3__PolygonType(struct soap *soap, ns3__PolygonType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__PolygonType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__PolygonType * SOAP_FMAC2 soap_instantiate_ns3__PolygonType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__PolygonType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__PolygonType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__PolygonType);
		if (size)
			*size = sizeof(ns3__PolygonType);
		((ns3__PolygonType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__PolygonType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__PolygonType);
		for (int i = 0; i < n; i++)
			((ns3__PolygonType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__PolygonType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__PolygonType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__PolygonType %p -> %p\n", q, p));
	*(ns3__PolygonType*)p = *(ns3__PolygonType*)q;
}

void ns3__LinearRingType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__CoordinatesType(soap, &this->ns3__LinearRingType::coordinates);
	this->ns3__AbstractGeometryType::crs = NULL;
	/* transient soap skipped */
}

void ns3__LinearRingType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns3__CoordinatesType(soap, &this->ns3__LinearRingType::coordinates);
	/* transient soap skipped */
}

int ns3__LinearRingType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__LinearRingType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__LinearRingType(struct soap *soap, const char *tag, int id, const ns3__LinearRingType *a, const char *type)
{
	if (((ns3__AbstractGeometryType*)a)->crs)
		soap_set_attr(soap, "crs", ((ns3__AbstractGeometryType*)a)->crs->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__LinearRingType), "ns3:LinearRingType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_ns3__CoordinatesType(soap, "ns3:coordinates", -1, &(a->ns3__LinearRingType::coordinates), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__LinearRingType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__LinearRingType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__LinearRingType * SOAP_FMAC4 soap_in_ns3__LinearRingType(struct soap *soap, const char *tag, ns3__LinearRingType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__LinearRingType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__LinearRingType, sizeof(ns3__LinearRingType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__LinearRingType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__LinearRingType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "crs", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((ns3__AbstractGeometryType*)a)->crs = soap_new_std__string(soap, -1);
				((ns3__AbstractGeometryType*)a)->crs->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_coordinates1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_coordinates1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__CoordinatesType(soap, "ns3:coordinates", &(a->ns3__LinearRingType::coordinates), "ns3:CoordinatesType"))
				{	soap_flag_coordinates1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__LinearRingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__LinearRingType, 0, sizeof(ns3__LinearRingType), 0, soap_copy_ns3__LinearRingType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_coordinates1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__LinearRingType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__LinearRingType);
	if (this->soap_out(soap, tag?tag:"ns3:LinearRingType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__LinearRingType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__LinearRingType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__LinearRingType * SOAP_FMAC4 soap_get_ns3__LinearRingType(struct soap *soap, ns3__LinearRingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__LinearRingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__LinearRingType * SOAP_FMAC2 soap_instantiate_ns3__LinearRingType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__LinearRingType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__LinearRingType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__LinearRingType);
		if (size)
			*size = sizeof(ns3__LinearRingType);
		((ns3__LinearRingType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__LinearRingType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__LinearRingType);
		for (int i = 0; i < n; i++)
			((ns3__LinearRingType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__LinearRingType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__LinearRingType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__LinearRingType %p -> %p\n", q, p));
	*(ns3__LinearRingType*)p = *(ns3__LinearRingType*)q;
}

void ns3__LineStringType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__CoordinatesType(soap, &this->ns3__LineStringType::coordinates);
	this->ns3__AbstractGeometryType::crs = NULL;
	/* transient soap skipped */
}

void ns3__LineStringType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns3__CoordinatesType(soap, &this->ns3__LineStringType::coordinates);
	/* transient soap skipped */
}

int ns3__LineStringType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__LineStringType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__LineStringType(struct soap *soap, const char *tag, int id, const ns3__LineStringType *a, const char *type)
{
	if (((ns3__AbstractGeometryType*)a)->crs)
		soap_set_attr(soap, "crs", ((ns3__AbstractGeometryType*)a)->crs->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__LineStringType), "ns3:LineStringType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_ns3__CoordinatesType(soap, "ns3:coordinates", -1, &(a->ns3__LineStringType::coordinates), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__LineStringType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__LineStringType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__LineStringType * SOAP_FMAC4 soap_in_ns3__LineStringType(struct soap *soap, const char *tag, ns3__LineStringType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__LineStringType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__LineStringType, sizeof(ns3__LineStringType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__LineStringType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__LineStringType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "crs", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((ns3__AbstractGeometryType*)a)->crs = soap_new_std__string(soap, -1);
				((ns3__AbstractGeometryType*)a)->crs->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_coordinates1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_coordinates1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__CoordinatesType(soap, "ns3:coordinates", &(a->ns3__LineStringType::coordinates), "ns3:CoordinatesType"))
				{	soap_flag_coordinates1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__LineStringType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__LineStringType, 0, sizeof(ns3__LineStringType), 0, soap_copy_ns3__LineStringType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_coordinates1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__LineStringType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__LineStringType);
	if (this->soap_out(soap, tag?tag:"ns3:LineStringType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__LineStringType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__LineStringType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__LineStringType * SOAP_FMAC4 soap_get_ns3__LineStringType(struct soap *soap, ns3__LineStringType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__LineStringType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__LineStringType * SOAP_FMAC2 soap_instantiate_ns3__LineStringType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__LineStringType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__LineStringType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__LineStringType);
		if (size)
			*size = sizeof(ns3__LineStringType);
		((ns3__LineStringType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__LineStringType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__LineStringType);
		for (int i = 0; i < n; i++)
			((ns3__LineStringType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__LineStringType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__LineStringType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__LineStringType %p -> %p\n", q, p));
	*(ns3__LineStringType*)p = *(ns3__LineStringType*)q;
}

void ns3__PointType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__CoordinatesType(soap, &this->ns3__PointType::coordinates);
	this->ns3__AbstractGeometryType::crs = NULL;
	/* transient soap skipped */
}

void ns3__PointType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns3__CoordinatesType(soap, &this->ns3__PointType::coordinates);
	/* transient soap skipped */
}

int ns3__PointType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__PointType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__PointType(struct soap *soap, const char *tag, int id, const ns3__PointType *a, const char *type)
{
	if (((ns3__AbstractGeometryType*)a)->crs)
		soap_set_attr(soap, "crs", ((ns3__AbstractGeometryType*)a)->crs->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__PointType), "ns3:PointType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_ns3__CoordinatesType(soap, "ns3:coordinates", -1, &(a->ns3__PointType::coordinates), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__PointType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__PointType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__PointType * SOAP_FMAC4 soap_in_ns3__PointType(struct soap *soap, const char *tag, ns3__PointType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__PointType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__PointType, sizeof(ns3__PointType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__PointType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__PointType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "crs", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((ns3__AbstractGeometryType*)a)->crs = soap_new_std__string(soap, -1);
				((ns3__AbstractGeometryType*)a)->crs->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_coordinates1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_coordinates1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__CoordinatesType(soap, "ns3:coordinates", &(a->ns3__PointType::coordinates), "ns3:CoordinatesType"))
				{	soap_flag_coordinates1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__PointType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__PointType, 0, sizeof(ns3__PointType), 0, soap_copy_ns3__PointType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_coordinates1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__PointType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__PointType);
	if (this->soap_out(soap, tag?tag:"ns3:PointType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__PointType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__PointType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__PointType * SOAP_FMAC4 soap_get_ns3__PointType(struct soap *soap, ns3__PointType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__PointType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__PointType * SOAP_FMAC2 soap_instantiate_ns3__PointType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__PointType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__PointType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__PointType);
		if (size)
			*size = sizeof(ns3__PointType);
		((ns3__PointType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__PointType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__PointType);
		for (int i = 0; i < n; i++)
			((ns3__PointType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__PointType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__PointType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__PointType %p -> %p\n", q, p));
	*(ns3__PointType*)p = *(ns3__PointType*)q;
}

void ns3__AbstractGeometryType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns3__AbstractGeometryType::crs = NULL;
	/* transient soap skipped */
}

void ns3__AbstractGeometryType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns3__AbstractGeometryType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__AbstractGeometryType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AbstractGeometryType(struct soap *soap, const char *tag, int id, const ns3__AbstractGeometryType *a, const char *type)
{
	if (((ns3__AbstractGeometryType*)a)->crs)
		soap_set_attr(soap, "crs", ((ns3__AbstractGeometryType*)a)->crs->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__AbstractGeometryType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__AbstractGeometryType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__AbstractGeometryType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__AbstractGeometryType * SOAP_FMAC4 soap_in_ns3__AbstractGeometryType(struct soap *soap, const char *tag, ns3__AbstractGeometryType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__AbstractGeometryType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__AbstractGeometryType, sizeof(ns3__AbstractGeometryType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__AbstractGeometryType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__AbstractGeometryType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "crs", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((ns3__AbstractGeometryType*)a)->crs = soap_new_std__string(soap, -1);
				((ns3__AbstractGeometryType*)a)->crs->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__AbstractGeometryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__AbstractGeometryType, 0, sizeof(ns3__AbstractGeometryType), 0, soap_copy_ns3__AbstractGeometryType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__AbstractGeometryType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__AbstractGeometryType);
	if (this->soap_out(soap, tag?tag:"ns3:AbstractGeometryType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__AbstractGeometryType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__AbstractGeometryType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__AbstractGeometryType * SOAP_FMAC4 soap_get_ns3__AbstractGeometryType(struct soap *soap, ns3__AbstractGeometryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__AbstractGeometryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__AbstractGeometryType * SOAP_FMAC2 soap_instantiate_ns3__AbstractGeometryType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__AbstractGeometryType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__AbstractGeometryType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns3:PointType"))
	{	cp->type = SOAP_TYPE_ns3__PointType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns3__PointType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns3__PointType);
			((ns3__PointType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns3__PointType[n]);
			if (size)
				*size = n * sizeof(ns3__PointType);
			for (int i = 0; i < n; i++)
				((ns3__PointType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__PointType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:LineStringType"))
	{	cp->type = SOAP_TYPE_ns3__LineStringType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns3__LineStringType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns3__LineStringType);
			((ns3__LineStringType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns3__LineStringType[n]);
			if (size)
				*size = n * sizeof(ns3__LineStringType);
			for (int i = 0; i < n; i++)
				((ns3__LineStringType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__LineStringType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:LinearRingType"))
	{	cp->type = SOAP_TYPE_ns3__LinearRingType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns3__LinearRingType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns3__LinearRingType);
			((ns3__LinearRingType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns3__LinearRingType[n]);
			if (size)
				*size = n * sizeof(ns3__LinearRingType);
			for (int i = 0; i < n; i++)
				((ns3__LinearRingType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__LinearRingType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:PolygonType"))
	{	cp->type = SOAP_TYPE_ns3__PolygonType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns3__PolygonType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns3__PolygonType);
			((ns3__PolygonType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns3__PolygonType[n]);
			if (size)
				*size = n * sizeof(ns3__PolygonType);
			for (int i = 0; i < n; i++)
				((ns3__PolygonType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__PolygonType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__AbstractGeometryType);
		if (size)
			*size = sizeof(ns3__AbstractGeometryType);
		((ns3__AbstractGeometryType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__AbstractGeometryType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__AbstractGeometryType);
		for (int i = 0; i < n; i++)
			((ns3__AbstractGeometryType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__AbstractGeometryType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__AbstractGeometryType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__AbstractGeometryType %p -> %p\n", q, p));
	*(ns3__AbstractGeometryType*)p = *(ns3__AbstractGeometryType*)q;
}

void ns3__EnvelopeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__CoordinatesType(soap, &this->ns3__EnvelopeType::lowerCorner);
	soap_default_ns3__CoordinatesType(soap, &this->ns3__EnvelopeType::upperCorner);
	/* transient soap skipped */
}

void ns3__EnvelopeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns3__CoordinatesType(soap, &this->ns3__EnvelopeType::lowerCorner);
	soap_serialize_ns3__CoordinatesType(soap, &this->ns3__EnvelopeType::upperCorner);
	/* transient soap skipped */
}

int ns3__EnvelopeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__EnvelopeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__EnvelopeType(struct soap *soap, const char *tag, int id, const ns3__EnvelopeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__EnvelopeType), type))
		return soap->error;
	if (soap_out_ns3__CoordinatesType(soap, "ns3:lowerCorner", -1, &(a->ns3__EnvelopeType::lowerCorner), ""))
		return soap->error;
	if (soap_out_ns3__CoordinatesType(soap, "ns3:upperCorner", -1, &(a->ns3__EnvelopeType::upperCorner), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__EnvelopeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__EnvelopeType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__EnvelopeType * SOAP_FMAC4 soap_in_ns3__EnvelopeType(struct soap *soap, const char *tag, ns3__EnvelopeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__EnvelopeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__EnvelopeType, sizeof(ns3__EnvelopeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__EnvelopeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__EnvelopeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_lowerCorner1 = 1;
	size_t soap_flag_upperCorner1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lowerCorner1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__CoordinatesType(soap, "ns3:lowerCorner", &(a->ns3__EnvelopeType::lowerCorner), "ns3:CoordinatesType"))
				{	soap_flag_lowerCorner1--;
					continue;
				}
			if (soap_flag_upperCorner1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__CoordinatesType(soap, "ns3:upperCorner", &(a->ns3__EnvelopeType::upperCorner), "ns3:CoordinatesType"))
				{	soap_flag_upperCorner1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__EnvelopeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__EnvelopeType, 0, sizeof(ns3__EnvelopeType), 0, soap_copy_ns3__EnvelopeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lowerCorner1 > 0 || soap_flag_upperCorner1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__EnvelopeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__EnvelopeType);
	if (this->soap_out(soap, tag?tag:"ns3:EnvelopeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__EnvelopeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__EnvelopeType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__EnvelopeType * SOAP_FMAC4 soap_get_ns3__EnvelopeType(struct soap *soap, ns3__EnvelopeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__EnvelopeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__EnvelopeType * SOAP_FMAC2 soap_instantiate_ns3__EnvelopeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__EnvelopeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__EnvelopeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__EnvelopeType);
		if (size)
			*size = sizeof(ns3__EnvelopeType);
		((ns3__EnvelopeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__EnvelopeType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__EnvelopeType);
		for (int i = 0; i < n; i++)
			((ns3__EnvelopeType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__EnvelopeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__EnvelopeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__EnvelopeType %p -> %p\n", q, p));
	*(ns3__EnvelopeType*)p = *(ns3__EnvelopeType*)q;
}

void ns3__GetCapabilitiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns3__GetCapabilitiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns3__GetCapabilitiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__GetCapabilitiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__GetCapabilitiesType(struct soap *soap, const char *tag, int id, const ns3__GetCapabilitiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__GetCapabilitiesType), "ns3:GetCapabilitiesType"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__GetCapabilitiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__GetCapabilitiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__GetCapabilitiesType * SOAP_FMAC4 soap_in_ns3__GetCapabilitiesType(struct soap *soap, const char *tag, ns3__GetCapabilitiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__GetCapabilitiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__GetCapabilitiesType, sizeof(ns3__GetCapabilitiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__GetCapabilitiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__GetCapabilitiesType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__GetCapabilitiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__GetCapabilitiesType, 0, sizeof(ns3__GetCapabilitiesType), 0, soap_copy_ns3__GetCapabilitiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__GetCapabilitiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__GetCapabilitiesType);
	if (this->soap_out(soap, tag?tag:"ns3:GetCapabilitiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__GetCapabilitiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__GetCapabilitiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__GetCapabilitiesType * SOAP_FMAC4 soap_get_ns3__GetCapabilitiesType(struct soap *soap, ns3__GetCapabilitiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__GetCapabilitiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__GetCapabilitiesType * SOAP_FMAC2 soap_instantiate_ns3__GetCapabilitiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__GetCapabilitiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__GetCapabilitiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__GetCapabilitiesType);
		if (size)
			*size = sizeof(ns3__GetCapabilitiesType);
		((ns3__GetCapabilitiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__GetCapabilitiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__GetCapabilitiesType);
		for (int i = 0; i < n; i++)
			((ns3__GetCapabilitiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__GetCapabilitiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__GetCapabilitiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__GetCapabilitiesType %p -> %p\n", q, p));
	*(ns3__GetCapabilitiesType*)p = *(ns3__GetCapabilitiesType*)q;
}

void ns3__BaseServiceCapabilitiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__VersionType(soap, &this->ns3__BaseServiceCapabilitiesType::version);
	/* transient soap skipped */
}

void ns3__BaseServiceCapabilitiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns3__BaseServiceCapabilitiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__BaseServiceCapabilitiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__BaseServiceCapabilitiesType(struct soap *soap, const char *tag, int id, const ns3__BaseServiceCapabilitiesType *a, const char *type)
{
	if (!((ns3__BaseServiceCapabilitiesType*)a)->version.empty())
		soap_set_attr(soap, "version", ((ns3__BaseServiceCapabilitiesType*)a)->version.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__BaseServiceCapabilitiesType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__BaseServiceCapabilitiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__BaseServiceCapabilitiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__BaseServiceCapabilitiesType * SOAP_FMAC4 soap_in_ns3__BaseServiceCapabilitiesType(struct soap *soap, const char *tag, ns3__BaseServiceCapabilitiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__BaseServiceCapabilitiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__BaseServiceCapabilitiesType, sizeof(ns3__BaseServiceCapabilitiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__BaseServiceCapabilitiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__BaseServiceCapabilitiesType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "version", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns3__BaseServiceCapabilitiesType*)a)->version.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__BaseServiceCapabilitiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__BaseServiceCapabilitiesType, 0, sizeof(ns3__BaseServiceCapabilitiesType), 0, soap_copy_ns3__BaseServiceCapabilitiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__BaseServiceCapabilitiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__BaseServiceCapabilitiesType);
	if (this->soap_out(soap, tag?tag:"ns3:BaseServiceCapabilitiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__BaseServiceCapabilitiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__BaseServiceCapabilitiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__BaseServiceCapabilitiesType * SOAP_FMAC4 soap_get_ns3__BaseServiceCapabilitiesType(struct soap *soap, ns3__BaseServiceCapabilitiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__BaseServiceCapabilitiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__BaseServiceCapabilitiesType * SOAP_FMAC2 soap_instantiate_ns3__BaseServiceCapabilitiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__BaseServiceCapabilitiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__BaseServiceCapabilitiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:ContentServiceCapabilitiesType"))
	{	cp->type = SOAP_TYPE_ns2__ContentServiceCapabilitiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ContentServiceCapabilitiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ContentServiceCapabilitiesType);
			((ns2__ContentServiceCapabilitiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ContentServiceCapabilitiesType[n]);
			if (size)
				*size = n * sizeof(ns2__ContentServiceCapabilitiesType);
			for (int i = 0; i < n; i++)
				((ns2__ContentServiceCapabilitiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ContentServiceCapabilitiesType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__BaseServiceCapabilitiesType);
		if (size)
			*size = sizeof(ns3__BaseServiceCapabilitiesType);
		((ns3__BaseServiceCapabilitiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__BaseServiceCapabilitiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__BaseServiceCapabilitiesType);
		for (int i = 0; i < n; i++)
			((ns3__BaseServiceCapabilitiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__BaseServiceCapabilitiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__BaseServiceCapabilitiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__BaseServiceCapabilitiesType %p -> %p\n", q, p));
	*(ns3__BaseServiceCapabilitiesType*)p = *(ns3__BaseServiceCapabilitiesType*)q;
}

void ns3__BaseRequestType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns3__BaseRequestType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns3__BaseRequestType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__BaseRequestType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__BaseRequestType(struct soap *soap, const char *tag, int id, const ns3__BaseRequestType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__BaseRequestType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__BaseRequestType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__BaseRequestType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__BaseRequestType * SOAP_FMAC4 soap_in_ns3__BaseRequestType(struct soap *soap, const char *tag, ns3__BaseRequestType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__BaseRequestType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__BaseRequestType, sizeof(ns3__BaseRequestType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__BaseRequestType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__BaseRequestType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__BaseRequestType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__BaseRequestType, 0, sizeof(ns3__BaseRequestType), 0, soap_copy_ns3__BaseRequestType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__BaseRequestType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__BaseRequestType);
	if (this->soap_out(soap, tag?tag:"ns3:BaseRequestType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__BaseRequestType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__BaseRequestType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__BaseRequestType * SOAP_FMAC4 soap_get_ns3__BaseRequestType(struct soap *soap, ns3__BaseRequestType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__BaseRequestType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__BaseRequestType * SOAP_FMAC2 soap_instantiate_ns3__BaseRequestType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__BaseRequestType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__BaseRequestType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:CreateType"))
	{	cp->type = SOAP_TYPE_ns2__CreateType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__CreateType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__CreateType);
			((ns2__CreateType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__CreateType[n]);
			if (size)
				*size = n * sizeof(ns2__CreateType);
			for (int i = 0; i < n; i++)
				((ns2__CreateType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__CreateType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:UpdateType"))
	{	cp->type = SOAP_TYPE_ns2__UpdateType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__UpdateType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__UpdateType);
			((ns2__UpdateType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__UpdateType[n]);
			if (size)
				*size = n * sizeof(ns2__UpdateType);
			for (int i = 0; i < n; i++)
				((ns2__UpdateType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__UpdateType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:DeleteType"))
	{	cp->type = SOAP_TYPE_ns2__DeleteType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__DeleteType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__DeleteType);
			((ns2__DeleteType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__DeleteType[n]);
			if (size)
				*size = n * sizeof(ns2__DeleteType);
			for (int i = 0; i < n; i++)
				((ns2__DeleteType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__DeleteType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:GetType"))
	{	cp->type = SOAP_TYPE_ns2__GetType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__GetType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__GetType);
			((ns2__GetType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__GetType[n]);
			if (size)
				*size = n * sizeof(ns2__GetType);
			for (int i = 0; i < n; i++)
				((ns2__GetType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__GetType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:GetCapabilitiesType"))
	{	cp->type = SOAP_TYPE_ns3__GetCapabilitiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns3__GetCapabilitiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns3__GetCapabilitiesType);
			((ns3__GetCapabilitiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns3__GetCapabilitiesType[n]);
			if (size)
				*size = n * sizeof(ns3__GetCapabilitiesType);
			for (int i = 0; i < n; i++)
				((ns3__GetCapabilitiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__GetCapabilitiesType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__BaseRequestType);
		if (size)
			*size = sizeof(ns3__BaseRequestType);
		((ns3__BaseRequestType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__BaseRequestType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__BaseRequestType);
		for (int i = 0; i < n; i++)
			((ns3__BaseRequestType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__BaseRequestType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__BaseRequestType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__BaseRequestType %p -> %p\n", q, p));
	*(ns3__BaseRequestType*)p = *(ns3__BaseRequestType*)q;
}

void ns3__TimePeriodType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->ns3__TimePeriodType::start);
	soap_default_time(soap, &this->ns3__TimePeriodType::end);
	/* transient soap skipped */
}

void ns3__TimePeriodType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns3__TimePeriodType::start, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns3__TimePeriodType::end, SOAP_TYPE_time);
	/* transient soap skipped */
}

int ns3__TimePeriodType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__TimePeriodType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__TimePeriodType(struct soap *soap, const char *tag, int id, const ns3__TimePeriodType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__TimePeriodType), type))
		return soap->error;
	if (soap_out_time(soap, "ns3:start", -1, &(a->ns3__TimePeriodType::start), ""))
		return soap->error;
	if (soap_out_time(soap, "ns3:end", -1, &(a->ns3__TimePeriodType::end), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__TimePeriodType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__TimePeriodType(soap, tag, this, type);
}

SOAP_FMAC3 ns3__TimePeriodType * SOAP_FMAC4 soap_in_ns3__TimePeriodType(struct soap *soap, const char *tag, ns3__TimePeriodType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__TimePeriodType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__TimePeriodType, sizeof(ns3__TimePeriodType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__TimePeriodType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__TimePeriodType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_start1 = 1;
	size_t soap_flag_end1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_start1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns3:start", &(a->ns3__TimePeriodType::start), "xsd:dateTime"))
				{	soap_flag_start1--;
					continue;
				}
			if (soap_flag_end1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns3:end", &(a->ns3__TimePeriodType::end), "xsd:dateTime"))
				{	soap_flag_end1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__TimePeriodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__TimePeriodType, 0, sizeof(ns3__TimePeriodType), 0, soap_copy_ns3__TimePeriodType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_start1 > 0 || soap_flag_end1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns3__TimePeriodType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__TimePeriodType);
	if (this->soap_out(soap, tag?tag:"ns3:TimePeriodType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__TimePeriodType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__TimePeriodType(soap, this, tag, type);
}

SOAP_FMAC3 ns3__TimePeriodType * SOAP_FMAC4 soap_get_ns3__TimePeriodType(struct soap *soap, ns3__TimePeriodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__TimePeriodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__TimePeriodType * SOAP_FMAC2 soap_instantiate_ns3__TimePeriodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__TimePeriodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__TimePeriodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__TimePeriodType);
		if (size)
			*size = sizeof(ns3__TimePeriodType);
		((ns3__TimePeriodType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__TimePeriodType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__TimePeriodType);
		for (int i = 0; i < n; i++)
			((ns3__TimePeriodType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__TimePeriodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__TimePeriodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__TimePeriodType %p -> %p\n", q, p));
	*(ns3__TimePeriodType*)p = *(ns3__TimePeriodType*)q;
}

void ns2__OrganizationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__OrganizationType::CommandFunction = NULL;
	this->ns2__OrganizationType::CommandAndControl = NULL;
	this->ns2__OrganizationType::GroupPeople = NULL;
	this->ns2__OrganizationType::Availability = NULL;
	this->ns2__OrganizationType::OperationalStatus = NULL;
	this->ns2__OrganizationType::OperationalStatus2 = NULL;
	this->ns2__OrganizationType::UsageStatus = NULL;
	this->ns2__OrganizationType::CommitmentStatus = NULL;
	this->ns2__OrganizationType::Readiness = NULL;
	this->ns2__OrganizationType::CBRNDressStatus = NULL;
	this->ns2__OrganizationType::TrainingStatus = NULL;
	this->ns2__OrganizationType::ReinforcementStatus = NULL;
	soap_default_std__string(soap, &this->ns2__OrganizationType::Summary);
	/* transient soap skipped */
}

void ns2__OrganizationType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__YesNoType(soap, &this->ns2__OrganizationType::CommandFunction);
	soap_serialize_PointerTons2__CommandAndControlType(soap, &this->ns2__OrganizationType::CommandAndControl);
	soap_serialize_PointerTons2__GroupPeopleType(soap, &this->ns2__OrganizationType::GroupPeople);
	soap_serialize_PointerTons2__AvailabilityType(soap, &this->ns2__OrganizationType::Availability);
	soap_serialize_PointerTons2__OperationalStatusType(soap, &this->ns2__OrganizationType::OperationalStatus);
	soap_serialize_PointerTons2__OperationalStatus2Type(soap, &this->ns2__OrganizationType::OperationalStatus2);
	soap_serialize_PointerTo_ns2__OrganizationType_UsageStatus(soap, &this->ns2__OrganizationType::UsageStatus);
	soap_serialize_PointerTons2__CommitmentStatusType(soap, &this->ns2__OrganizationType::CommitmentStatus);
	soap_serialize_PointerTons2__ReadinessType(soap, &this->ns2__OrganizationType::Readiness);
	soap_serialize_PointerTons2__CBRNDressStatusType(soap, &this->ns2__OrganizationType::CBRNDressStatus);
	soap_serialize_PointerTons2__TrainingStatusType(soap, &this->ns2__OrganizationType::TrainingStatus);
	soap_serialize_PointerTons2__ReinforcementStatusType(soap, &this->ns2__OrganizationType::ReinforcementStatus);
	soap_embedded(soap, &this->ns2__OrganizationType::Summary, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__OrganizationType::Summary);
	/* transient soap skipped */
}

int ns2__OrganizationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OrganizationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OrganizationType(struct soap *soap, const char *tag, int id, const ns2__OrganizationType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OrganizationType), type))
		return soap->error;
	if (soap_out_PointerTons2__YesNoType(soap, "ns2:CommandFunction", -1, &(a->ns2__OrganizationType::CommandFunction), ""))
		return soap->error;
	if (soap_out_PointerTons2__CommandAndControlType(soap, "ns2:CommandAndControl", -1, &(a->ns2__OrganizationType::CommandAndControl), ""))
		return soap->error;
	if (soap_out_PointerTons2__GroupPeopleType(soap, "ns2:GroupPeople", -1, &(a->ns2__OrganizationType::GroupPeople), ""))
		return soap->error;
	if (soap_out_PointerTons2__AvailabilityType(soap, "ns2:Availability", -1, &(a->ns2__OrganizationType::Availability), ""))
		return soap->error;
	if (soap_out_PointerTons2__OperationalStatusType(soap, "ns2:OperationalStatus", -1, &(a->ns2__OrganizationType::OperationalStatus), ""))
		return soap->error;
	if (soap_out_PointerTons2__OperationalStatus2Type(soap, "ns2:OperationalStatus2", -1, &(a->ns2__OrganizationType::OperationalStatus2), ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__OrganizationType_UsageStatus(soap, "ns2:UsageStatus", -1, &(a->ns2__OrganizationType::UsageStatus), ""))
		return soap->error;
	if (soap_out_PointerTons2__CommitmentStatusType(soap, "ns2:CommitmentStatus", -1, &(a->ns2__OrganizationType::CommitmentStatus), ""))
		return soap->error;
	if (soap_out_PointerTons2__ReadinessType(soap, "ns2:Readiness", -1, &(a->ns2__OrganizationType::Readiness), ""))
		return soap->error;
	if (soap_out_PointerTons2__CBRNDressStatusType(soap, "ns2:CBRNDressStatus", -1, &(a->ns2__OrganizationType::CBRNDressStatus), ""))
		return soap->error;
	if (soap_out_PointerTons2__TrainingStatusType(soap, "ns2:TrainingStatus", -1, &(a->ns2__OrganizationType::TrainingStatus), ""))
		return soap->error;
	if (soap_out_PointerTons2__ReinforcementStatusType(soap, "ns2:ReinforcementStatus", -1, &(a->ns2__OrganizationType::ReinforcementStatus), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Summary", -1, &(a->ns2__OrganizationType::Summary), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__OrganizationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OrganizationType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OrganizationType * SOAP_FMAC4 soap_in_ns2__OrganizationType(struct soap *soap, const char *tag, ns2__OrganizationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OrganizationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OrganizationType, sizeof(ns2__OrganizationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OrganizationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OrganizationType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CommandFunction1 = 1;
	size_t soap_flag_CommandAndControl1 = 1;
	size_t soap_flag_GroupPeople1 = 1;
	size_t soap_flag_Availability1 = 1;
	size_t soap_flag_OperationalStatus1 = 1;
	size_t soap_flag_OperationalStatus21 = 1;
	size_t soap_flag_UsageStatus1 = 1;
	size_t soap_flag_CommitmentStatus1 = 1;
	size_t soap_flag_Readiness1 = 1;
	size_t soap_flag_CBRNDressStatus1 = 1;
	size_t soap_flag_TrainingStatus1 = 1;
	size_t soap_flag_ReinforcementStatus1 = 1;
	size_t soap_flag_Summary1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CommandFunction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__YesNoType(soap, "ns2:CommandFunction", &(a->ns2__OrganizationType::CommandFunction), "ns2:YesNoType"))
				{	soap_flag_CommandFunction1--;
					continue;
				}
			if (soap_flag_CommandAndControl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CommandAndControlType(soap, "ns2:CommandAndControl", &(a->ns2__OrganizationType::CommandAndControl), "ns2:CommandAndControlType"))
				{	soap_flag_CommandAndControl1--;
					continue;
				}
			if (soap_flag_GroupPeople1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__GroupPeopleType(soap, "ns2:GroupPeople", &(a->ns2__OrganizationType::GroupPeople), "ns2:GroupPeopleType"))
				{	soap_flag_GroupPeople1--;
					continue;
				}
			if (soap_flag_Availability1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AvailabilityType(soap, "ns2:Availability", &(a->ns2__OrganizationType::Availability), "ns2:AvailabilityType"))
				{	soap_flag_Availability1--;
					continue;
				}
			if (soap_flag_OperationalStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OperationalStatusType(soap, "ns2:OperationalStatus", &(a->ns2__OrganizationType::OperationalStatus), "ns2:OperationalStatusType"))
				{	soap_flag_OperationalStatus1--;
					continue;
				}
			if (soap_flag_OperationalStatus21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OperationalStatus2Type(soap, "ns2:OperationalStatus2", &(a->ns2__OrganizationType::OperationalStatus2), "ns2:OperationalStatus2Type"))
				{	soap_flag_OperationalStatus21--;
					continue;
				}
			if (soap_flag_UsageStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__OrganizationType_UsageStatus(soap, "ns2:UsageStatus", &(a->ns2__OrganizationType::UsageStatus), "ns2:OrganizationType-UsageStatus"))
				{	soap_flag_UsageStatus1--;
					continue;
				}
			if (soap_flag_CommitmentStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CommitmentStatusType(soap, "ns2:CommitmentStatus", &(a->ns2__OrganizationType::CommitmentStatus), "ns2:CommitmentStatusType"))
				{	soap_flag_CommitmentStatus1--;
					continue;
				}
			if (soap_flag_Readiness1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReadinessType(soap, "ns2:Readiness", &(a->ns2__OrganizationType::Readiness), "ns2:ReadinessType"))
				{	soap_flag_Readiness1--;
					continue;
				}
			if (soap_flag_CBRNDressStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CBRNDressStatusType(soap, "ns2:CBRNDressStatus", &(a->ns2__OrganizationType::CBRNDressStatus), "ns2:CBRNDressStatusType"))
				{	soap_flag_CBRNDressStatus1--;
					continue;
				}
			if (soap_flag_TrainingStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TrainingStatusType(soap, "ns2:TrainingStatus", &(a->ns2__OrganizationType::TrainingStatus), "ns2:TrainingStatusType"))
				{	soap_flag_TrainingStatus1--;
					continue;
				}
			if (soap_flag_ReinforcementStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReinforcementStatusType(soap, "ns2:ReinforcementStatus", &(a->ns2__OrganizationType::ReinforcementStatus), "ns2:ReinforcementStatusType"))
				{	soap_flag_ReinforcementStatus1--;
					continue;
				}
			if (soap_flag_Summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Summary", &(a->ns2__OrganizationType::Summary), "xsd:string"))
				{	soap_flag_Summary1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OrganizationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OrganizationType, 0, sizeof(ns2__OrganizationType), 0, soap_copy_ns2__OrganizationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Summary1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__OrganizationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OrganizationType);
	if (this->soap_out(soap, tag?tag:"ns2:OrganizationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OrganizationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OrganizationType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OrganizationType * SOAP_FMAC4 soap_get_ns2__OrganizationType(struct soap *soap, ns2__OrganizationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OrganizationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OrganizationType * SOAP_FMAC2 soap_instantiate_ns2__OrganizationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OrganizationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OrganizationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OrganizationType);
		if (size)
			*size = sizeof(ns2__OrganizationType);
		((ns2__OrganizationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__OrganizationType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__OrganizationType);
		for (int i = 0; i < n; i++)
			((ns2__OrganizationType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__OrganizationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OrganizationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OrganizationType %p -> %p\n", q, p));
	*(ns2__OrganizationType*)p = *(ns2__OrganizationType*)q;
}

void ns2__SpecialCollectionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__SpecialCollectionType::__union_SpecialCollectionType = 0;
	this->ns2__CollectionType::children = NULL;
	this->ns2__CollectionType::parents = NULL;
	this->ns2__CollectionType::annotations = NULL;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__SpecialCollectionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_SpecialCollectionType(soap, this->ns2__SpecialCollectionType::__union_SpecialCollectionType, &this->ns2__SpecialCollectionType::union_SpecialCollectionType);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__CollectionType::children);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__CollectionType::parents);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__CollectionType::annotations);
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__SpecialCollectionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SpecialCollectionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SpecialCollectionType(struct soap *soap, const char *tag, int id, const ns2__SpecialCollectionType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SpecialCollectionType), "ns2:SpecialCollectionType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__CollectionType::children), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", -1, &(a->ns2__CollectionType::parents), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", -1, &(a->ns2__CollectionType::annotations), ""))
		return soap->error;
	if (soap_out__ns2__union_SpecialCollectionType(soap, a->ns2__SpecialCollectionType::__union_SpecialCollectionType, &a->ns2__SpecialCollectionType::union_SpecialCollectionType))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__SpecialCollectionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SpecialCollectionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SpecialCollectionType * SOAP_FMAC4 soap_in_ns2__SpecialCollectionType(struct soap *soap, const char *tag, ns2__SpecialCollectionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SpecialCollectionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SpecialCollectionType, sizeof(ns2__SpecialCollectionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SpecialCollectionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SpecialCollectionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory3 = 1;
	size_t soap_flag_localUpdateTime3 = 1;
	size_t soap_flag_securityInfo3 = 1;
	size_t soap_flag_title3 = 1;
	size_t soap_flag_description3 = 1;
	size_t soap_flag_unit3 = 1;
	size_t soap_flag_extId3 = 1;
	size_t soap_flag_children2 = 1;
	size_t soap_flag_parents2 = 1;
	size_t soap_flag_annotations2 = 1;
	size_t soap_flag_union_SpecialCollectionType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory3--;
					continue;
				}
			if (soap_flag_localUpdateTime3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime3--;
					continue;
				}
			if (soap_flag_securityInfo3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo3--;
					continue;
				}
			if (soap_flag_title3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title3--;
					continue;
				}
			if (soap_flag_description3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description3--;
					continue;
				}
			if (soap_flag_unit3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit3--;
					continue;
				}
			if (soap_flag_extId3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_children2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__CollectionType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children2--;
					continue;
				}
			if (soap_flag_parents2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", &(a->ns2__CollectionType::parents), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_parents2--;
					continue;
				}
			if (soap_flag_annotations2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", &(a->ns2__CollectionType::annotations), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_annotations2--;
					continue;
				}
			if (soap_flag_union_SpecialCollectionType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_SpecialCollectionType(soap, &a->ns2__SpecialCollectionType::__union_SpecialCollectionType, &a->ns2__SpecialCollectionType::union_SpecialCollectionType))
				{	soap_flag_union_SpecialCollectionType1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SpecialCollectionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SpecialCollectionType, 0, sizeof(ns2__SpecialCollectionType), 0, soap_copy_ns2__SpecialCollectionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory3 > 0 || soap_flag_localUpdateTime3 > 0 || soap_flag_securityInfo3 > 0 || soap_flag_title3 > 0 || soap_flag_union_SpecialCollectionType1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SpecialCollectionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SpecialCollectionType);
	if (this->soap_out(soap, tag?tag:"ns2:SpecialCollectionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SpecialCollectionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SpecialCollectionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SpecialCollectionType * SOAP_FMAC4 soap_get_ns2__SpecialCollectionType(struct soap *soap, ns2__SpecialCollectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SpecialCollectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SpecialCollectionType * SOAP_FMAC2 soap_instantiate_ns2__SpecialCollectionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SpecialCollectionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SpecialCollectionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialCollectionType);
		if (size)
			*size = sizeof(ns2__SpecialCollectionType);
		((ns2__SpecialCollectionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialCollectionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SpecialCollectionType);
		for (int i = 0; i < n; i++)
			((ns2__SpecialCollectionType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SpecialCollectionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SpecialCollectionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SpecialCollectionType %p -> %p\n", q, p));
	*(ns2__SpecialCollectionType*)p = *(ns2__SpecialCollectionType*)q;
}

void ns2__SpecialCollectionUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__SpecialCollectionUserPropertiesType::__union_SpecialCollectionUserPropertiesType = 0;
	this->ns2__CollectionUserPropertiesType::children = NULL;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__SpecialCollectionUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_SpecialCollectionUserPropertiesType(soap, this->ns2__SpecialCollectionUserPropertiesType::__union_SpecialCollectionUserPropertiesType, &this->ns2__SpecialCollectionUserPropertiesType::union_SpecialCollectionUserPropertiesType);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__CollectionUserPropertiesType::children);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__SpecialCollectionUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SpecialCollectionUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SpecialCollectionUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__SpecialCollectionUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType), "ns2:SpecialCollectionUserPropertiesType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__CollectionUserPropertiesType::children), ""))
		return soap->error;
	if (soap_out__ns2__union_SpecialCollectionUserPropertiesType(soap, a->ns2__SpecialCollectionUserPropertiesType::__union_SpecialCollectionUserPropertiesType, &a->ns2__SpecialCollectionUserPropertiesType::union_SpecialCollectionUserPropertiesType))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__SpecialCollectionUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SpecialCollectionUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SpecialCollectionUserPropertiesType * SOAP_FMAC4 soap_in_ns2__SpecialCollectionUserPropertiesType(struct soap *soap, const char *tag, ns2__SpecialCollectionUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SpecialCollectionUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType, sizeof(ns2__SpecialCollectionUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SpecialCollectionUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo3 = 1;
	size_t soap_flag_title3 = 1;
	size_t soap_flag_description3 = 1;
	size_t soap_flag_unit3 = 1;
	size_t soap_flag_extId3 = 1;
	size_t soap_flag_children2 = 1;
	size_t soap_flag_union_SpecialCollectionUserPropertiesType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo3--;
					continue;
				}
			if (soap_flag_title3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title3--;
					continue;
				}
			if (soap_flag_description3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description3--;
					continue;
				}
			if (soap_flag_unit3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit3--;
					continue;
				}
			if (soap_flag_extId3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_children2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__CollectionUserPropertiesType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children2--;
					continue;
				}
			if (soap_flag_union_SpecialCollectionUserPropertiesType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_SpecialCollectionUserPropertiesType(soap, &a->ns2__SpecialCollectionUserPropertiesType::__union_SpecialCollectionUserPropertiesType, &a->ns2__SpecialCollectionUserPropertiesType::union_SpecialCollectionUserPropertiesType))
				{	soap_flag_union_SpecialCollectionUserPropertiesType1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SpecialCollectionUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType, 0, sizeof(ns2__SpecialCollectionUserPropertiesType), 0, soap_copy_ns2__SpecialCollectionUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo3 > 0 || soap_flag_title3 > 0 || soap_flag_union_SpecialCollectionUserPropertiesType1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SpecialCollectionUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:SpecialCollectionUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SpecialCollectionUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SpecialCollectionUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SpecialCollectionUserPropertiesType * SOAP_FMAC4 soap_get_ns2__SpecialCollectionUserPropertiesType(struct soap *soap, ns2__SpecialCollectionUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SpecialCollectionUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SpecialCollectionUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__SpecialCollectionUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SpecialCollectionUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialCollectionUserPropertiesType);
		if (size)
			*size = sizeof(ns2__SpecialCollectionUserPropertiesType);
		((ns2__SpecialCollectionUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialCollectionUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SpecialCollectionUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__SpecialCollectionUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SpecialCollectionUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SpecialCollectionUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SpecialCollectionUserPropertiesType %p -> %p\n", q, p));
	*(ns2__SpecialCollectionUserPropertiesType*)p = *(ns2__SpecialCollectionUserPropertiesType*)q;
}

void ns2__DetailedPlaceInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DetailedPlaceInfoType::OperationalStatus = NULL;
	this->ns2__DetailedPlaceInfoType::OperationalStatus2 = NULL;
	this->ns2__DetailedPlaceInfoType::OccupationStatus = NULL;
	this->ns2__DetailedPlaceInfoType::Construction = NULL;
	this->ns2__DetailedPlaceInfoType::UsageStatus = NULL;
	this->ns2__DetailedPlaceInfoType::EnemyActivityPresent = NULL;
	this->ns2__DetailedPlaceInfoType::SecurityStatus = NULL;
	this->ns2__DetailedPlaceInfoType::MinesPresent = NULL;
	this->ns2__DetailedPlaceInfoType::DemolitionScheduled = NULL;
	soap_default_std__string(soap, &this->ns2__DetailedPlaceInfoType::Height);
	soap_default_std__string(soap, &this->ns2__DetailedPlaceInfoType::Length);
	soap_default_std__string(soap, &this->ns2__DetailedPlaceInfoType::Width);
	soap_default_std__string(soap, &this->ns2__DetailedPlaceInfoType::Summary);
	/* transient soap skipped */
}

void ns2__DetailedPlaceInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__OperationalStatusType(soap, &this->ns2__DetailedPlaceInfoType::OperationalStatus);
	soap_serialize_PointerTons2__OperationalStatus2Type(soap, &this->ns2__DetailedPlaceInfoType::OperationalStatus2);
	soap_serialize_PointerTons2__OccupationStatusType(soap, &this->ns2__DetailedPlaceInfoType::OccupationStatus);
	soap_serialize_PointerTons2__ConstructionType(soap, &this->ns2__DetailedPlaceInfoType::Construction);
	soap_serialize_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(soap, &this->ns2__DetailedPlaceInfoType::UsageStatus);
	soap_serialize_PointerTons2__EnemyActivityPresentType(soap, &this->ns2__DetailedPlaceInfoType::EnemyActivityPresent);
	soap_serialize_PointerTons2__SecurityStatusType(soap, &this->ns2__DetailedPlaceInfoType::SecurityStatus);
	soap_serialize_PointerTons2__YesNoType(soap, &this->ns2__DetailedPlaceInfoType::MinesPresent);
	soap_serialize_PointerTons2__YesNoType(soap, &this->ns2__DetailedPlaceInfoType::DemolitionScheduled);
	soap_embedded(soap, &this->ns2__DetailedPlaceInfoType::Height, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__DetailedPlaceInfoType::Height);
	soap_embedded(soap, &this->ns2__DetailedPlaceInfoType::Length, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__DetailedPlaceInfoType::Length);
	soap_embedded(soap, &this->ns2__DetailedPlaceInfoType::Width, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__DetailedPlaceInfoType::Width);
	soap_embedded(soap, &this->ns2__DetailedPlaceInfoType::Summary, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__DetailedPlaceInfoType::Summary);
	/* transient soap skipped */
}

int ns2__DetailedPlaceInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DetailedPlaceInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DetailedPlaceInfoType(struct soap *soap, const char *tag, int id, const ns2__DetailedPlaceInfoType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DetailedPlaceInfoType), type))
		return soap->error;
	if (soap_out_PointerTons2__OperationalStatusType(soap, "ns2:OperationalStatus", -1, &(a->ns2__DetailedPlaceInfoType::OperationalStatus), ""))
		return soap->error;
	if (soap_out_PointerTons2__OperationalStatus2Type(soap, "ns2:OperationalStatus2", -1, &(a->ns2__DetailedPlaceInfoType::OperationalStatus2), ""))
		return soap->error;
	if (soap_out_PointerTons2__OccupationStatusType(soap, "ns2:OccupationStatus", -1, &(a->ns2__DetailedPlaceInfoType::OccupationStatus), ""))
		return soap->error;
	if (soap_out_PointerTons2__ConstructionType(soap, "ns2:Construction", -1, &(a->ns2__DetailedPlaceInfoType::Construction), ""))
		return soap->error;
	if (soap_out_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(soap, "ns2:UsageStatus", -1, &(a->ns2__DetailedPlaceInfoType::UsageStatus), ""))
		return soap->error;
	if (soap_out_PointerTons2__EnemyActivityPresentType(soap, "ns2:EnemyActivityPresent", -1, &(a->ns2__DetailedPlaceInfoType::EnemyActivityPresent), ""))
		return soap->error;
	if (soap_out_PointerTons2__SecurityStatusType(soap, "ns2:SecurityStatus", -1, &(a->ns2__DetailedPlaceInfoType::SecurityStatus), ""))
		return soap->error;
	if (soap_out_PointerTons2__YesNoType(soap, "ns2:MinesPresent", -1, &(a->ns2__DetailedPlaceInfoType::MinesPresent), ""))
		return soap->error;
	if (soap_out_PointerTons2__YesNoType(soap, "ns2:DemolitionScheduled", -1, &(a->ns2__DetailedPlaceInfoType::DemolitionScheduled), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Height", -1, &(a->ns2__DetailedPlaceInfoType::Height), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Length", -1, &(a->ns2__DetailedPlaceInfoType::Length), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Width", -1, &(a->ns2__DetailedPlaceInfoType::Width), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Summary", -1, &(a->ns2__DetailedPlaceInfoType::Summary), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DetailedPlaceInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DetailedPlaceInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DetailedPlaceInfoType * SOAP_FMAC4 soap_in_ns2__DetailedPlaceInfoType(struct soap *soap, const char *tag, ns2__DetailedPlaceInfoType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DetailedPlaceInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DetailedPlaceInfoType, sizeof(ns2__DetailedPlaceInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DetailedPlaceInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DetailedPlaceInfoType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_OperationalStatus1 = 1;
	size_t soap_flag_OperationalStatus21 = 1;
	size_t soap_flag_OccupationStatus1 = 1;
	size_t soap_flag_Construction1 = 1;
	size_t soap_flag_UsageStatus1 = 1;
	size_t soap_flag_EnemyActivityPresent1 = 1;
	size_t soap_flag_SecurityStatus1 = 1;
	size_t soap_flag_MinesPresent1 = 1;
	size_t soap_flag_DemolitionScheduled1 = 1;
	size_t soap_flag_Height1 = 1;
	size_t soap_flag_Length1 = 1;
	size_t soap_flag_Width1 = 1;
	size_t soap_flag_Summary1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OperationalStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OperationalStatusType(soap, "ns2:OperationalStatus", &(a->ns2__DetailedPlaceInfoType::OperationalStatus), "ns2:OperationalStatusType"))
				{	soap_flag_OperationalStatus1--;
					continue;
				}
			if (soap_flag_OperationalStatus21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OperationalStatus2Type(soap, "ns2:OperationalStatus2", &(a->ns2__DetailedPlaceInfoType::OperationalStatus2), "ns2:OperationalStatus2Type"))
				{	soap_flag_OperationalStatus21--;
					continue;
				}
			if (soap_flag_OccupationStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OccupationStatusType(soap, "ns2:OccupationStatus", &(a->ns2__DetailedPlaceInfoType::OccupationStatus), "ns2:OccupationStatusType"))
				{	soap_flag_OccupationStatus1--;
					continue;
				}
			if (soap_flag_Construction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ConstructionType(soap, "ns2:Construction", &(a->ns2__DetailedPlaceInfoType::Construction), "ns2:ConstructionType"))
				{	soap_flag_Construction1--;
					continue;
				}
			if (soap_flag_UsageStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(soap, "ns2:UsageStatus", &(a->ns2__DetailedPlaceInfoType::UsageStatus), "ns2:DetailedPlaceInfoType-UsageStatus"))
				{	soap_flag_UsageStatus1--;
					continue;
				}
			if (soap_flag_EnemyActivityPresent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EnemyActivityPresentType(soap, "ns2:EnemyActivityPresent", &(a->ns2__DetailedPlaceInfoType::EnemyActivityPresent), "ns2:EnemyActivityPresentType"))
				{	soap_flag_EnemyActivityPresent1--;
					continue;
				}
			if (soap_flag_SecurityStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SecurityStatusType(soap, "ns2:SecurityStatus", &(a->ns2__DetailedPlaceInfoType::SecurityStatus), "ns2:SecurityStatusType"))
				{	soap_flag_SecurityStatus1--;
					continue;
				}
			if (soap_flag_MinesPresent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__YesNoType(soap, "ns2:MinesPresent", &(a->ns2__DetailedPlaceInfoType::MinesPresent), "ns2:YesNoType"))
				{	soap_flag_MinesPresent1--;
					continue;
				}
			if (soap_flag_DemolitionScheduled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__YesNoType(soap, "ns2:DemolitionScheduled", &(a->ns2__DetailedPlaceInfoType::DemolitionScheduled), "ns2:YesNoType"))
				{	soap_flag_DemolitionScheduled1--;
					continue;
				}
			if (soap_flag_Height1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Height", &(a->ns2__DetailedPlaceInfoType::Height), "xsd:string"))
				{	soap_flag_Height1--;
					continue;
				}
			if (soap_flag_Length1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Length", &(a->ns2__DetailedPlaceInfoType::Length), "xsd:string"))
				{	soap_flag_Length1--;
					continue;
				}
			if (soap_flag_Width1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Width", &(a->ns2__DetailedPlaceInfoType::Width), "xsd:string"))
				{	soap_flag_Width1--;
					continue;
				}
			if (soap_flag_Summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Summary", &(a->ns2__DetailedPlaceInfoType::Summary), "xsd:string"))
				{	soap_flag_Summary1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DetailedPlaceInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DetailedPlaceInfoType, 0, sizeof(ns2__DetailedPlaceInfoType), 0, soap_copy_ns2__DetailedPlaceInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Height1 > 0 || soap_flag_Length1 > 0 || soap_flag_Width1 > 0 || soap_flag_Summary1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__DetailedPlaceInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DetailedPlaceInfoType);
	if (this->soap_out(soap, tag?tag:"ns2:DetailedPlaceInfoType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DetailedPlaceInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DetailedPlaceInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DetailedPlaceInfoType * SOAP_FMAC4 soap_get_ns2__DetailedPlaceInfoType(struct soap *soap, ns2__DetailedPlaceInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DetailedPlaceInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DetailedPlaceInfoType * SOAP_FMAC2 soap_instantiate_ns2__DetailedPlaceInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DetailedPlaceInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DetailedPlaceInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DetailedPlaceInfoType);
		if (size)
			*size = sizeof(ns2__DetailedPlaceInfoType);
		((ns2__DetailedPlaceInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__DetailedPlaceInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__DetailedPlaceInfoType);
		for (int i = 0; i < n; i++)
			((ns2__DetailedPlaceInfoType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__DetailedPlaceInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DetailedPlaceInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DetailedPlaceInfoType %p -> %p\n", q, p));
	*(ns2__DetailedPlaceInfoType*)p = *(ns2__DetailedPlaceInfoType*)q;
}

void ns2__SpecialPlaceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__SpecialPlaceType::__union_SpecialPlaceType = 0;
	this->ns2__PlaceType::categoryList = NULL;
	this->ns2__PlaceType::locationList = NULL;
	this->ns2__PlaceType::ns3__timePeriod = NULL;
	this->ns2__PlaceType::children = NULL;
	this->ns2__PlaceType::parents = NULL;
	this->ns2__PlaceType::annotations = NULL;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__SpecialPlaceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_SpecialPlaceType(soap, this->ns2__SpecialPlaceType::__union_SpecialPlaceType, &this->ns2__SpecialPlaceType::union_SpecialPlaceType);
	soap_serialize_PointerTons2__CategoryListType(soap, &this->ns2__PlaceType::categoryList);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__PlaceType::locationList);
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__PlaceType::ns3__timePeriod);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__PlaceType::children);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__PlaceType::parents);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__PlaceType::annotations);
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__SpecialPlaceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SpecialPlaceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SpecialPlaceType(struct soap *soap, const char *tag, int id, const ns2__SpecialPlaceType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SpecialPlaceType), "ns2:SpecialPlaceType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__CategoryListType(soap, "ns2:categoryList", -1, &(a->ns2__PlaceType::categoryList), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__PlaceType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__PlaceType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__PlaceType::children), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", -1, &(a->ns2__PlaceType::parents), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", -1, &(a->ns2__PlaceType::annotations), ""))
		return soap->error;
	if (soap_out__ns2__union_SpecialPlaceType(soap, a->ns2__SpecialPlaceType::__union_SpecialPlaceType, &a->ns2__SpecialPlaceType::union_SpecialPlaceType))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__SpecialPlaceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SpecialPlaceType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SpecialPlaceType * SOAP_FMAC4 soap_in_ns2__SpecialPlaceType(struct soap *soap, const char *tag, ns2__SpecialPlaceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SpecialPlaceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SpecialPlaceType, sizeof(ns2__SpecialPlaceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SpecialPlaceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SpecialPlaceType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory3 = 1;
	size_t soap_flag_localUpdateTime3 = 1;
	size_t soap_flag_securityInfo3 = 1;
	size_t soap_flag_title3 = 1;
	size_t soap_flag_description3 = 1;
	size_t soap_flag_unit3 = 1;
	size_t soap_flag_extId3 = 1;
	size_t soap_flag_categoryList2 = 1;
	size_t soap_flag_locationList2 = 1;
	size_t soap_flag_ns3__timePeriod2 = 1;
	size_t soap_flag_children2 = 1;
	size_t soap_flag_parents2 = 1;
	size_t soap_flag_annotations2 = 1;
	size_t soap_flag_union_SpecialPlaceType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory3--;
					continue;
				}
			if (soap_flag_localUpdateTime3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime3--;
					continue;
				}
			if (soap_flag_securityInfo3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo3--;
					continue;
				}
			if (soap_flag_title3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title3--;
					continue;
				}
			if (soap_flag_description3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description3--;
					continue;
				}
			if (soap_flag_unit3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit3--;
					continue;
				}
			if (soap_flag_extId3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_categoryList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CategoryListType(soap, "ns2:categoryList", &(a->ns2__PlaceType::categoryList), "ns2:CategoryListType"))
				{	soap_flag_categoryList2--;
					continue;
				}
			if (soap_flag_locationList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__PlaceType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList2--;
					continue;
				}
			if (soap_flag_ns3__timePeriod2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__PlaceType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod2--;
					continue;
				}
			if (soap_flag_children2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__PlaceType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children2--;
					continue;
				}
			if (soap_flag_parents2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", &(a->ns2__PlaceType::parents), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_parents2--;
					continue;
				}
			if (soap_flag_annotations2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", &(a->ns2__PlaceType::annotations), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_annotations2--;
					continue;
				}
			if (soap_flag_union_SpecialPlaceType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_SpecialPlaceType(soap, &a->ns2__SpecialPlaceType::__union_SpecialPlaceType, &a->ns2__SpecialPlaceType::union_SpecialPlaceType))
				{	soap_flag_union_SpecialPlaceType1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SpecialPlaceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SpecialPlaceType, 0, sizeof(ns2__SpecialPlaceType), 0, soap_copy_ns2__SpecialPlaceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory3 > 0 || soap_flag_localUpdateTime3 > 0 || soap_flag_securityInfo3 > 0 || soap_flag_title3 > 0 || soap_flag_categoryList2 > 0 || soap_flag_locationList2 > 0 || soap_flag_union_SpecialPlaceType1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SpecialPlaceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SpecialPlaceType);
	if (this->soap_out(soap, tag?tag:"ns2:SpecialPlaceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SpecialPlaceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SpecialPlaceType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SpecialPlaceType * SOAP_FMAC4 soap_get_ns2__SpecialPlaceType(struct soap *soap, ns2__SpecialPlaceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SpecialPlaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SpecialPlaceType * SOAP_FMAC2 soap_instantiate_ns2__SpecialPlaceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SpecialPlaceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SpecialPlaceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialPlaceType);
		if (size)
			*size = sizeof(ns2__SpecialPlaceType);
		((ns2__SpecialPlaceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialPlaceType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SpecialPlaceType);
		for (int i = 0; i < n; i++)
			((ns2__SpecialPlaceType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SpecialPlaceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SpecialPlaceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SpecialPlaceType %p -> %p\n", q, p));
	*(ns2__SpecialPlaceType*)p = *(ns2__SpecialPlaceType*)q;
}

void ns2__SpecialPlaceUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__SpecialPlaceUserPropertiesType::__union_SpecialPlaceUserPropertiesType = 0;
	this->ns2__PlaceUserPropertiesType::categoryList = NULL;
	this->ns2__PlaceUserPropertiesType::locationList = NULL;
	this->ns2__PlaceUserPropertiesType::ns3__timePeriod = NULL;
	this->ns2__PlaceUserPropertiesType::children = NULL;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__SpecialPlaceUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_SpecialPlaceUserPropertiesType(soap, this->ns2__SpecialPlaceUserPropertiesType::__union_SpecialPlaceUserPropertiesType, &this->ns2__SpecialPlaceUserPropertiesType::union_SpecialPlaceUserPropertiesType);
	soap_serialize_PointerTons2__CategoryListType(soap, &this->ns2__PlaceUserPropertiesType::categoryList);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__PlaceUserPropertiesType::locationList);
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__PlaceUserPropertiesType::ns3__timePeriod);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__PlaceUserPropertiesType::children);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__SpecialPlaceUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SpecialPlaceUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SpecialPlaceUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__SpecialPlaceUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType), "ns2:SpecialPlaceUserPropertiesType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__CategoryListType(soap, "ns2:categoryList", -1, &(a->ns2__PlaceUserPropertiesType::categoryList), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__PlaceUserPropertiesType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__PlaceUserPropertiesType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__PlaceUserPropertiesType::children), ""))
		return soap->error;
	if (soap_out__ns2__union_SpecialPlaceUserPropertiesType(soap, a->ns2__SpecialPlaceUserPropertiesType::__union_SpecialPlaceUserPropertiesType, &a->ns2__SpecialPlaceUserPropertiesType::union_SpecialPlaceUserPropertiesType))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__SpecialPlaceUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SpecialPlaceUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SpecialPlaceUserPropertiesType * SOAP_FMAC4 soap_in_ns2__SpecialPlaceUserPropertiesType(struct soap *soap, const char *tag, ns2__SpecialPlaceUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SpecialPlaceUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType, sizeof(ns2__SpecialPlaceUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SpecialPlaceUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo3 = 1;
	size_t soap_flag_title3 = 1;
	size_t soap_flag_description3 = 1;
	size_t soap_flag_unit3 = 1;
	size_t soap_flag_extId3 = 1;
	size_t soap_flag_categoryList2 = 1;
	size_t soap_flag_locationList2 = 1;
	size_t soap_flag_ns3__timePeriod2 = 1;
	size_t soap_flag_children2 = 1;
	size_t soap_flag_union_SpecialPlaceUserPropertiesType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo3--;
					continue;
				}
			if (soap_flag_title3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title3--;
					continue;
				}
			if (soap_flag_description3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description3--;
					continue;
				}
			if (soap_flag_unit3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit3--;
					continue;
				}
			if (soap_flag_extId3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_categoryList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CategoryListType(soap, "ns2:categoryList", &(a->ns2__PlaceUserPropertiesType::categoryList), "ns2:CategoryListType"))
				{	soap_flag_categoryList2--;
					continue;
				}
			if (soap_flag_locationList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__PlaceUserPropertiesType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList2--;
					continue;
				}
			if (soap_flag_ns3__timePeriod2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__PlaceUserPropertiesType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod2--;
					continue;
				}
			if (soap_flag_children2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__PlaceUserPropertiesType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children2--;
					continue;
				}
			if (soap_flag_union_SpecialPlaceUserPropertiesType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_SpecialPlaceUserPropertiesType(soap, &a->ns2__SpecialPlaceUserPropertiesType::__union_SpecialPlaceUserPropertiesType, &a->ns2__SpecialPlaceUserPropertiesType::union_SpecialPlaceUserPropertiesType))
				{	soap_flag_union_SpecialPlaceUserPropertiesType1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SpecialPlaceUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType, 0, sizeof(ns2__SpecialPlaceUserPropertiesType), 0, soap_copy_ns2__SpecialPlaceUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo3 > 0 || soap_flag_title3 > 0 || soap_flag_categoryList2 > 0 || soap_flag_locationList2 > 0 || soap_flag_union_SpecialPlaceUserPropertiesType1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SpecialPlaceUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:SpecialPlaceUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SpecialPlaceUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SpecialPlaceUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SpecialPlaceUserPropertiesType * SOAP_FMAC4 soap_get_ns2__SpecialPlaceUserPropertiesType(struct soap *soap, ns2__SpecialPlaceUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SpecialPlaceUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SpecialPlaceUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__SpecialPlaceUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SpecialPlaceUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialPlaceUserPropertiesType);
		if (size)
			*size = sizeof(ns2__SpecialPlaceUserPropertiesType);
		((ns2__SpecialPlaceUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialPlaceUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SpecialPlaceUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__SpecialPlaceUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SpecialPlaceUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SpecialPlaceUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SpecialPlaceUserPropertiesType %p -> %p\n", q, p));
	*(ns2__SpecialPlaceUserPropertiesType*)p = *(ns2__SpecialPlaceUserPropertiesType*)q;
}

void ns2__UpcomingEventType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__UpcomingEventType::Summary);
	soap_default_std__string(soap, &this->ns2__UpcomingEventType::Location);
	/* transient soap skipped */
}

void ns2__UpcomingEventType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__UpcomingEventType::Summary, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__UpcomingEventType::Summary);
	soap_embedded(soap, &this->ns2__UpcomingEventType::Location, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__UpcomingEventType::Location);
	/* transient soap skipped */
}

int ns2__UpcomingEventType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__UpcomingEventType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UpcomingEventType(struct soap *soap, const char *tag, int id, const ns2__UpcomingEventType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UpcomingEventType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Summary", -1, &(a->ns2__UpcomingEventType::Summary), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Location", -1, &(a->ns2__UpcomingEventType::Location), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__UpcomingEventType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__UpcomingEventType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__UpcomingEventType * SOAP_FMAC4 soap_in_ns2__UpcomingEventType(struct soap *soap, const char *tag, ns2__UpcomingEventType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__UpcomingEventType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UpcomingEventType, sizeof(ns2__UpcomingEventType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__UpcomingEventType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__UpcomingEventType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Summary1 = 1;
	size_t soap_flag_Location1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Summary", &(a->ns2__UpcomingEventType::Summary), "xsd:string"))
				{	soap_flag_Summary1--;
					continue;
				}
			if (soap_flag_Location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Location", &(a->ns2__UpcomingEventType::Location), "xsd:string"))
				{	soap_flag_Location1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__UpcomingEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UpcomingEventType, 0, sizeof(ns2__UpcomingEventType), 0, soap_copy_ns2__UpcomingEventType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Summary1 > 0 || soap_flag_Location1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__UpcomingEventType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__UpcomingEventType);
	if (this->soap_out(soap, tag?tag:"ns2:UpcomingEventType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__UpcomingEventType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__UpcomingEventType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__UpcomingEventType * SOAP_FMAC4 soap_get_ns2__UpcomingEventType(struct soap *soap, ns2__UpcomingEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UpcomingEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__UpcomingEventType * SOAP_FMAC2 soap_instantiate_ns2__UpcomingEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__UpcomingEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__UpcomingEventType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__UpcomingEventType);
		if (size)
			*size = sizeof(ns2__UpcomingEventType);
		((ns2__UpcomingEventType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__UpcomingEventType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__UpcomingEventType);
		for (int i = 0; i < n; i++)
			((ns2__UpcomingEventType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__UpcomingEventType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__UpcomingEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__UpcomingEventType %p -> %p\n", q, p));
	*(ns2__UpcomingEventType*)p = *(ns2__UpcomingEventType*)q;
}

void ns2__UpcomingEventsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__UpcomingEventsType::Next24Hours = NULL;
	this->ns2__UpcomingEventsType::Next48Hours = NULL;
	this->ns2__UpcomingEventsType::Next72Hours = NULL;
	soap_default_std__string(soap, &this->ns2__UpcomingEventsType::TagBox);
	/* transient soap skipped */
}

void ns2__UpcomingEventsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__UpcomingEventType(soap, &this->ns2__UpcomingEventsType::Next24Hours);
	soap_serialize_PointerTons2__UpcomingEventType(soap, &this->ns2__UpcomingEventsType::Next48Hours);
	soap_serialize_PointerTons2__UpcomingEventType(soap, &this->ns2__UpcomingEventsType::Next72Hours);
	soap_embedded(soap, &this->ns2__UpcomingEventsType::TagBox, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__UpcomingEventsType::TagBox);
	/* transient soap skipped */
}

int ns2__UpcomingEventsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__UpcomingEventsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UpcomingEventsType(struct soap *soap, const char *tag, int id, const ns2__UpcomingEventsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UpcomingEventsType), type))
		return soap->error;
	if (soap_out_PointerTons2__UpcomingEventType(soap, "ns2:Next24Hours", -1, &(a->ns2__UpcomingEventsType::Next24Hours), ""))
		return soap->error;
	if (soap_out_PointerTons2__UpcomingEventType(soap, "ns2:Next48Hours", -1, &(a->ns2__UpcomingEventsType::Next48Hours), ""))
		return soap->error;
	if (soap_out_PointerTons2__UpcomingEventType(soap, "ns2:Next72Hours", -1, &(a->ns2__UpcomingEventsType::Next72Hours), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:TagBox", -1, &(a->ns2__UpcomingEventsType::TagBox), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__UpcomingEventsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__UpcomingEventsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__UpcomingEventsType * SOAP_FMAC4 soap_in_ns2__UpcomingEventsType(struct soap *soap, const char *tag, ns2__UpcomingEventsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__UpcomingEventsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UpcomingEventsType, sizeof(ns2__UpcomingEventsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__UpcomingEventsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__UpcomingEventsType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Next24Hours1 = 1;
	size_t soap_flag_Next48Hours1 = 1;
	size_t soap_flag_Next72Hours1 = 1;
	size_t soap_flag_TagBox1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Next24Hours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UpcomingEventType(soap, "ns2:Next24Hours", &(a->ns2__UpcomingEventsType::Next24Hours), "ns2:UpcomingEventType"))
				{	soap_flag_Next24Hours1--;
					continue;
				}
			if (soap_flag_Next48Hours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UpcomingEventType(soap, "ns2:Next48Hours", &(a->ns2__UpcomingEventsType::Next48Hours), "ns2:UpcomingEventType"))
				{	soap_flag_Next48Hours1--;
					continue;
				}
			if (soap_flag_Next72Hours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UpcomingEventType(soap, "ns2:Next72Hours", &(a->ns2__UpcomingEventsType::Next72Hours), "ns2:UpcomingEventType"))
				{	soap_flag_Next72Hours1--;
					continue;
				}
			if (soap_flag_TagBox1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:TagBox", &(a->ns2__UpcomingEventsType::TagBox), "xsd:string"))
				{	soap_flag_TagBox1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__UpcomingEventsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UpcomingEventsType, 0, sizeof(ns2__UpcomingEventsType), 0, soap_copy_ns2__UpcomingEventsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Next24Hours1 > 0 || soap_flag_Next48Hours1 > 0 || soap_flag_Next72Hours1 > 0 || soap_flag_TagBox1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__UpcomingEventsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__UpcomingEventsType);
	if (this->soap_out(soap, tag?tag:"ns2:UpcomingEventsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__UpcomingEventsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__UpcomingEventsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__UpcomingEventsType * SOAP_FMAC4 soap_get_ns2__UpcomingEventsType(struct soap *soap, ns2__UpcomingEventsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UpcomingEventsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__UpcomingEventsType * SOAP_FMAC2 soap_instantiate_ns2__UpcomingEventsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__UpcomingEventsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__UpcomingEventsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__UpcomingEventsType);
		if (size)
			*size = sizeof(ns2__UpcomingEventsType);
		((ns2__UpcomingEventsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__UpcomingEventsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__UpcomingEventsType);
		for (int i = 0; i < n; i++)
			((ns2__UpcomingEventsType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__UpcomingEventsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__UpcomingEventsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__UpcomingEventsType %p -> %p\n", q, p));
	*(ns2__UpcomingEventsType*)p = *(ns2__UpcomingEventsType*)q;
}

void ns2__AssessmentsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__AssessmentsType::Commanders);
	soap_default_std__string(soap, &this->ns2__AssessmentsType::USAID);
	soap_default_std__string(soap, &this->ns2__AssessmentsType::USDA);
	soap_default_std__string(soap, &this->ns2__AssessmentsType::DOS);
	/* transient soap skipped */
}

void ns2__AssessmentsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__AssessmentsType::Commanders, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AssessmentsType::Commanders);
	soap_embedded(soap, &this->ns2__AssessmentsType::USAID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AssessmentsType::USAID);
	soap_embedded(soap, &this->ns2__AssessmentsType::USDA, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AssessmentsType::USDA);
	soap_embedded(soap, &this->ns2__AssessmentsType::DOS, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AssessmentsType::DOS);
	/* transient soap skipped */
}

int ns2__AssessmentsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AssessmentsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AssessmentsType(struct soap *soap, const char *tag, int id, const ns2__AssessmentsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AssessmentsType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Commanders", -1, &(a->ns2__AssessmentsType::Commanders), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:USAID", -1, &(a->ns2__AssessmentsType::USAID), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:USDA", -1, &(a->ns2__AssessmentsType::USDA), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:DOS", -1, &(a->ns2__AssessmentsType::DOS), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AssessmentsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AssessmentsType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AssessmentsType * SOAP_FMAC4 soap_in_ns2__AssessmentsType(struct soap *soap, const char *tag, ns2__AssessmentsType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AssessmentsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AssessmentsType, sizeof(ns2__AssessmentsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AssessmentsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AssessmentsType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Commanders1 = 1;
	size_t soap_flag_USAID1 = 1;
	size_t soap_flag_USDA1 = 1;
	size_t soap_flag_DOS1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Commanders1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Commanders", &(a->ns2__AssessmentsType::Commanders), "xsd:string"))
				{	soap_flag_Commanders1--;
					continue;
				}
			if (soap_flag_USAID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:USAID", &(a->ns2__AssessmentsType::USAID), "xsd:string"))
				{	soap_flag_USAID1--;
					continue;
				}
			if (soap_flag_USDA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:USDA", &(a->ns2__AssessmentsType::USDA), "xsd:string"))
				{	soap_flag_USDA1--;
					continue;
				}
			if (soap_flag_DOS1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:DOS", &(a->ns2__AssessmentsType::DOS), "xsd:string"))
				{	soap_flag_DOS1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AssessmentsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AssessmentsType, 0, sizeof(ns2__AssessmentsType), 0, soap_copy_ns2__AssessmentsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Commanders1 > 0 || soap_flag_USAID1 > 0 || soap_flag_USDA1 > 0 || soap_flag_DOS1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__AssessmentsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AssessmentsType);
	if (this->soap_out(soap, tag?tag:"ns2:AssessmentsType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AssessmentsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AssessmentsType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AssessmentsType * SOAP_FMAC4 soap_get_ns2__AssessmentsType(struct soap *soap, ns2__AssessmentsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AssessmentsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AssessmentsType * SOAP_FMAC2 soap_instantiate_ns2__AssessmentsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AssessmentsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AssessmentsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AssessmentsType);
		if (size)
			*size = sizeof(ns2__AssessmentsType);
		((ns2__AssessmentsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AssessmentsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AssessmentsType);
		for (int i = 0; i < n; i++)
			((ns2__AssessmentsType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AssessmentsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AssessmentsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AssessmentsType %p -> %p\n", q, p));
	*(ns2__AssessmentsType*)p = *(ns2__AssessmentsType*)q;
}

void ns2__PEMSIIOutcomeType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__ClassificationType(soap, &this->ns2__PEMSIIOutcomeType::Classification);
	soap_default_ns2__ReleasabilityType(soap, &this->ns2__PEMSIIOutcomeType::Releasability);
	soap_default_std__string(soap, &this->ns2__PEMSIIOutcomeType::Summary);
	soap_default_std__string(soap, &this->ns2__PEMSIIOutcomeType::IndividualsInvolved);
	soap_default_std__string(soap, &this->ns2__PEMSIIOutcomeType::MGRS);
	/* transient soap skipped */
}

void ns2__PEMSIIOutcomeType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__PEMSIIOutcomeType::Summary, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__PEMSIIOutcomeType::Summary);
	soap_embedded(soap, &this->ns2__PEMSIIOutcomeType::IndividualsInvolved, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__PEMSIIOutcomeType::IndividualsInvolved);
	soap_embedded(soap, &this->ns2__PEMSIIOutcomeType::MGRS, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__PEMSIIOutcomeType::MGRS);
	/* transient soap skipped */
}

int ns2__PEMSIIOutcomeType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PEMSIIOutcomeType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PEMSIIOutcomeType(struct soap *soap, const char *tag, int id, const ns2__PEMSIIOutcomeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PEMSIIOutcomeType), type))
		return soap->error;
	if (soap_out_ns2__ClassificationType(soap, "ns2:Classification", -1, &(a->ns2__PEMSIIOutcomeType::Classification), ""))
		return soap->error;
	if (soap_out_ns2__ReleasabilityType(soap, "ns2:Releasability", -1, &(a->ns2__PEMSIIOutcomeType::Releasability), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Summary", -1, &(a->ns2__PEMSIIOutcomeType::Summary), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:IndividualsInvolved", -1, &(a->ns2__PEMSIIOutcomeType::IndividualsInvolved), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:MGRS", -1, &(a->ns2__PEMSIIOutcomeType::MGRS), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__PEMSIIOutcomeType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PEMSIIOutcomeType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PEMSIIOutcomeType * SOAP_FMAC4 soap_in_ns2__PEMSIIOutcomeType(struct soap *soap, const char *tag, ns2__PEMSIIOutcomeType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PEMSIIOutcomeType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PEMSIIOutcomeType, sizeof(ns2__PEMSIIOutcomeType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__PEMSIIOutcomeType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__PEMSIIOutcomeType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Classification1 = 1;
	size_t soap_flag_Releasability1 = 1;
	size_t soap_flag_Summary1 = 1;
	size_t soap_flag_IndividualsInvolved1 = 1;
	size_t soap_flag_MGRS1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Classification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ClassificationType(soap, "ns2:Classification", &(a->ns2__PEMSIIOutcomeType::Classification), "ns2:ClassificationType"))
				{	soap_flag_Classification1--;
					continue;
				}
			if (soap_flag_Releasability1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ReleasabilityType(soap, "ns2:Releasability", &(a->ns2__PEMSIIOutcomeType::Releasability), "ns2:ReleasabilityType"))
				{	soap_flag_Releasability1--;
					continue;
				}
			if (soap_flag_Summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Summary", &(a->ns2__PEMSIIOutcomeType::Summary), "xsd:string"))
				{	soap_flag_Summary1--;
					continue;
				}
			if (soap_flag_IndividualsInvolved1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:IndividualsInvolved", &(a->ns2__PEMSIIOutcomeType::IndividualsInvolved), "xsd:string"))
				{	soap_flag_IndividualsInvolved1--;
					continue;
				}
			if (soap_flag_MGRS1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:MGRS", &(a->ns2__PEMSIIOutcomeType::MGRS), "xsd:string"))
				{	soap_flag_MGRS1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PEMSIIOutcomeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PEMSIIOutcomeType, 0, sizeof(ns2__PEMSIIOutcomeType), 0, soap_copy_ns2__PEMSIIOutcomeType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Classification1 > 0 || soap_flag_Releasability1 > 0 || soap_flag_Summary1 > 0 || soap_flag_IndividualsInvolved1 > 0 || soap_flag_MGRS1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__PEMSIIOutcomeType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__PEMSIIOutcomeType);
	if (this->soap_out(soap, tag?tag:"ns2:PEMSIIOutcomeType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PEMSIIOutcomeType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PEMSIIOutcomeType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PEMSIIOutcomeType * SOAP_FMAC4 soap_get_ns2__PEMSIIOutcomeType(struct soap *soap, ns2__PEMSIIOutcomeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PEMSIIOutcomeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__PEMSIIOutcomeType * SOAP_FMAC2 soap_instantiate_ns2__PEMSIIOutcomeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PEMSIIOutcomeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__PEMSIIOutcomeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__PEMSIIOutcomeType);
		if (size)
			*size = sizeof(ns2__PEMSIIOutcomeType);
		((ns2__PEMSIIOutcomeType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__PEMSIIOutcomeType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__PEMSIIOutcomeType);
		for (int i = 0; i < n; i++)
			((ns2__PEMSIIOutcomeType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__PEMSIIOutcomeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__PEMSIIOutcomeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__PEMSIIOutcomeType %p -> %p\n", q, p));
	*(ns2__PEMSIIOutcomeType*)p = *(ns2__PEMSIIOutcomeType*)q;
}

void ns2__PEMSIIOutcomesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PEMSIIOutcomesType::Political = NULL;
	this->ns2__PEMSIIOutcomesType::Military = NULL;
	this->ns2__PEMSIIOutcomesType::Economic = NULL;
	this->ns2__PEMSIIOutcomesType::Social = NULL;
	this->ns2__PEMSIIOutcomesType::Infrastructure = NULL;
	this->ns2__PEMSIIOutcomesType::Information = NULL;
	/* transient soap skipped */
}

void ns2__PEMSIIOutcomesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__PEMSIIOutcomeType(soap, &this->ns2__PEMSIIOutcomesType::Political);
	soap_serialize_PointerTons2__PEMSIIOutcomeType(soap, &this->ns2__PEMSIIOutcomesType::Military);
	soap_serialize_PointerTons2__PEMSIIOutcomeType(soap, &this->ns2__PEMSIIOutcomesType::Economic);
	soap_serialize_PointerTons2__PEMSIIOutcomeType(soap, &this->ns2__PEMSIIOutcomesType::Social);
	soap_serialize_PointerTons2__PEMSIIOutcomeType(soap, &this->ns2__PEMSIIOutcomesType::Infrastructure);
	soap_serialize_PointerTons2__PEMSIIOutcomeType(soap, &this->ns2__PEMSIIOutcomesType::Information);
	/* transient soap skipped */
}

int ns2__PEMSIIOutcomesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PEMSIIOutcomesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PEMSIIOutcomesType(struct soap *soap, const char *tag, int id, const ns2__PEMSIIOutcomesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PEMSIIOutcomesType), type))
		return soap->error;
	if (soap_out_PointerTons2__PEMSIIOutcomeType(soap, "ns2:Political", -1, &(a->ns2__PEMSIIOutcomesType::Political), ""))
		return soap->error;
	if (soap_out_PointerTons2__PEMSIIOutcomeType(soap, "ns2:Military", -1, &(a->ns2__PEMSIIOutcomesType::Military), ""))
		return soap->error;
	if (soap_out_PointerTons2__PEMSIIOutcomeType(soap, "ns2:Economic", -1, &(a->ns2__PEMSIIOutcomesType::Economic), ""))
		return soap->error;
	if (soap_out_PointerTons2__PEMSIIOutcomeType(soap, "ns2:Social", -1, &(a->ns2__PEMSIIOutcomesType::Social), ""))
		return soap->error;
	if (soap_out_PointerTons2__PEMSIIOutcomeType(soap, "ns2:Infrastructure", -1, &(a->ns2__PEMSIIOutcomesType::Infrastructure), ""))
		return soap->error;
	if (soap_out_PointerTons2__PEMSIIOutcomeType(soap, "ns2:Information", -1, &(a->ns2__PEMSIIOutcomesType::Information), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__PEMSIIOutcomesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PEMSIIOutcomesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PEMSIIOutcomesType * SOAP_FMAC4 soap_in_ns2__PEMSIIOutcomesType(struct soap *soap, const char *tag, ns2__PEMSIIOutcomesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PEMSIIOutcomesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PEMSIIOutcomesType, sizeof(ns2__PEMSIIOutcomesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__PEMSIIOutcomesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__PEMSIIOutcomesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Political1 = 1;
	size_t soap_flag_Military1 = 1;
	size_t soap_flag_Economic1 = 1;
	size_t soap_flag_Social1 = 1;
	size_t soap_flag_Infrastructure1 = 1;
	size_t soap_flag_Information1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Political1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PEMSIIOutcomeType(soap, "ns2:Political", &(a->ns2__PEMSIIOutcomesType::Political), "ns2:PEMSIIOutcomeType"))
				{	soap_flag_Political1--;
					continue;
				}
			if (soap_flag_Military1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PEMSIIOutcomeType(soap, "ns2:Military", &(a->ns2__PEMSIIOutcomesType::Military), "ns2:PEMSIIOutcomeType"))
				{	soap_flag_Military1--;
					continue;
				}
			if (soap_flag_Economic1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PEMSIIOutcomeType(soap, "ns2:Economic", &(a->ns2__PEMSIIOutcomesType::Economic), "ns2:PEMSIIOutcomeType"))
				{	soap_flag_Economic1--;
					continue;
				}
			if (soap_flag_Social1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PEMSIIOutcomeType(soap, "ns2:Social", &(a->ns2__PEMSIIOutcomesType::Social), "ns2:PEMSIIOutcomeType"))
				{	soap_flag_Social1--;
					continue;
				}
			if (soap_flag_Infrastructure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PEMSIIOutcomeType(soap, "ns2:Infrastructure", &(a->ns2__PEMSIIOutcomesType::Infrastructure), "ns2:PEMSIIOutcomeType"))
				{	soap_flag_Infrastructure1--;
					continue;
				}
			if (soap_flag_Information1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PEMSIIOutcomeType(soap, "ns2:Information", &(a->ns2__PEMSIIOutcomesType::Information), "ns2:PEMSIIOutcomeType"))
				{	soap_flag_Information1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PEMSIIOutcomesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PEMSIIOutcomesType, 0, sizeof(ns2__PEMSIIOutcomesType), 0, soap_copy_ns2__PEMSIIOutcomesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Political1 > 0 || soap_flag_Military1 > 0 || soap_flag_Economic1 > 0 || soap_flag_Social1 > 0 || soap_flag_Infrastructure1 > 0 || soap_flag_Information1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__PEMSIIOutcomesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__PEMSIIOutcomesType);
	if (this->soap_out(soap, tag?tag:"ns2:PEMSIIOutcomesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PEMSIIOutcomesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PEMSIIOutcomesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PEMSIIOutcomesType * SOAP_FMAC4 soap_get_ns2__PEMSIIOutcomesType(struct soap *soap, ns2__PEMSIIOutcomesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PEMSIIOutcomesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__PEMSIIOutcomesType * SOAP_FMAC2 soap_instantiate_ns2__PEMSIIOutcomesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PEMSIIOutcomesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__PEMSIIOutcomesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__PEMSIIOutcomesType);
		if (size)
			*size = sizeof(ns2__PEMSIIOutcomesType);
		((ns2__PEMSIIOutcomesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__PEMSIIOutcomesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__PEMSIIOutcomesType);
		for (int i = 0; i < n; i++)
			((ns2__PEMSIIOutcomesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__PEMSIIOutcomesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__PEMSIIOutcomesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__PEMSIIOutcomesType %p -> %p\n", q, p));
	*(ns2__PEMSIIOutcomesType*)p = *(ns2__PEMSIIOutcomesType*)q;
}

void ns2__CIDNE_USCORECMODailyReportType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__ClassificationType(soap, &this->ns2__CIDNE_USCORECMODailyReportType::Classification);
	soap_default_ns2__ReleasabilityType(soap, &this->ns2__CIDNE_USCORECMODailyReportType::Releasability);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCORECMODailyReportType::TrackingNumber);
	soap_default_ns2__MissionType(soap, &this->ns2__CIDNE_USCORECMODailyReportType::Mission);
	soap_default_ns2__LineOfOperationType(soap, &this->ns2__CIDNE_USCORECMODailyReportType::LineOfOperation);
	soap_default_std__vectorTemplateOfns2__MinistryType(soap, &this->ns2__CIDNE_USCORECMODailyReportType::AffectedMinistry);
	this->ns2__CIDNE_USCORECMODailyReportType::PEMSIIOutcomes = NULL;
	this->ns2__CIDNE_USCORECMODailyReportType::Assessments = NULL;
	this->ns2__CIDNE_USCORECMODailyReportType::UpcomingEvents = NULL;
	/* transient soap skipped */
}

void ns2__CIDNE_USCORECMODailyReportType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__CIDNE_USCORECMODailyReportType::TrackingNumber, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCORECMODailyReportType::TrackingNumber);
	soap_serialize_std__vectorTemplateOfns2__MinistryType(soap, &this->ns2__CIDNE_USCORECMODailyReportType::AffectedMinistry);
	soap_serialize_PointerTons2__PEMSIIOutcomesType(soap, &this->ns2__CIDNE_USCORECMODailyReportType::PEMSIIOutcomes);
	soap_serialize_PointerTons2__AssessmentsType(soap, &this->ns2__CIDNE_USCORECMODailyReportType::Assessments);
	soap_serialize_PointerTons2__UpcomingEventsType(soap, &this->ns2__CIDNE_USCORECMODailyReportType::UpcomingEvents);
	/* transient soap skipped */
}

int ns2__CIDNE_USCORECMODailyReportType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CIDNE_USCORECMODailyReportType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CIDNE_USCORECMODailyReportType(struct soap *soap, const char *tag, int id, const ns2__CIDNE_USCORECMODailyReportType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType), type))
		return soap->error;
	if (soap_out_ns2__ClassificationType(soap, "ns2:Classification", -1, &(a->ns2__CIDNE_USCORECMODailyReportType::Classification), ""))
		return soap->error;
	if (soap_out_ns2__ReleasabilityType(soap, "ns2:Releasability", -1, &(a->ns2__CIDNE_USCORECMODailyReportType::Releasability), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:TrackingNumber", -1, &(a->ns2__CIDNE_USCORECMODailyReportType::TrackingNumber), ""))
		return soap->error;
	if (soap_out_ns2__MissionType(soap, "ns2:Mission", -1, &(a->ns2__CIDNE_USCORECMODailyReportType::Mission), ""))
		return soap->error;
	if (soap_out_ns2__LineOfOperationType(soap, "ns2:LineOfOperation", -1, &(a->ns2__CIDNE_USCORECMODailyReportType::LineOfOperation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns2__MinistryType(soap, "ns2:AffectedMinistry", -1, &(a->ns2__CIDNE_USCORECMODailyReportType::AffectedMinistry), ""))
		return soap->error;
	if (soap_out_PointerTons2__PEMSIIOutcomesType(soap, "ns2:PEMSIIOutcomes", -1, &(a->ns2__CIDNE_USCORECMODailyReportType::PEMSIIOutcomes), ""))
		return soap->error;
	if (soap_out_PointerTons2__AssessmentsType(soap, "ns2:Assessments", -1, &(a->ns2__CIDNE_USCORECMODailyReportType::Assessments), ""))
		return soap->error;
	if (soap_out_PointerTons2__UpcomingEventsType(soap, "ns2:UpcomingEvents", -1, &(a->ns2__CIDNE_USCORECMODailyReportType::UpcomingEvents), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CIDNE_USCORECMODailyReportType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CIDNE_USCORECMODailyReportType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CIDNE_USCORECMODailyReportType * SOAP_FMAC4 soap_in_ns2__CIDNE_USCORECMODailyReportType(struct soap *soap, const char *tag, ns2__CIDNE_USCORECMODailyReportType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CIDNE_USCORECMODailyReportType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType, sizeof(ns2__CIDNE_USCORECMODailyReportType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CIDNE_USCORECMODailyReportType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Classification1 = 1;
	size_t soap_flag_Releasability1 = 1;
	size_t soap_flag_TrackingNumber1 = 1;
	size_t soap_flag_Mission1 = 1;
	size_t soap_flag_LineOfOperation1 = 1;
	size_t soap_flag_PEMSIIOutcomes1 = 1;
	size_t soap_flag_Assessments1 = 1;
	size_t soap_flag_UpcomingEvents1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Classification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ClassificationType(soap, "ns2:Classification", &(a->ns2__CIDNE_USCORECMODailyReportType::Classification), "ns2:ClassificationType"))
				{	soap_flag_Classification1--;
					continue;
				}
			if (soap_flag_Releasability1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ReleasabilityType(soap, "ns2:Releasability", &(a->ns2__CIDNE_USCORECMODailyReportType::Releasability), "ns2:ReleasabilityType"))
				{	soap_flag_Releasability1--;
					continue;
				}
			if (soap_flag_TrackingNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:TrackingNumber", &(a->ns2__CIDNE_USCORECMODailyReportType::TrackingNumber), "xsd:string"))
				{	soap_flag_TrackingNumber1--;
					continue;
				}
			if (soap_flag_Mission1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__MissionType(soap, "ns2:Mission", &(a->ns2__CIDNE_USCORECMODailyReportType::Mission), "ns2:MissionType"))
				{	soap_flag_Mission1--;
					continue;
				}
			if (soap_flag_LineOfOperation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__LineOfOperationType(soap, "ns2:LineOfOperation", &(a->ns2__CIDNE_USCORECMODailyReportType::LineOfOperation), "ns2:LineOfOperationType"))
				{	soap_flag_LineOfOperation1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns2__MinistryType(soap, "ns2:AffectedMinistry", &(a->ns2__CIDNE_USCORECMODailyReportType::AffectedMinistry), "ns2:MinistryType"))
					continue;
			if (soap_flag_PEMSIIOutcomes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PEMSIIOutcomesType(soap, "ns2:PEMSIIOutcomes", &(a->ns2__CIDNE_USCORECMODailyReportType::PEMSIIOutcomes), "ns2:PEMSIIOutcomesType"))
				{	soap_flag_PEMSIIOutcomes1--;
					continue;
				}
			if (soap_flag_Assessments1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AssessmentsType(soap, "ns2:Assessments", &(a->ns2__CIDNE_USCORECMODailyReportType::Assessments), "ns2:AssessmentsType"))
				{	soap_flag_Assessments1--;
					continue;
				}
			if (soap_flag_UpcomingEvents1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UpcomingEventsType(soap, "ns2:UpcomingEvents", &(a->ns2__CIDNE_USCORECMODailyReportType::UpcomingEvents), "ns2:UpcomingEventsType"))
				{	soap_flag_UpcomingEvents1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CIDNE_USCORECMODailyReportType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType, 0, sizeof(ns2__CIDNE_USCORECMODailyReportType), 0, soap_copy_ns2__CIDNE_USCORECMODailyReportType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Classification1 > 0 || soap_flag_Releasability1 > 0 || soap_flag_TrackingNumber1 > 0 || soap_flag_Mission1 > 0 || soap_flag_LineOfOperation1 > 0 || soap_flag_PEMSIIOutcomes1 > 0 || soap_flag_Assessments1 > 0 || soap_flag_UpcomingEvents1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__CIDNE_USCORECMODailyReportType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType);
	if (this->soap_out(soap, tag?tag:"ns2:CIDNE_CMODailyReportType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CIDNE_USCORECMODailyReportType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CIDNE_USCORECMODailyReportType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CIDNE_USCORECMODailyReportType * SOAP_FMAC4 soap_get_ns2__CIDNE_USCORECMODailyReportType(struct soap *soap, ns2__CIDNE_USCORECMODailyReportType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CIDNE_USCORECMODailyReportType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CIDNE_USCORECMODailyReportType * SOAP_FMAC2 soap_instantiate_ns2__CIDNE_USCORECMODailyReportType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CIDNE_USCORECMODailyReportType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CIDNE_USCORECMODailyReportType);
		if (size)
			*size = sizeof(ns2__CIDNE_USCORECMODailyReportType);
		((ns2__CIDNE_USCORECMODailyReportType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CIDNE_USCORECMODailyReportType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CIDNE_USCORECMODailyReportType);
		for (int i = 0; i < n; i++)
			((ns2__CIDNE_USCORECMODailyReportType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CIDNE_USCORECMODailyReportType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CIDNE_USCORECMODailyReportType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CIDNE_USCORECMODailyReportType %p -> %p\n", q, p));
	*(ns2__CIDNE_USCORECMODailyReportType*)p = *(ns2__CIDNE_USCORECMODailyReportType*)q;
}

void ns2__HTSAreaAssessmentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__ClassificationType(soap, &this->ns2__HTSAreaAssessmentType::Classification);
	soap_default_ns2__ReleasabilityType(soap, &this->ns2__HTSAreaAssessmentType::Releasibility);
	soap_default_ns2__JustificationType(soap, &this->ns2__HTSAreaAssessmentType::Justification);
	this->ns2__HTSAreaAssessmentType::Country = NULL;
	this->ns2__HTSAreaAssessmentType::Province = NULL;
	soap_default_std__string(soap, &this->ns2__HTSAreaAssessmentType::TrackingNumber);
	soap_default_ns2__ProductType(soap, &this->ns2__HTSAreaAssessmentType::ProductType);
	soap_default_std__vectorTemplateOfns2__DataCollectionMethodType(soap, &this->ns2__HTSAreaAssessmentType::DataCollectionMethod);
	soap_default_std__vectorTemplateOfns2__AnalyticalToolMethodType(soap, &this->ns2__HTSAreaAssessmentType::AnalyticalToolMethod);
	soap_default_std__vectorTemplateOfns2__KeywordType(soap, &this->ns2__HTSAreaAssessmentType::Keyword);
	soap_default_std__string(soap, &this->ns2__HTSAreaAssessmentType::Summary);
	/* transient soap skipped */
}

void ns2__HTSAreaAssessmentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__HTSAreaAssessmentType::Country);
	soap_serialize_PointerTostd__string(soap, &this->ns2__HTSAreaAssessmentType::Province);
	soap_embedded(soap, &this->ns2__HTSAreaAssessmentType::TrackingNumber, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__HTSAreaAssessmentType::TrackingNumber);
	soap_serialize_std__vectorTemplateOfns2__DataCollectionMethodType(soap, &this->ns2__HTSAreaAssessmentType::DataCollectionMethod);
	soap_serialize_std__vectorTemplateOfns2__AnalyticalToolMethodType(soap, &this->ns2__HTSAreaAssessmentType::AnalyticalToolMethod);
	soap_serialize_std__vectorTemplateOfns2__KeywordType(soap, &this->ns2__HTSAreaAssessmentType::Keyword);
	soap_embedded(soap, &this->ns2__HTSAreaAssessmentType::Summary, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__HTSAreaAssessmentType::Summary);
	/* transient soap skipped */
}

int ns2__HTSAreaAssessmentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HTSAreaAssessmentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HTSAreaAssessmentType(struct soap *soap, const char *tag, int id, const ns2__HTSAreaAssessmentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HTSAreaAssessmentType), type))
		return soap->error;
	if (soap_out_ns2__ClassificationType(soap, "ns2:Classification", -1, &(a->ns2__HTSAreaAssessmentType::Classification), ""))
		return soap->error;
	if (soap_out_ns2__ReleasabilityType(soap, "ns2:Releasibility", -1, &(a->ns2__HTSAreaAssessmentType::Releasibility), ""))
		return soap->error;
	if (soap_out_ns2__JustificationType(soap, "ns2:Justification", -1, &(a->ns2__HTSAreaAssessmentType::Justification), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Country", -1, &(a->ns2__HTSAreaAssessmentType::Country), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Province", -1, &(a->ns2__HTSAreaAssessmentType::Province), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:TrackingNumber", -1, &(a->ns2__HTSAreaAssessmentType::TrackingNumber), ""))
		return soap->error;
	if (soap_out_ns2__ProductType(soap, "ns2:ProductType", -1, &(a->ns2__HTSAreaAssessmentType::ProductType), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns2__DataCollectionMethodType(soap, "ns2:DataCollectionMethod", -1, &(a->ns2__HTSAreaAssessmentType::DataCollectionMethod), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns2__AnalyticalToolMethodType(soap, "ns2:AnalyticalToolMethod", -1, &(a->ns2__HTSAreaAssessmentType::AnalyticalToolMethod), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns2__KeywordType(soap, "ns2:Keyword", -1, &(a->ns2__HTSAreaAssessmentType::Keyword), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Summary", -1, &(a->ns2__HTSAreaAssessmentType::Summary), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__HTSAreaAssessmentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HTSAreaAssessmentType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HTSAreaAssessmentType * SOAP_FMAC4 soap_in_ns2__HTSAreaAssessmentType(struct soap *soap, const char *tag, ns2__HTSAreaAssessmentType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HTSAreaAssessmentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HTSAreaAssessmentType, sizeof(ns2__HTSAreaAssessmentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__HTSAreaAssessmentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__HTSAreaAssessmentType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Classification1 = 1;
	size_t soap_flag_Releasibility1 = 1;
	size_t soap_flag_Justification1 = 1;
	size_t soap_flag_Country1 = 1;
	size_t soap_flag_Province1 = 1;
	size_t soap_flag_TrackingNumber1 = 1;
	size_t soap_flag_ProductType1 = 1;
	size_t soap_flag_Summary1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Classification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ClassificationType(soap, "ns2:Classification", &(a->ns2__HTSAreaAssessmentType::Classification), "ns2:ClassificationType"))
				{	soap_flag_Classification1--;
					continue;
				}
			if (soap_flag_Releasibility1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ReleasabilityType(soap, "ns2:Releasibility", &(a->ns2__HTSAreaAssessmentType::Releasibility), "ns2:ReleasabilityType"))
				{	soap_flag_Releasibility1--;
					continue;
				}
			if (soap_flag_Justification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__JustificationType(soap, "ns2:Justification", &(a->ns2__HTSAreaAssessmentType::Justification), "ns2:JustificationType"))
				{	soap_flag_Justification1--;
					continue;
				}
			if (soap_flag_Country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Country", &(a->ns2__HTSAreaAssessmentType::Country), "xsd:string"))
				{	soap_flag_Country1--;
					continue;
				}
			if (soap_flag_Province1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Province", &(a->ns2__HTSAreaAssessmentType::Province), "xsd:string"))
				{	soap_flag_Province1--;
					continue;
				}
			if (soap_flag_TrackingNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:TrackingNumber", &(a->ns2__HTSAreaAssessmentType::TrackingNumber), "xsd:string"))
				{	soap_flag_TrackingNumber1--;
					continue;
				}
			if (soap_flag_ProductType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ProductType(soap, "ns2:ProductType", &(a->ns2__HTSAreaAssessmentType::ProductType), "ns2:ProductType"))
				{	soap_flag_ProductType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns2__DataCollectionMethodType(soap, "ns2:DataCollectionMethod", &(a->ns2__HTSAreaAssessmentType::DataCollectionMethod), "ns2:DataCollectionMethodType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns2__AnalyticalToolMethodType(soap, "ns2:AnalyticalToolMethod", &(a->ns2__HTSAreaAssessmentType::AnalyticalToolMethod), "ns2:AnalyticalToolMethodType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns2__KeywordType(soap, "ns2:Keyword", &(a->ns2__HTSAreaAssessmentType::Keyword), "ns2:KeywordType"))
					continue;
			if (soap_flag_Summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Summary", &(a->ns2__HTSAreaAssessmentType::Summary), "xsd:string"))
				{	soap_flag_Summary1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HTSAreaAssessmentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HTSAreaAssessmentType, 0, sizeof(ns2__HTSAreaAssessmentType), 0, soap_copy_ns2__HTSAreaAssessmentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Classification1 > 0 || soap_flag_Releasibility1 > 0 || soap_flag_Justification1 > 0 || soap_flag_TrackingNumber1 > 0 || soap_flag_ProductType1 > 0 || soap_flag_Summary1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__HTSAreaAssessmentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__HTSAreaAssessmentType);
	if (this->soap_out(soap, tag?tag:"ns2:HTSAreaAssessmentType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HTSAreaAssessmentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HTSAreaAssessmentType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HTSAreaAssessmentType * SOAP_FMAC4 soap_get_ns2__HTSAreaAssessmentType(struct soap *soap, ns2__HTSAreaAssessmentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HTSAreaAssessmentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__HTSAreaAssessmentType * SOAP_FMAC2 soap_instantiate_ns2__HTSAreaAssessmentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HTSAreaAssessmentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__HTSAreaAssessmentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__HTSAreaAssessmentType);
		if (size)
			*size = sizeof(ns2__HTSAreaAssessmentType);
		((ns2__HTSAreaAssessmentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__HTSAreaAssessmentType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__HTSAreaAssessmentType);
		for (int i = 0; i < n; i++)
			((ns2__HTSAreaAssessmentType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__HTSAreaAssessmentType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__HTSAreaAssessmentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__HTSAreaAssessmentType %p -> %p\n", q, p));
	*(ns2__HTSAreaAssessmentType*)p = *(ns2__HTSAreaAssessmentType*)q;
}

void ns2__RemarkType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__RemarkType::Type);
	soap_default_ns2__ClassificationType(soap, &this->ns2__RemarkType::Classification);
	soap_default_ns2__ReleasabilityType(soap, &this->ns2__RemarkType::Releasibility);
	soap_default_std__string(soap, &this->ns2__RemarkType::Date);
	soap_default_std__string(soap, &this->ns2__RemarkType::Description);
	/* transient soap skipped */
}

void ns2__RemarkType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__RemarkType::Type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__RemarkType::Type);
	soap_embedded(soap, &this->ns2__RemarkType::Date, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__RemarkType::Date);
	soap_embedded(soap, &this->ns2__RemarkType::Description, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__RemarkType::Description);
	/* transient soap skipped */
}

int ns2__RemarkType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RemarkType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RemarkType(struct soap *soap, const char *tag, int id, const ns2__RemarkType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RemarkType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Type", -1, &(a->ns2__RemarkType::Type), ""))
		return soap->error;
	if (soap_out_ns2__ClassificationType(soap, "ns2:Classification", -1, &(a->ns2__RemarkType::Classification), ""))
		return soap->error;
	if (soap_out_ns2__ReleasabilityType(soap, "ns2:Releasibility", -1, &(a->ns2__RemarkType::Releasibility), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Date", -1, &(a->ns2__RemarkType::Date), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Description", -1, &(a->ns2__RemarkType::Description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RemarkType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RemarkType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RemarkType * SOAP_FMAC4 soap_in_ns2__RemarkType(struct soap *soap, const char *tag, ns2__RemarkType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RemarkType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RemarkType, sizeof(ns2__RemarkType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RemarkType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RemarkType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Classification1 = 1;
	size_t soap_flag_Releasibility1 = 1;
	size_t soap_flag_Date1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Type", &(a->ns2__RemarkType::Type), "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap_flag_Classification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ClassificationType(soap, "ns2:Classification", &(a->ns2__RemarkType::Classification), "ns2:ClassificationType"))
				{	soap_flag_Classification1--;
					continue;
				}
			if (soap_flag_Releasibility1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ReleasabilityType(soap, "ns2:Releasibility", &(a->ns2__RemarkType::Releasibility), "ns2:ReleasabilityType"))
				{	soap_flag_Releasibility1--;
					continue;
				}
			if (soap_flag_Date1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Date", &(a->ns2__RemarkType::Date), "xsd:string"))
				{	soap_flag_Date1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Description", &(a->ns2__RemarkType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RemarkType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RemarkType, 0, sizeof(ns2__RemarkType), 0, soap_copy_ns2__RemarkType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0 || soap_flag_Classification1 > 0 || soap_flag_Releasibility1 > 0 || soap_flag_Date1 > 0 || soap_flag_Description1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RemarkType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RemarkType);
	if (this->soap_out(soap, tag?tag:"ns2:RemarkType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RemarkType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RemarkType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RemarkType * SOAP_FMAC4 soap_get_ns2__RemarkType(struct soap *soap, ns2__RemarkType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RemarkType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RemarkType * SOAP_FMAC2 soap_instantiate_ns2__RemarkType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RemarkType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RemarkType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RemarkType);
		if (size)
			*size = sizeof(ns2__RemarkType);
		((ns2__RemarkType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__RemarkType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__RemarkType);
		for (int i = 0; i < n; i++)
			((ns2__RemarkType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__RemarkType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RemarkType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RemarkType %p -> %p\n", q, p));
	*(ns2__RemarkType*)p = *(ns2__RemarkType*)q;
}

void ns2__LocationInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__LocationInfoType::StartDate);
	soap_default_std__string(soap, &this->ns2__LocationInfoType::EndDate);
	soap_default_std__string(soap, &this->ns2__LocationInfoType::Latitude);
	soap_default_std__string(soap, &this->ns2__LocationInfoType::Longitude);
	/* transient soap skipped */
}

void ns2__LocationInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__LocationInfoType::StartDate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__LocationInfoType::StartDate);
	soap_embedded(soap, &this->ns2__LocationInfoType::EndDate, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__LocationInfoType::EndDate);
	soap_embedded(soap, &this->ns2__LocationInfoType::Latitude, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__LocationInfoType::Latitude);
	soap_embedded(soap, &this->ns2__LocationInfoType::Longitude, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__LocationInfoType::Longitude);
	/* transient soap skipped */
}

int ns2__LocationInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LocationInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LocationInfoType(struct soap *soap, const char *tag, int id, const ns2__LocationInfoType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LocationInfoType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:StartDate", -1, &(a->ns2__LocationInfoType::StartDate), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:EndDate", -1, &(a->ns2__LocationInfoType::EndDate), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Latitude", -1, &(a->ns2__LocationInfoType::Latitude), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Longitude", -1, &(a->ns2__LocationInfoType::Longitude), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__LocationInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LocationInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LocationInfoType * SOAP_FMAC4 soap_in_ns2__LocationInfoType(struct soap *soap, const char *tag, ns2__LocationInfoType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LocationInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LocationInfoType, sizeof(ns2__LocationInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__LocationInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__LocationInfoType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_StartDate1 = 1;
	size_t soap_flag_EndDate1 = 1;
	size_t soap_flag_Latitude1 = 1;
	size_t soap_flag_Longitude1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:StartDate", &(a->ns2__LocationInfoType::StartDate), "xsd:string"))
				{	soap_flag_StartDate1--;
					continue;
				}
			if (soap_flag_EndDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:EndDate", &(a->ns2__LocationInfoType::EndDate), "xsd:string"))
				{	soap_flag_EndDate1--;
					continue;
				}
			if (soap_flag_Latitude1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Latitude", &(a->ns2__LocationInfoType::Latitude), "xsd:string"))
				{	soap_flag_Latitude1--;
					continue;
				}
			if (soap_flag_Longitude1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Longitude", &(a->ns2__LocationInfoType::Longitude), "xsd:string"))
				{	soap_flag_Longitude1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LocationInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LocationInfoType, 0, sizeof(ns2__LocationInfoType), 0, soap_copy_ns2__LocationInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartDate1 > 0 || soap_flag_EndDate1 > 0 || soap_flag_Latitude1 > 0 || soap_flag_Longitude1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__LocationInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__LocationInfoType);
	if (this->soap_out(soap, tag?tag:"ns2:LocationInfoType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LocationInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LocationInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LocationInfoType * SOAP_FMAC4 soap_get_ns2__LocationInfoType(struct soap *soap, ns2__LocationInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LocationInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__LocationInfoType * SOAP_FMAC2 soap_instantiate_ns2__LocationInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LocationInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__LocationInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__LocationInfoType);
		if (size)
			*size = sizeof(ns2__LocationInfoType);
		((ns2__LocationInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__LocationInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__LocationInfoType);
		for (int i = 0; i < n; i++)
			((ns2__LocationInfoType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__LocationInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__LocationInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__LocationInfoType %p -> %p\n", q, p));
	*(ns2__LocationInfoType*)p = *(ns2__LocationInfoType*)q;
}

void ns2__FamilyMemberInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__FamilyMemberInfoType::Relationship);
	soap_default_std__string(soap, &this->ns2__FamilyMemberInfoType::CIDNE_USCOREPersonName);
	this->ns2__FamilyMemberInfoType::YearOfBirth = NULL;
	this->ns2__FamilyMemberInfoType::Description = NULL;
	/* transient soap skipped */
}

void ns2__FamilyMemberInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__FamilyMemberInfoType::Relationship, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__FamilyMemberInfoType::Relationship);
	soap_embedded(soap, &this->ns2__FamilyMemberInfoType::CIDNE_USCOREPersonName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__FamilyMemberInfoType::CIDNE_USCOREPersonName);
	soap_serialize_PointerTostd__string(soap, &this->ns2__FamilyMemberInfoType::YearOfBirth);
	soap_serialize_PointerTostd__string(soap, &this->ns2__FamilyMemberInfoType::Description);
	/* transient soap skipped */
}

int ns2__FamilyMemberInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FamilyMemberInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FamilyMemberInfoType(struct soap *soap, const char *tag, int id, const ns2__FamilyMemberInfoType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FamilyMemberInfoType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Relationship", -1, &(a->ns2__FamilyMemberInfoType::Relationship), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:CIDNE_PersonName", -1, &(a->ns2__FamilyMemberInfoType::CIDNE_USCOREPersonName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:YearOfBirth", -1, &(a->ns2__FamilyMemberInfoType::YearOfBirth), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Description", -1, &(a->ns2__FamilyMemberInfoType::Description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__FamilyMemberInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FamilyMemberInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FamilyMemberInfoType * SOAP_FMAC4 soap_in_ns2__FamilyMemberInfoType(struct soap *soap, const char *tag, ns2__FamilyMemberInfoType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FamilyMemberInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FamilyMemberInfoType, sizeof(ns2__FamilyMemberInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FamilyMemberInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FamilyMemberInfoType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Relationship1 = 1;
	size_t soap_flag_CIDNE_USCOREPersonName1 = 1;
	size_t soap_flag_YearOfBirth1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Relationship1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Relationship", &(a->ns2__FamilyMemberInfoType::Relationship), "xsd:string"))
				{	soap_flag_Relationship1--;
					continue;
				}
			if (soap_flag_CIDNE_USCOREPersonName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:CIDNE_PersonName", &(a->ns2__FamilyMemberInfoType::CIDNE_USCOREPersonName), "xsd:string"))
				{	soap_flag_CIDNE_USCOREPersonName1--;
					continue;
				}
			if (soap_flag_YearOfBirth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:YearOfBirth", &(a->ns2__FamilyMemberInfoType::YearOfBirth), "xsd:string"))
				{	soap_flag_YearOfBirth1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Description", &(a->ns2__FamilyMemberInfoType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FamilyMemberInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FamilyMemberInfoType, 0, sizeof(ns2__FamilyMemberInfoType), 0, soap_copy_ns2__FamilyMemberInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Relationship1 > 0 || soap_flag_CIDNE_USCOREPersonName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__FamilyMemberInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FamilyMemberInfoType);
	if (this->soap_out(soap, tag?tag:"ns2:FamilyMemberInfoType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FamilyMemberInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FamilyMemberInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FamilyMemberInfoType * SOAP_FMAC4 soap_get_ns2__FamilyMemberInfoType(struct soap *soap, ns2__FamilyMemberInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FamilyMemberInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FamilyMemberInfoType * SOAP_FMAC2 soap_instantiate_ns2__FamilyMemberInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FamilyMemberInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FamilyMemberInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FamilyMemberInfoType);
		if (size)
			*size = sizeof(ns2__FamilyMemberInfoType);
		((ns2__FamilyMemberInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__FamilyMemberInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__FamilyMemberInfoType);
		for (int i = 0; i < n; i++)
			((ns2__FamilyMemberInfoType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__FamilyMemberInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FamilyMemberInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FamilyMemberInfoType %p -> %p\n", q, p));
	*(ns2__FamilyMemberInfoType*)p = *(ns2__FamilyMemberInfoType*)q;
}

void ns2__VehicleInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__VehicleInfoType::Type);
	this->ns2__VehicleInfoType::LicensePlate = NULL;
	this->ns2__VehicleInfoType::Color = NULL;
	this->ns2__VehicleInfoType::Description = NULL;
	/* transient soap skipped */
}

void ns2__VehicleInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__VehicleInfoType::Type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__VehicleInfoType::Type);
	soap_serialize_PointerTostd__string(soap, &this->ns2__VehicleInfoType::LicensePlate);
	soap_serialize_PointerTostd__string(soap, &this->ns2__VehicleInfoType::Color);
	soap_serialize_PointerTostd__string(soap, &this->ns2__VehicleInfoType::Description);
	/* transient soap skipped */
}

int ns2__VehicleInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VehicleInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VehicleInfoType(struct soap *soap, const char *tag, int id, const ns2__VehicleInfoType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VehicleInfoType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Type", -1, &(a->ns2__VehicleInfoType::Type), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:LicensePlate", -1, &(a->ns2__VehicleInfoType::LicensePlate), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Color", -1, &(a->ns2__VehicleInfoType::Color), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Description", -1, &(a->ns2__VehicleInfoType::Description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__VehicleInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VehicleInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VehicleInfoType * SOAP_FMAC4 soap_in_ns2__VehicleInfoType(struct soap *soap, const char *tag, ns2__VehicleInfoType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VehicleInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VehicleInfoType, sizeof(ns2__VehicleInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__VehicleInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__VehicleInfoType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_LicensePlate1 = 1;
	size_t soap_flag_Color1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Type", &(a->ns2__VehicleInfoType::Type), "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap_flag_LicensePlate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:LicensePlate", &(a->ns2__VehicleInfoType::LicensePlate), "xsd:string"))
				{	soap_flag_LicensePlate1--;
					continue;
				}
			if (soap_flag_Color1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Color", &(a->ns2__VehicleInfoType::Color), "xsd:string"))
				{	soap_flag_Color1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Description", &(a->ns2__VehicleInfoType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VehicleInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VehicleInfoType, 0, sizeof(ns2__VehicleInfoType), 0, soap_copy_ns2__VehicleInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__VehicleInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__VehicleInfoType);
	if (this->soap_out(soap, tag?tag:"ns2:VehicleInfoType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VehicleInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VehicleInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VehicleInfoType * SOAP_FMAC4 soap_get_ns2__VehicleInfoType(struct soap *soap, ns2__VehicleInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VehicleInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__VehicleInfoType * SOAP_FMAC2 soap_instantiate_ns2__VehicleInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VehicleInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__VehicleInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__VehicleInfoType);
		if (size)
			*size = sizeof(ns2__VehicleInfoType);
		((ns2__VehicleInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__VehicleInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__VehicleInfoType);
		for (int i = 0; i < n; i++)
			((ns2__VehicleInfoType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__VehicleInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__VehicleInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__VehicleInfoType %p -> %p\n", q, p));
	*(ns2__VehicleInfoType*)p = *(ns2__VehicleInfoType*)q;
}

void ns2__PEMSIIType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__YesNoType(soap, &this->ns2__PEMSIIType::Political);
	soap_default_ns2__YesNoType(soap, &this->ns2__PEMSIIType::Economic);
	soap_default_ns2__YesNoType(soap, &this->ns2__PEMSIIType::Military);
	soap_default_ns2__YesNoType(soap, &this->ns2__PEMSIIType::Social);
	soap_default_ns2__YesNoType(soap, &this->ns2__PEMSIIType::Information);
	soap_default_ns2__YesNoType(soap, &this->ns2__PEMSIIType::Infrastructure);
	/* transient soap skipped */
}

void ns2__PEMSIIType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__PEMSIIType::Political, SOAP_TYPE_ns2__YesNoType);
	soap_embedded(soap, &this->ns2__PEMSIIType::Economic, SOAP_TYPE_ns2__YesNoType);
	soap_embedded(soap, &this->ns2__PEMSIIType::Military, SOAP_TYPE_ns2__YesNoType);
	soap_embedded(soap, &this->ns2__PEMSIIType::Social, SOAP_TYPE_ns2__YesNoType);
	soap_embedded(soap, &this->ns2__PEMSIIType::Information, SOAP_TYPE_ns2__YesNoType);
	soap_embedded(soap, &this->ns2__PEMSIIType::Infrastructure, SOAP_TYPE_ns2__YesNoType);
	/* transient soap skipped */
}

int ns2__PEMSIIType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PEMSIIType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PEMSIIType(struct soap *soap, const char *tag, int id, const ns2__PEMSIIType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PEMSIIType), type))
		return soap->error;
	if (soap_out_ns2__YesNoType(soap, "ns2:Political", -1, &(a->ns2__PEMSIIType::Political), ""))
		return soap->error;
	if (soap_out_ns2__YesNoType(soap, "ns2:Economic", -1, &(a->ns2__PEMSIIType::Economic), ""))
		return soap->error;
	if (soap_out_ns2__YesNoType(soap, "ns2:Military", -1, &(a->ns2__PEMSIIType::Military), ""))
		return soap->error;
	if (soap_out_ns2__YesNoType(soap, "ns2:Social", -1, &(a->ns2__PEMSIIType::Social), ""))
		return soap->error;
	if (soap_out_ns2__YesNoType(soap, "ns2:Information", -1, &(a->ns2__PEMSIIType::Information), ""))
		return soap->error;
	if (soap_out_ns2__YesNoType(soap, "ns2:Infrastructure", -1, &(a->ns2__PEMSIIType::Infrastructure), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__PEMSIIType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PEMSIIType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PEMSIIType * SOAP_FMAC4 soap_in_ns2__PEMSIIType(struct soap *soap, const char *tag, ns2__PEMSIIType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PEMSIIType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PEMSIIType, sizeof(ns2__PEMSIIType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__PEMSIIType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__PEMSIIType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Political1 = 1;
	size_t soap_flag_Economic1 = 1;
	size_t soap_flag_Military1 = 1;
	size_t soap_flag_Social1 = 1;
	size_t soap_flag_Information1 = 1;
	size_t soap_flag_Infrastructure1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Political1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__YesNoType(soap, "ns2:Political", &(a->ns2__PEMSIIType::Political), "ns2:YesNoType"))
				{	soap_flag_Political1--;
					continue;
				}
			if (soap_flag_Economic1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__YesNoType(soap, "ns2:Economic", &(a->ns2__PEMSIIType::Economic), "ns2:YesNoType"))
				{	soap_flag_Economic1--;
					continue;
				}
			if (soap_flag_Military1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__YesNoType(soap, "ns2:Military", &(a->ns2__PEMSIIType::Military), "ns2:YesNoType"))
				{	soap_flag_Military1--;
					continue;
				}
			if (soap_flag_Social1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__YesNoType(soap, "ns2:Social", &(a->ns2__PEMSIIType::Social), "ns2:YesNoType"))
				{	soap_flag_Social1--;
					continue;
				}
			if (soap_flag_Information1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__YesNoType(soap, "ns2:Information", &(a->ns2__PEMSIIType::Information), "ns2:YesNoType"))
				{	soap_flag_Information1--;
					continue;
				}
			if (soap_flag_Infrastructure1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__YesNoType(soap, "ns2:Infrastructure", &(a->ns2__PEMSIIType::Infrastructure), "ns2:YesNoType"))
				{	soap_flag_Infrastructure1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PEMSIIType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PEMSIIType, 0, sizeof(ns2__PEMSIIType), 0, soap_copy_ns2__PEMSIIType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Political1 > 0 || soap_flag_Economic1 > 0 || soap_flag_Military1 > 0 || soap_flag_Social1 > 0 || soap_flag_Information1 > 0 || soap_flag_Infrastructure1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__PEMSIIType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__PEMSIIType);
	if (this->soap_out(soap, tag?tag:"ns2:PEMSIIType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PEMSIIType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PEMSIIType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PEMSIIType * SOAP_FMAC4 soap_get_ns2__PEMSIIType(struct soap *soap, ns2__PEMSIIType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PEMSIIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__PEMSIIType * SOAP_FMAC2 soap_instantiate_ns2__PEMSIIType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PEMSIIType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__PEMSIIType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__PEMSIIType);
		if (size)
			*size = sizeof(ns2__PEMSIIType);
		((ns2__PEMSIIType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__PEMSIIType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__PEMSIIType);
		for (int i = 0; i < n; i++)
			((ns2__PEMSIIType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__PEMSIIType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__PEMSIIType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__PEMSIIType %p -> %p\n", q, p));
	*(ns2__PEMSIIType*)p = *(ns2__PEMSIIType*)q;
}

void ns2__DescriptionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__GenderType(soap, &this->ns2__DescriptionType::Gender);
	soap_default_ns2__EyeColorType(soap, &this->ns2__DescriptionType::EyeColor);
	soap_default_ns2__HairColorType(soap, &this->ns2__DescriptionType::HairColor);
	soap_default_ns2__BuildType(soap, &this->ns2__DescriptionType::Build);
	soap_default_ns2__MannerOfDressType(soap, &this->ns2__DescriptionType::MannerOfDress);
	soap_default_ns2__WritingHandType(soap, &this->ns2__DescriptionType::WritingHand);
	soap_default_std__string(soap, &this->ns2__DescriptionType::Height);
	soap_default_std__string(soap, &this->ns2__DescriptionType::Weight);
	this->ns2__DescriptionType::FacialHair = NULL;
	this->ns2__DescriptionType::DistinguishingMarks = NULL;
	this->ns2__DescriptionType::Details = NULL;
	/* transient soap skipped */
}

void ns2__DescriptionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__DescriptionType::Gender, SOAP_TYPE_ns2__GenderType);
	soap_embedded(soap, &this->ns2__DescriptionType::Height, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__DescriptionType::Height);
	soap_embedded(soap, &this->ns2__DescriptionType::Weight, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__DescriptionType::Weight);
	soap_serialize_PointerTostd__string(soap, &this->ns2__DescriptionType::FacialHair);
	soap_serialize_PointerTostd__string(soap, &this->ns2__DescriptionType::DistinguishingMarks);
	soap_serialize_PointerTostd__string(soap, &this->ns2__DescriptionType::Details);
	/* transient soap skipped */
}

int ns2__DescriptionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DescriptionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DescriptionType(struct soap *soap, const char *tag, int id, const ns2__DescriptionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DescriptionType), type))
		return soap->error;
	if (soap_out_ns2__GenderType(soap, "ns2:Gender", -1, &(a->ns2__DescriptionType::Gender), ""))
		return soap->error;
	if (soap_out_ns2__EyeColorType(soap, "ns2:EyeColor", -1, &(a->ns2__DescriptionType::EyeColor), ""))
		return soap->error;
	if (soap_out_ns2__HairColorType(soap, "ns2:HairColor", -1, &(a->ns2__DescriptionType::HairColor), ""))
		return soap->error;
	if (soap_out_ns2__BuildType(soap, "ns2:Build", -1, &(a->ns2__DescriptionType::Build), ""))
		return soap->error;
	if (soap_out_ns2__MannerOfDressType(soap, "ns2:MannerOfDress", -1, &(a->ns2__DescriptionType::MannerOfDress), ""))
		return soap->error;
	if (soap_out_ns2__WritingHandType(soap, "ns2:WritingHand", -1, &(a->ns2__DescriptionType::WritingHand), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Height", -1, &(a->ns2__DescriptionType::Height), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Weight", -1, &(a->ns2__DescriptionType::Weight), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:FacialHair", -1, &(a->ns2__DescriptionType::FacialHair), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:DistinguishingMarks", -1, &(a->ns2__DescriptionType::DistinguishingMarks), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Details", -1, &(a->ns2__DescriptionType::Details), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DescriptionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DescriptionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DescriptionType * SOAP_FMAC4 soap_in_ns2__DescriptionType(struct soap *soap, const char *tag, ns2__DescriptionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DescriptionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DescriptionType, sizeof(ns2__DescriptionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DescriptionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DescriptionType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Gender1 = 1;
	size_t soap_flag_EyeColor1 = 1;
	size_t soap_flag_HairColor1 = 1;
	size_t soap_flag_Build1 = 1;
	size_t soap_flag_MannerOfDress1 = 1;
	size_t soap_flag_WritingHand1 = 1;
	size_t soap_flag_Height1 = 1;
	size_t soap_flag_Weight1 = 1;
	size_t soap_flag_FacialHair1 = 1;
	size_t soap_flag_DistinguishingMarks1 = 1;
	size_t soap_flag_Details1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Gender1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__GenderType(soap, "ns2:Gender", &(a->ns2__DescriptionType::Gender), "ns2:GenderType"))
				{	soap_flag_Gender1--;
					continue;
				}
			if (soap_flag_EyeColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__EyeColorType(soap, "ns2:EyeColor", &(a->ns2__DescriptionType::EyeColor), "ns2:EyeColorType"))
				{	soap_flag_EyeColor1--;
					continue;
				}
			if (soap_flag_HairColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__HairColorType(soap, "ns2:HairColor", &(a->ns2__DescriptionType::HairColor), "ns2:HairColorType"))
				{	soap_flag_HairColor1--;
					continue;
				}
			if (soap_flag_Build1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__BuildType(soap, "ns2:Build", &(a->ns2__DescriptionType::Build), "ns2:BuildType"))
				{	soap_flag_Build1--;
					continue;
				}
			if (soap_flag_MannerOfDress1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__MannerOfDressType(soap, "ns2:MannerOfDress", &(a->ns2__DescriptionType::MannerOfDress), "ns2:MannerOfDressType"))
				{	soap_flag_MannerOfDress1--;
					continue;
				}
			if (soap_flag_WritingHand1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__WritingHandType(soap, "ns2:WritingHand", &(a->ns2__DescriptionType::WritingHand), "ns2:WritingHandType"))
				{	soap_flag_WritingHand1--;
					continue;
				}
			if (soap_flag_Height1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Height", &(a->ns2__DescriptionType::Height), "xsd:string"))
				{	soap_flag_Height1--;
					continue;
				}
			if (soap_flag_Weight1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Weight", &(a->ns2__DescriptionType::Weight), "xsd:string"))
				{	soap_flag_Weight1--;
					continue;
				}
			if (soap_flag_FacialHair1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:FacialHair", &(a->ns2__DescriptionType::FacialHair), "xsd:string"))
				{	soap_flag_FacialHair1--;
					continue;
				}
			if (soap_flag_DistinguishingMarks1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:DistinguishingMarks", &(a->ns2__DescriptionType::DistinguishingMarks), "xsd:string"))
				{	soap_flag_DistinguishingMarks1--;
					continue;
				}
			if (soap_flag_Details1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Details", &(a->ns2__DescriptionType::Details), "xsd:string"))
				{	soap_flag_Details1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DescriptionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DescriptionType, 0, sizeof(ns2__DescriptionType), 0, soap_copy_ns2__DescriptionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Gender1 > 0 || soap_flag_EyeColor1 > 0 || soap_flag_HairColor1 > 0 || soap_flag_Build1 > 0 || soap_flag_MannerOfDress1 > 0 || soap_flag_WritingHand1 > 0 || soap_flag_Height1 > 0 || soap_flag_Weight1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__DescriptionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DescriptionType);
	if (this->soap_out(soap, tag?tag:"ns2:DescriptionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DescriptionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DescriptionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DescriptionType * SOAP_FMAC4 soap_get_ns2__DescriptionType(struct soap *soap, ns2__DescriptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DescriptionType * SOAP_FMAC2 soap_instantiate_ns2__DescriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DescriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DescriptionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DescriptionType);
		if (size)
			*size = sizeof(ns2__DescriptionType);
		((ns2__DescriptionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__DescriptionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__DescriptionType);
		for (int i = 0; i < n; i++)
			((ns2__DescriptionType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__DescriptionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DescriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DescriptionType %p -> %p\n", q, p));
	*(ns2__DescriptionType*)p = *(ns2__DescriptionType*)q;
}

void ns2__TitleAliasIdInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__TitleAliasIdInfoType::CaptureTag);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__TitleAliasIdInfoType::ISN);
	soap_default_std__vectorTemplateOfPointerTons2__OtherIDType(soap, &this->ns2__TitleAliasIdInfoType::OtherID);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__TitleAliasIdInfoType::Alias);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__TitleAliasIdInfoType::Title);
	/* transient soap skipped */
}

void ns2__TitleAliasIdInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__TitleAliasIdInfoType::CaptureTag);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__TitleAliasIdInfoType::ISN);
	soap_serialize_std__vectorTemplateOfPointerTons2__OtherIDType(soap, &this->ns2__TitleAliasIdInfoType::OtherID);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__TitleAliasIdInfoType::Alias);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__TitleAliasIdInfoType::Title);
	/* transient soap skipped */
}

int ns2__TitleAliasIdInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TitleAliasIdInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TitleAliasIdInfoType(struct soap *soap, const char *tag, int id, const ns2__TitleAliasIdInfoType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TitleAliasIdInfoType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns2:CaptureTag", -1, &(a->ns2__TitleAliasIdInfoType::CaptureTag), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns2:ISN", -1, &(a->ns2__TitleAliasIdInfoType::ISN), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__OtherIDType(soap, "ns2:OtherID", -1, &(a->ns2__TitleAliasIdInfoType::OtherID), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns2:Alias", -1, &(a->ns2__TitleAliasIdInfoType::Alias), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns2:Title", -1, &(a->ns2__TitleAliasIdInfoType::Title), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__TitleAliasIdInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TitleAliasIdInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TitleAliasIdInfoType * SOAP_FMAC4 soap_in_ns2__TitleAliasIdInfoType(struct soap *soap, const char *tag, ns2__TitleAliasIdInfoType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TitleAliasIdInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TitleAliasIdInfoType, sizeof(ns2__TitleAliasIdInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__TitleAliasIdInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__TitleAliasIdInfoType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns2:CaptureTag", &(a->ns2__TitleAliasIdInfoType::CaptureTag), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns2:ISN", &(a->ns2__TitleAliasIdInfoType::ISN), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__OtherIDType(soap, "ns2:OtherID", &(a->ns2__TitleAliasIdInfoType::OtherID), "ns2:OtherIDType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns2:Alias", &(a->ns2__TitleAliasIdInfoType::Alias), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns2:Title", &(a->ns2__TitleAliasIdInfoType::Title), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TitleAliasIdInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TitleAliasIdInfoType, 0, sizeof(ns2__TitleAliasIdInfoType), 0, soap_copy_ns2__TitleAliasIdInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__TitleAliasIdInfoType::Alias.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__TitleAliasIdInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__TitleAliasIdInfoType);
	if (this->soap_out(soap, tag?tag:"ns2:TitleAliasIdInfoType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TitleAliasIdInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TitleAliasIdInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TitleAliasIdInfoType * SOAP_FMAC4 soap_get_ns2__TitleAliasIdInfoType(struct soap *soap, ns2__TitleAliasIdInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TitleAliasIdInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__TitleAliasIdInfoType * SOAP_FMAC2 soap_instantiate_ns2__TitleAliasIdInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TitleAliasIdInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__TitleAliasIdInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__TitleAliasIdInfoType);
		if (size)
			*size = sizeof(ns2__TitleAliasIdInfoType);
		((ns2__TitleAliasIdInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__TitleAliasIdInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__TitleAliasIdInfoType);
		for (int i = 0; i < n; i++)
			((ns2__TitleAliasIdInfoType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__TitleAliasIdInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__TitleAliasIdInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__TitleAliasIdInfoType %p -> %p\n", q, p));
	*(ns2__TitleAliasIdInfoType*)p = *(ns2__TitleAliasIdInfoType*)q;
}

void ns2__OtherIDType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__OtherIDType::Type);
	soap_default_std__string(soap, &this->ns2__OtherIDType::Value);
	/* transient soap skipped */
}

void ns2__OtherIDType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__OtherIDType::Type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__OtherIDType::Type);
	soap_embedded(soap, &this->ns2__OtherIDType::Value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__OtherIDType::Value);
	/* transient soap skipped */
}

int ns2__OtherIDType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OtherIDType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OtherIDType(struct soap *soap, const char *tag, int id, const ns2__OtherIDType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OtherIDType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Type", -1, &(a->ns2__OtherIDType::Type), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Value", -1, &(a->ns2__OtherIDType::Value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__OtherIDType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OtherIDType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OtherIDType * SOAP_FMAC4 soap_in_ns2__OtherIDType(struct soap *soap, const char *tag, ns2__OtherIDType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OtherIDType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OtherIDType, sizeof(ns2__OtherIDType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OtherIDType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OtherIDType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Type", &(a->ns2__OtherIDType::Type), "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap_flag_Value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Value", &(a->ns2__OtherIDType::Value), "xsd:string"))
				{	soap_flag_Value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OtherIDType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OtherIDType, 0, sizeof(ns2__OtherIDType), 0, soap_copy_ns2__OtherIDType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0 || soap_flag_Value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__OtherIDType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OtherIDType);
	if (this->soap_out(soap, tag?tag:"ns2:OtherIDType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OtherIDType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OtherIDType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OtherIDType * SOAP_FMAC4 soap_get_ns2__OtherIDType(struct soap *soap, ns2__OtherIDType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OtherIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OtherIDType * SOAP_FMAC2 soap_instantiate_ns2__OtherIDType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OtherIDType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OtherIDType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OtherIDType);
		if (size)
			*size = sizeof(ns2__OtherIDType);
		((ns2__OtherIDType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__OtherIDType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__OtherIDType);
		for (int i = 0; i < n; i++)
			((ns2__OtherIDType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__OtherIDType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OtherIDType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OtherIDType %p -> %p\n", q, p));
	*(ns2__OtherIDType*)p = *(ns2__OtherIDType*)q;
}

void ns2__ContactInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ContactInfoType::HomePhone = NULL;
	this->ns2__ContactInfoType::WorkPhone = NULL;
	this->ns2__ContactInfoType::CellPhone = NULL;
	this->ns2__ContactInfoType::AlternateCell = NULL;
	this->ns2__ContactInfoType::AlternateWork = NULL;
	this->ns2__ContactInfoType::Fax = NULL;
	this->ns2__ContactInfoType::Email = NULL;
	this->ns2__ContactInfoType::AlternateEmail = NULL;
	/* transient soap skipped */
}

void ns2__ContactInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__ContactInfoType::HomePhone);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ContactInfoType::WorkPhone);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ContactInfoType::CellPhone);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ContactInfoType::AlternateCell);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ContactInfoType::AlternateWork);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ContactInfoType::Fax);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ContactInfoType::Email);
	soap_serialize_PointerTostd__string(soap, &this->ns2__ContactInfoType::AlternateEmail);
	/* transient soap skipped */
}

int ns2__ContactInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ContactInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContactInfoType(struct soap *soap, const char *tag, int id, const ns2__ContactInfoType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContactInfoType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:HomePhone", -1, &(a->ns2__ContactInfoType::HomePhone), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:WorkPhone", -1, &(a->ns2__ContactInfoType::WorkPhone), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:CellPhone", -1, &(a->ns2__ContactInfoType::CellPhone), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:AlternateCell", -1, &(a->ns2__ContactInfoType::AlternateCell), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:AlternateWork", -1, &(a->ns2__ContactInfoType::AlternateWork), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Fax", -1, &(a->ns2__ContactInfoType::Fax), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:Email", -1, &(a->ns2__ContactInfoType::Email), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:AlternateEmail", -1, &(a->ns2__ContactInfoType::AlternateEmail), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ContactInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ContactInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ContactInfoType * SOAP_FMAC4 soap_in_ns2__ContactInfoType(struct soap *soap, const char *tag, ns2__ContactInfoType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ContactInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContactInfoType, sizeof(ns2__ContactInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ContactInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ContactInfoType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_HomePhone1 = 1;
	size_t soap_flag_WorkPhone1 = 1;
	size_t soap_flag_CellPhone1 = 1;
	size_t soap_flag_AlternateCell1 = 1;
	size_t soap_flag_AlternateWork1 = 1;
	size_t soap_flag_Fax1 = 1;
	size_t soap_flag_Email1 = 1;
	size_t soap_flag_AlternateEmail1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HomePhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:HomePhone", &(a->ns2__ContactInfoType::HomePhone), "xsd:string"))
				{	soap_flag_HomePhone1--;
					continue;
				}
			if (soap_flag_WorkPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:WorkPhone", &(a->ns2__ContactInfoType::WorkPhone), "xsd:string"))
				{	soap_flag_WorkPhone1--;
					continue;
				}
			if (soap_flag_CellPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:CellPhone", &(a->ns2__ContactInfoType::CellPhone), "xsd:string"))
				{	soap_flag_CellPhone1--;
					continue;
				}
			if (soap_flag_AlternateCell1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:AlternateCell", &(a->ns2__ContactInfoType::AlternateCell), "xsd:string"))
				{	soap_flag_AlternateCell1--;
					continue;
				}
			if (soap_flag_AlternateWork1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:AlternateWork", &(a->ns2__ContactInfoType::AlternateWork), "xsd:string"))
				{	soap_flag_AlternateWork1--;
					continue;
				}
			if (soap_flag_Fax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Fax", &(a->ns2__ContactInfoType::Fax), "xsd:string"))
				{	soap_flag_Fax1--;
					continue;
				}
			if (soap_flag_Email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:Email", &(a->ns2__ContactInfoType::Email), "xsd:string"))
				{	soap_flag_Email1--;
					continue;
				}
			if (soap_flag_AlternateEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:AlternateEmail", &(a->ns2__ContactInfoType::AlternateEmail), "xsd:string"))
				{	soap_flag_AlternateEmail1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ContactInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContactInfoType, 0, sizeof(ns2__ContactInfoType), 0, soap_copy_ns2__ContactInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ContactInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ContactInfoType);
	if (this->soap_out(soap, tag?tag:"ns2:ContactInfoType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ContactInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ContactInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ContactInfoType * SOAP_FMAC4 soap_get_ns2__ContactInfoType(struct soap *soap, ns2__ContactInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContactInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ContactInfoType * SOAP_FMAC2 soap_instantiate_ns2__ContactInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ContactInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ContactInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContactInfoType);
		if (size)
			*size = sizeof(ns2__ContactInfoType);
		((ns2__ContactInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContactInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ContactInfoType);
		for (int i = 0; i < n; i++)
			((ns2__ContactInfoType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ContactInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ContactInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ContactInfoType %p -> %p\n", q, p));
	*(ns2__ContactInfoType*)p = *(ns2__ContactInfoType*)q;
}

void ns2__CIDNE_USCOREPersonalInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Tribe);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Confederation);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::House);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Clan);
	soap_default_ns2__YesNoType(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Religion);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::ReligiousSectType);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::ReligionPracticing);
	this->ns2__CIDNE_USCOREPersonalInfoType::ReligionDetails = NULL;
	this->ns2__CIDNE_USCOREPersonalInfoType::ReligiousInfluence = NULL;
	this->ns2__CIDNE_USCOREPersonalInfoType::AttendsMosqueChurch = NULL;
	soap_default_ns2__PoliticalStanceType(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::PoliticalStance);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Ethnicity);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Nationality);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::BirthDateOrYear);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::DeathDateOrYear);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::LanguagesSpoken);
	/* transient soap skipped */
}

void ns2__CIDNE_USCOREPersonalInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Tribe, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Tribe);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Confederation, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Confederation);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::House, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::House);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Clan, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Clan);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Religion, SOAP_TYPE_ns2__YesNoType);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::ReligiousSectType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::ReligiousSectType);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::ReligionPracticing, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::ReligionPracticing);
	soap_serialize_PointerTostd__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::ReligionDetails);
	soap_serialize_PointerTostd__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::ReligiousInfluence);
	soap_serialize_PointerTostd__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::AttendsMosqueChurch);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Ethnicity, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Ethnicity);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Nationality, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::Nationality);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::BirthDateOrYear, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::BirthDateOrYear);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::DeathDateOrYear, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::DeathDateOrYear);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::LanguagesSpoken, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonalInfoType::LanguagesSpoken);
	/* transient soap skipped */
}

int ns2__CIDNE_USCOREPersonalInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CIDNE_USCOREPersonalInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CIDNE_USCOREPersonalInfoType(struct soap *soap, const char *tag, int id, const ns2__CIDNE_USCOREPersonalInfoType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Tribe", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::Tribe), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Confederation", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::Confederation), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:House", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::House), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Clan", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::Clan), ""))
		return soap->error;
	if (soap_out_ns2__YesNoType(soap, "ns2:Religion", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::Religion), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:ReligiousSectType", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::ReligiousSectType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:ReligionPracticing", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::ReligionPracticing), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:ReligionDetails", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::ReligionDetails), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:ReligiousInfluence", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::ReligiousInfluence), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:AttendsMosqueChurch", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::AttendsMosqueChurch), ""))
		return soap->error;
	if (soap_out_ns2__PoliticalStanceType(soap, "ns2:PoliticalStance", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::PoliticalStance), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Ethnicity", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::Ethnicity), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Nationality", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::Nationality), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:BirthDateOrYear", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::BirthDateOrYear), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:DeathDateOrYear", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::DeathDateOrYear), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:LanguagesSpoken", -1, &(a->ns2__CIDNE_USCOREPersonalInfoType::LanguagesSpoken), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CIDNE_USCOREPersonalInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CIDNE_USCOREPersonalInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CIDNE_USCOREPersonalInfoType * SOAP_FMAC4 soap_in_ns2__CIDNE_USCOREPersonalInfoType(struct soap *soap, const char *tag, ns2__CIDNE_USCOREPersonalInfoType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CIDNE_USCOREPersonalInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType, sizeof(ns2__CIDNE_USCOREPersonalInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CIDNE_USCOREPersonalInfoType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Tribe1 = 1;
	size_t soap_flag_Confederation1 = 1;
	size_t soap_flag_House1 = 1;
	size_t soap_flag_Clan1 = 1;
	size_t soap_flag_Religion1 = 1;
	size_t soap_flag_ReligiousSectType1 = 1;
	size_t soap_flag_ReligionPracticing1 = 1;
	size_t soap_flag_ReligionDetails1 = 1;
	size_t soap_flag_ReligiousInfluence1 = 1;
	size_t soap_flag_AttendsMosqueChurch1 = 1;
	size_t soap_flag_PoliticalStance1 = 1;
	size_t soap_flag_Ethnicity1 = 1;
	size_t soap_flag_Nationality1 = 1;
	size_t soap_flag_BirthDateOrYear1 = 1;
	size_t soap_flag_DeathDateOrYear1 = 1;
	size_t soap_flag_LanguagesSpoken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Tribe1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Tribe", &(a->ns2__CIDNE_USCOREPersonalInfoType::Tribe), "xsd:string"))
				{	soap_flag_Tribe1--;
					continue;
				}
			if (soap_flag_Confederation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Confederation", &(a->ns2__CIDNE_USCOREPersonalInfoType::Confederation), "xsd:string"))
				{	soap_flag_Confederation1--;
					continue;
				}
			if (soap_flag_House1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:House", &(a->ns2__CIDNE_USCOREPersonalInfoType::House), "xsd:string"))
				{	soap_flag_House1--;
					continue;
				}
			if (soap_flag_Clan1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Clan", &(a->ns2__CIDNE_USCOREPersonalInfoType::Clan), "xsd:string"))
				{	soap_flag_Clan1--;
					continue;
				}
			if (soap_flag_Religion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__YesNoType(soap, "ns2:Religion", &(a->ns2__CIDNE_USCOREPersonalInfoType::Religion), "ns2:YesNoType"))
				{	soap_flag_Religion1--;
					continue;
				}
			if (soap_flag_ReligiousSectType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:ReligiousSectType", &(a->ns2__CIDNE_USCOREPersonalInfoType::ReligiousSectType), "xsd:string"))
				{	soap_flag_ReligiousSectType1--;
					continue;
				}
			if (soap_flag_ReligionPracticing1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:ReligionPracticing", &(a->ns2__CIDNE_USCOREPersonalInfoType::ReligionPracticing), "xsd:string"))
				{	soap_flag_ReligionPracticing1--;
					continue;
				}
			if (soap_flag_ReligionDetails1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:ReligionDetails", &(a->ns2__CIDNE_USCOREPersonalInfoType::ReligionDetails), "xsd:string"))
				{	soap_flag_ReligionDetails1--;
					continue;
				}
			if (soap_flag_ReligiousInfluence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:ReligiousInfluence", &(a->ns2__CIDNE_USCOREPersonalInfoType::ReligiousInfluence), "xsd:string"))
				{	soap_flag_ReligiousInfluence1--;
					continue;
				}
			if (soap_flag_AttendsMosqueChurch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:AttendsMosqueChurch", &(a->ns2__CIDNE_USCOREPersonalInfoType::AttendsMosqueChurch), "xsd:string"))
				{	soap_flag_AttendsMosqueChurch1--;
					continue;
				}
			if (soap_flag_PoliticalStance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__PoliticalStanceType(soap, "ns2:PoliticalStance", &(a->ns2__CIDNE_USCOREPersonalInfoType::PoliticalStance), "ns2:PoliticalStanceType"))
				{	soap_flag_PoliticalStance1--;
					continue;
				}
			if (soap_flag_Ethnicity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Ethnicity", &(a->ns2__CIDNE_USCOREPersonalInfoType::Ethnicity), "xsd:string"))
				{	soap_flag_Ethnicity1--;
					continue;
				}
			if (soap_flag_Nationality1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Nationality", &(a->ns2__CIDNE_USCOREPersonalInfoType::Nationality), "xsd:string"))
				{	soap_flag_Nationality1--;
					continue;
				}
			if (soap_flag_BirthDateOrYear1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:BirthDateOrYear", &(a->ns2__CIDNE_USCOREPersonalInfoType::BirthDateOrYear), "xsd:string"))
				{	soap_flag_BirthDateOrYear1--;
					continue;
				}
			if (soap_flag_DeathDateOrYear1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:DeathDateOrYear", &(a->ns2__CIDNE_USCOREPersonalInfoType::DeathDateOrYear), "xsd:string"))
				{	soap_flag_DeathDateOrYear1--;
					continue;
				}
			if (soap_flag_LanguagesSpoken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:LanguagesSpoken", &(a->ns2__CIDNE_USCOREPersonalInfoType::LanguagesSpoken), "xsd:string"))
				{	soap_flag_LanguagesSpoken1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CIDNE_USCOREPersonalInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType, 0, sizeof(ns2__CIDNE_USCOREPersonalInfoType), 0, soap_copy_ns2__CIDNE_USCOREPersonalInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Tribe1 > 0 || soap_flag_Confederation1 > 0 || soap_flag_House1 > 0 || soap_flag_Clan1 > 0 || soap_flag_Religion1 > 0 || soap_flag_ReligiousSectType1 > 0 || soap_flag_ReligionPracticing1 > 0 || soap_flag_PoliticalStance1 > 0 || soap_flag_Ethnicity1 > 0 || soap_flag_Nationality1 > 0 || soap_flag_BirthDateOrYear1 > 0 || soap_flag_DeathDateOrYear1 > 0 || soap_flag_LanguagesSpoken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__CIDNE_USCOREPersonalInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType);
	if (this->soap_out(soap, tag?tag:"ns2:CIDNE_PersonalInfoType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CIDNE_USCOREPersonalInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CIDNE_USCOREPersonalInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CIDNE_USCOREPersonalInfoType * SOAP_FMAC4 soap_get_ns2__CIDNE_USCOREPersonalInfoType(struct soap *soap, ns2__CIDNE_USCOREPersonalInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CIDNE_USCOREPersonalInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CIDNE_USCOREPersonalInfoType * SOAP_FMAC2 soap_instantiate_ns2__CIDNE_USCOREPersonalInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CIDNE_USCOREPersonalInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CIDNE_USCOREPersonalInfoType);
		if (size)
			*size = sizeof(ns2__CIDNE_USCOREPersonalInfoType);
		((ns2__CIDNE_USCOREPersonalInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CIDNE_USCOREPersonalInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CIDNE_USCOREPersonalInfoType);
		for (int i = 0; i < n; i++)
			((ns2__CIDNE_USCOREPersonalInfoType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CIDNE_USCOREPersonalInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CIDNE_USCOREPersonalInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CIDNE_USCOREPersonalInfoType %p -> %p\n", q, p));
	*(ns2__CIDNE_USCOREPersonalInfoType*)p = *(ns2__CIDNE_USCOREPersonalInfoType*)q;
}

void ns2__NameInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__NameInfoType::FirstName);
	soap_default_std__string(soap, &this->ns2__NameInfoType::MiddleName);
	soap_default_std__string(soap, &this->ns2__NameInfoType::LastName);
	soap_default_std__string(soap, &this->ns2__NameInfoType::Suffix);
	soap_default_std__string(soap, &this->ns2__NameInfoType::Kunya);
	soap_default_std__string(soap, &this->ns2__NameInfoType::Laqab);
	/* transient soap skipped */
}

void ns2__NameInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__NameInfoType::FirstName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__NameInfoType::FirstName);
	soap_embedded(soap, &this->ns2__NameInfoType::MiddleName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__NameInfoType::MiddleName);
	soap_embedded(soap, &this->ns2__NameInfoType::LastName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__NameInfoType::LastName);
	soap_embedded(soap, &this->ns2__NameInfoType::Suffix, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__NameInfoType::Suffix);
	soap_embedded(soap, &this->ns2__NameInfoType::Kunya, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__NameInfoType::Kunya);
	soap_embedded(soap, &this->ns2__NameInfoType::Laqab, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__NameInfoType::Laqab);
	/* transient soap skipped */
}

int ns2__NameInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NameInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NameInfoType(struct soap *soap, const char *tag, int id, const ns2__NameInfoType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NameInfoType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:FirstName", -1, &(a->ns2__NameInfoType::FirstName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:MiddleName", -1, &(a->ns2__NameInfoType::MiddleName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:LastName", -1, &(a->ns2__NameInfoType::LastName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Suffix", -1, &(a->ns2__NameInfoType::Suffix), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Kunya", -1, &(a->ns2__NameInfoType::Kunya), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Laqab", -1, &(a->ns2__NameInfoType::Laqab), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__NameInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NameInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NameInfoType * SOAP_FMAC4 soap_in_ns2__NameInfoType(struct soap *soap, const char *tag, ns2__NameInfoType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NameInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NameInfoType, sizeof(ns2__NameInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NameInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NameInfoType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_FirstName1 = 1;
	size_t soap_flag_MiddleName1 = 1;
	size_t soap_flag_LastName1 = 1;
	size_t soap_flag_Suffix1 = 1;
	size_t soap_flag_Kunya1 = 1;
	size_t soap_flag_Laqab1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FirstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:FirstName", &(a->ns2__NameInfoType::FirstName), "xsd:string"))
				{	soap_flag_FirstName1--;
					continue;
				}
			if (soap_flag_MiddleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:MiddleName", &(a->ns2__NameInfoType::MiddleName), "xsd:string"))
				{	soap_flag_MiddleName1--;
					continue;
				}
			if (soap_flag_LastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:LastName", &(a->ns2__NameInfoType::LastName), "xsd:string"))
				{	soap_flag_LastName1--;
					continue;
				}
			if (soap_flag_Suffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Suffix", &(a->ns2__NameInfoType::Suffix), "xsd:string"))
				{	soap_flag_Suffix1--;
					continue;
				}
			if (soap_flag_Kunya1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Kunya", &(a->ns2__NameInfoType::Kunya), "xsd:string"))
				{	soap_flag_Kunya1--;
					continue;
				}
			if (soap_flag_Laqab1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Laqab", &(a->ns2__NameInfoType::Laqab), "xsd:string"))
				{	soap_flag_Laqab1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NameInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NameInfoType, 0, sizeof(ns2__NameInfoType), 0, soap_copy_ns2__NameInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FirstName1 > 0 || soap_flag_MiddleName1 > 0 || soap_flag_LastName1 > 0 || soap_flag_Suffix1 > 0 || soap_flag_Kunya1 > 0 || soap_flag_Laqab1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NameInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NameInfoType);
	if (this->soap_out(soap, tag?tag:"ns2:NameInfoType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NameInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NameInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NameInfoType * SOAP_FMAC4 soap_get_ns2__NameInfoType(struct soap *soap, ns2__NameInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NameInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NameInfoType * SOAP_FMAC2 soap_instantiate_ns2__NameInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NameInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NameInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NameInfoType);
		if (size)
			*size = sizeof(ns2__NameInfoType);
		((ns2__NameInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__NameInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__NameInfoType);
		for (int i = 0; i < n; i++)
			((ns2__NameInfoType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__NameInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NameInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NameInfoType %p -> %p\n", q, p));
	*(ns2__NameInfoType*)p = *(ns2__NameInfoType*)q;
}

void ns2__CIDNE_USCOREPersonType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__ClassificationType(soap, &this->ns2__CIDNE_USCOREPersonType::Classification);
	soap_default_ns2__ReleasabilityType(soap, &this->ns2__CIDNE_USCOREPersonType::Releasibility);
	this->ns2__CIDNE_USCOREPersonType::NameInfo = NULL;
	soap_default_ns2__ClassificationType(soap, &this->ns2__CIDNE_USCOREPersonType::AssessmentClassification);
	soap_default_ns2__ReleasabilityType(soap, &this->ns2__CIDNE_USCOREPersonType::AssessmentReleasibility);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonType::Assessment);
	soap_default_std__string(soap, &this->ns2__CIDNE_USCOREPersonType::Significance);
	this->ns2__CIDNE_USCOREPersonType::CIDNE_USCOREPersonalInfo = NULL;
	this->ns2__CIDNE_USCOREPersonType::ContactInfo = NULL;
	this->ns2__CIDNE_USCOREPersonType::TitleAliasIdInfo = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__DescriptionType(soap, &this->ns2__CIDNE_USCOREPersonType::Description);
	this->ns2__CIDNE_USCOREPersonType::PEMSII = NULL;
	soap_default_std__vectorTemplateOfns2__RoleType(soap, &this->ns2__CIDNE_USCOREPersonType::Role);
	soap_default_std__vectorTemplateOfPointerTons2__VehicleInfoType(soap, &this->ns2__CIDNE_USCOREPersonType::Vehicle);
	soap_default_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(soap, &this->ns2__CIDNE_USCOREPersonType::FamilyMember);
	soap_default_std__vectorTemplateOfPointerTons2__LocationInfoType(soap, &this->ns2__CIDNE_USCOREPersonType::Location);
	soap_default_std__vectorTemplateOfPointerTons2__RemarkType(soap, &this->ns2__CIDNE_USCOREPersonType::Remark);
	/* transient soap skipped */
}

void ns2__CIDNE_USCOREPersonType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__NameInfoType(soap, &this->ns2__CIDNE_USCOREPersonType::NameInfo);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonType::Assessment, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonType::Assessment);
	soap_embedded(soap, &this->ns2__CIDNE_USCOREPersonType::Significance, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CIDNE_USCOREPersonType::Significance);
	soap_serialize_PointerTons2__CIDNE_USCOREPersonalInfoType(soap, &this->ns2__CIDNE_USCOREPersonType::CIDNE_USCOREPersonalInfo);
	soap_serialize_PointerTons2__ContactInfoType(soap, &this->ns2__CIDNE_USCOREPersonType::ContactInfo);
	soap_serialize_PointerTons2__TitleAliasIdInfoType(soap, &this->ns2__CIDNE_USCOREPersonType::TitleAliasIdInfo);
	soap_serialize_std__vectorTemplateOfPointerTons2__DescriptionType(soap, &this->ns2__CIDNE_USCOREPersonType::Description);
	soap_serialize_PointerTons2__PEMSIIType(soap, &this->ns2__CIDNE_USCOREPersonType::PEMSII);
	soap_serialize_std__vectorTemplateOfns2__RoleType(soap, &this->ns2__CIDNE_USCOREPersonType::Role);
	soap_serialize_std__vectorTemplateOfPointerTons2__VehicleInfoType(soap, &this->ns2__CIDNE_USCOREPersonType::Vehicle);
	soap_serialize_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(soap, &this->ns2__CIDNE_USCOREPersonType::FamilyMember);
	soap_serialize_std__vectorTemplateOfPointerTons2__LocationInfoType(soap, &this->ns2__CIDNE_USCOREPersonType::Location);
	soap_serialize_std__vectorTemplateOfPointerTons2__RemarkType(soap, &this->ns2__CIDNE_USCOREPersonType::Remark);
	/* transient soap skipped */
}

int ns2__CIDNE_USCOREPersonType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CIDNE_USCOREPersonType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CIDNE_USCOREPersonType(struct soap *soap, const char *tag, int id, const ns2__CIDNE_USCOREPersonType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CIDNE_USCOREPersonType), type))
		return soap->error;
	if (soap_out_ns2__ClassificationType(soap, "ns2:Classification", -1, &(a->ns2__CIDNE_USCOREPersonType::Classification), ""))
		return soap->error;
	if (soap_out_ns2__ReleasabilityType(soap, "ns2:Releasibility", -1, &(a->ns2__CIDNE_USCOREPersonType::Releasibility), ""))
		return soap->error;
	if (soap_out_PointerTons2__NameInfoType(soap, "ns2:NameInfo", -1, &(a->ns2__CIDNE_USCOREPersonType::NameInfo), ""))
		return soap->error;
	if (soap_out_ns2__ClassificationType(soap, "ns2:AssessmentClassification", -1, &(a->ns2__CIDNE_USCOREPersonType::AssessmentClassification), ""))
		return soap->error;
	if (soap_out_ns2__ReleasabilityType(soap, "ns2:AssessmentReleasibility", -1, &(a->ns2__CIDNE_USCOREPersonType::AssessmentReleasibility), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Assessment", -1, &(a->ns2__CIDNE_USCOREPersonType::Assessment), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Significance", -1, &(a->ns2__CIDNE_USCOREPersonType::Significance), ""))
		return soap->error;
	if (soap_out_PointerTons2__CIDNE_USCOREPersonalInfoType(soap, "ns2:CIDNE_PersonalInfo", -1, &(a->ns2__CIDNE_USCOREPersonType::CIDNE_USCOREPersonalInfo), ""))
		return soap->error;
	if (soap_out_PointerTons2__ContactInfoType(soap, "ns2:ContactInfo", -1, &(a->ns2__CIDNE_USCOREPersonType::ContactInfo), ""))
		return soap->error;
	if (soap_out_PointerTons2__TitleAliasIdInfoType(soap, "ns2:TitleAliasIdInfo", -1, &(a->ns2__CIDNE_USCOREPersonType::TitleAliasIdInfo), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__DescriptionType(soap, "ns2:Description", -1, &(a->ns2__CIDNE_USCOREPersonType::Description), ""))
		return soap->error;
	if (soap_out_PointerTons2__PEMSIIType(soap, "ns2:PEMSII", -1, &(a->ns2__CIDNE_USCOREPersonType::PEMSII), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns2__RoleType(soap, "ns2:Role", -1, &(a->ns2__CIDNE_USCOREPersonType::Role), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__VehicleInfoType(soap, "ns2:Vehicle", -1, &(a->ns2__CIDNE_USCOREPersonType::Vehicle), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(soap, "ns2:FamilyMember", -1, &(a->ns2__CIDNE_USCOREPersonType::FamilyMember), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__LocationInfoType(soap, "ns2:Location", -1, &(a->ns2__CIDNE_USCOREPersonType::Location), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__RemarkType(soap, "ns2:Remark", -1, &(a->ns2__CIDNE_USCOREPersonType::Remark), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CIDNE_USCOREPersonType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CIDNE_USCOREPersonType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CIDNE_USCOREPersonType * SOAP_FMAC4 soap_in_ns2__CIDNE_USCOREPersonType(struct soap *soap, const char *tag, ns2__CIDNE_USCOREPersonType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CIDNE_USCOREPersonType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CIDNE_USCOREPersonType, sizeof(ns2__CIDNE_USCOREPersonType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CIDNE_USCOREPersonType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CIDNE_USCOREPersonType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Classification1 = 1;
	size_t soap_flag_Releasibility1 = 1;
	size_t soap_flag_NameInfo1 = 1;
	size_t soap_flag_AssessmentClassification1 = 1;
	size_t soap_flag_AssessmentReleasibility1 = 1;
	size_t soap_flag_Assessment1 = 1;
	size_t soap_flag_Significance1 = 1;
	size_t soap_flag_CIDNE_USCOREPersonalInfo1 = 1;
	size_t soap_flag_ContactInfo1 = 1;
	size_t soap_flag_TitleAliasIdInfo1 = 1;
	size_t soap_flag_PEMSII1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Classification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ClassificationType(soap, "ns2:Classification", &(a->ns2__CIDNE_USCOREPersonType::Classification), "ns2:ClassificationType"))
				{	soap_flag_Classification1--;
					continue;
				}
			if (soap_flag_Releasibility1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ReleasabilityType(soap, "ns2:Releasibility", &(a->ns2__CIDNE_USCOREPersonType::Releasibility), "ns2:ReleasabilityType"))
				{	soap_flag_Releasibility1--;
					continue;
				}
			if (soap_flag_NameInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NameInfoType(soap, "ns2:NameInfo", &(a->ns2__CIDNE_USCOREPersonType::NameInfo), "ns2:NameInfoType"))
				{	soap_flag_NameInfo1--;
					continue;
				}
			if (soap_flag_AssessmentClassification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ClassificationType(soap, "ns2:AssessmentClassification", &(a->ns2__CIDNE_USCOREPersonType::AssessmentClassification), "ns2:ClassificationType"))
				{	soap_flag_AssessmentClassification1--;
					continue;
				}
			if (soap_flag_AssessmentReleasibility1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ReleasabilityType(soap, "ns2:AssessmentReleasibility", &(a->ns2__CIDNE_USCOREPersonType::AssessmentReleasibility), "ns2:ReleasabilityType"))
				{	soap_flag_AssessmentReleasibility1--;
					continue;
				}
			if (soap_flag_Assessment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Assessment", &(a->ns2__CIDNE_USCOREPersonType::Assessment), "xsd:string"))
				{	soap_flag_Assessment1--;
					continue;
				}
			if (soap_flag_Significance1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Significance", &(a->ns2__CIDNE_USCOREPersonType::Significance), "xsd:string"))
				{	soap_flag_Significance1--;
					continue;
				}
			if (soap_flag_CIDNE_USCOREPersonalInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CIDNE_USCOREPersonalInfoType(soap, "ns2:CIDNE_PersonalInfo", &(a->ns2__CIDNE_USCOREPersonType::CIDNE_USCOREPersonalInfo), "ns2:CIDNE_PersonalInfoType"))
				{	soap_flag_CIDNE_USCOREPersonalInfo1--;
					continue;
				}
			if (soap_flag_ContactInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContactInfoType(soap, "ns2:ContactInfo", &(a->ns2__CIDNE_USCOREPersonType::ContactInfo), "ns2:ContactInfoType"))
				{	soap_flag_ContactInfo1--;
					continue;
				}
			if (soap_flag_TitleAliasIdInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TitleAliasIdInfoType(soap, "ns2:TitleAliasIdInfo", &(a->ns2__CIDNE_USCOREPersonType::TitleAliasIdInfo), "ns2:TitleAliasIdInfoType"))
				{	soap_flag_TitleAliasIdInfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__DescriptionType(soap, "ns2:Description", &(a->ns2__CIDNE_USCOREPersonType::Description), "ns2:DescriptionType"))
					continue;
			if (soap_flag_PEMSII1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PEMSIIType(soap, "ns2:PEMSII", &(a->ns2__CIDNE_USCOREPersonType::PEMSII), "ns2:PEMSIIType"))
				{	soap_flag_PEMSII1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns2__RoleType(soap, "ns2:Role", &(a->ns2__CIDNE_USCOREPersonType::Role), "ns2:RoleType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__VehicleInfoType(soap, "ns2:Vehicle", &(a->ns2__CIDNE_USCOREPersonType::Vehicle), "ns2:VehicleInfoType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(soap, "ns2:FamilyMember", &(a->ns2__CIDNE_USCOREPersonType::FamilyMember), "ns2:FamilyMemberInfoType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__LocationInfoType(soap, "ns2:Location", &(a->ns2__CIDNE_USCOREPersonType::Location), "ns2:LocationInfoType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__RemarkType(soap, "ns2:Remark", &(a->ns2__CIDNE_USCOREPersonType::Remark), "ns2:RemarkType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CIDNE_USCOREPersonType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CIDNE_USCOREPersonType, 0, sizeof(ns2__CIDNE_USCOREPersonType), 0, soap_copy_ns2__CIDNE_USCOREPersonType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Classification1 > 0 || soap_flag_Releasibility1 > 0 || soap_flag_NameInfo1 > 0 || soap_flag_AssessmentClassification1 > 0 || soap_flag_AssessmentReleasibility1 > 0 || soap_flag_Assessment1 > 0 || soap_flag_Significance1 > 0 || soap_flag_CIDNE_USCOREPersonalInfo1 > 0 || soap_flag_ContactInfo1 > 0 || soap_flag_TitleAliasIdInfo1 > 0 || soap_flag_PEMSII1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__CIDNE_USCOREPersonType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CIDNE_USCOREPersonType);
	if (this->soap_out(soap, tag?tag:"ns2:CIDNE_PersonType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CIDNE_USCOREPersonType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CIDNE_USCOREPersonType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CIDNE_USCOREPersonType * SOAP_FMAC4 soap_get_ns2__CIDNE_USCOREPersonType(struct soap *soap, ns2__CIDNE_USCOREPersonType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CIDNE_USCOREPersonType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CIDNE_USCOREPersonType * SOAP_FMAC2 soap_instantiate_ns2__CIDNE_USCOREPersonType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CIDNE_USCOREPersonType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CIDNE_USCOREPersonType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CIDNE_USCOREPersonType);
		if (size)
			*size = sizeof(ns2__CIDNE_USCOREPersonType);
		((ns2__CIDNE_USCOREPersonType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CIDNE_USCOREPersonType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CIDNE_USCOREPersonType);
		for (int i = 0; i < n; i++)
			((ns2__CIDNE_USCOREPersonType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CIDNE_USCOREPersonType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CIDNE_USCOREPersonType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CIDNE_USCOREPersonType %p -> %p\n", q, p));
	*(ns2__CIDNE_USCOREPersonType*)p = *(ns2__CIDNE_USCOREPersonType*)q;
}

void ns2__PeopleType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PeopleType::Type = NULL;
	this->ns2__PeopleType::Type2 = NULL;
	this->ns2__PeopleType::Rank = NULL;
	this->ns2__PeopleType::Gender = NULL;
	soap_default_std__string(soap, &this->ns2__PeopleType::Company);
	soap_default_std__string(soap, &this->ns2__PeopleType::BusinessPhone);
	soap_default_std__string(soap, &this->ns2__PeopleType::MobilePhone);
	soap_default_std__string(soap, &this->ns2__PeopleType::Fax);
	soap_default_std__string(soap, &this->ns2__PeopleType::PrimayEmail);
	soap_default_std__string(soap, &this->ns2__PeopleType::SecondaryEmail);
	this->ns2__PeopleType::DutyStatus = NULL;
	this->ns2__PeopleType::PhysicalStatus = NULL;
	this->ns2__PeopleType::PhysicalStatus2 = NULL;
	soap_default_std__string(soap, &this->ns2__PeopleType::Summary);
	/* transient soap skipped */
}

void ns2__PeopleType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__PeopleTypeType(soap, &this->ns2__PeopleType::Type);
	soap_serialize_PointerTons2__PeopleType2Type(soap, &this->ns2__PeopleType::Type2);
	soap_serialize_PointerTons2__RankType(soap, &this->ns2__PeopleType::Rank);
	soap_serialize_PointerTons2__GenderType(soap, &this->ns2__PeopleType::Gender);
	soap_embedded(soap, &this->ns2__PeopleType::Company, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__PeopleType::Company);
	soap_embedded(soap, &this->ns2__PeopleType::BusinessPhone, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__PeopleType::BusinessPhone);
	soap_embedded(soap, &this->ns2__PeopleType::MobilePhone, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__PeopleType::MobilePhone);
	soap_embedded(soap, &this->ns2__PeopleType::Fax, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__PeopleType::Fax);
	soap_embedded(soap, &this->ns2__PeopleType::PrimayEmail, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__PeopleType::PrimayEmail);
	soap_embedded(soap, &this->ns2__PeopleType::SecondaryEmail, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__PeopleType::SecondaryEmail);
	soap_serialize_PointerTons2__DutyStatusType(soap, &this->ns2__PeopleType::DutyStatus);
	soap_serialize_PointerTons2__PhysicalStatusType(soap, &this->ns2__PeopleType::PhysicalStatus);
	soap_serialize_PointerTons2__PhysicalStatus2Type(soap, &this->ns2__PeopleType::PhysicalStatus2);
	soap_embedded(soap, &this->ns2__PeopleType::Summary, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__PeopleType::Summary);
	/* transient soap skipped */
}

int ns2__PeopleType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PeopleType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PeopleType(struct soap *soap, const char *tag, int id, const ns2__PeopleType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PeopleType), type))
		return soap->error;
	if (soap_out_PointerTons2__PeopleTypeType(soap, "ns2:Type", -1, &(a->ns2__PeopleType::Type), ""))
		return soap->error;
	if (soap_out_PointerTons2__PeopleType2Type(soap, "ns2:Type2", -1, &(a->ns2__PeopleType::Type2), ""))
		return soap->error;
	if (soap_out_PointerTons2__RankType(soap, "ns2:Rank", -1, &(a->ns2__PeopleType::Rank), ""))
		return soap->error;
	if (soap_out_PointerTons2__GenderType(soap, "ns2:Gender", -1, &(a->ns2__PeopleType::Gender), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Company", -1, &(a->ns2__PeopleType::Company), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:BusinessPhone", -1, &(a->ns2__PeopleType::BusinessPhone), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:MobilePhone", -1, &(a->ns2__PeopleType::MobilePhone), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Fax", -1, &(a->ns2__PeopleType::Fax), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:PrimayEmail", -1, &(a->ns2__PeopleType::PrimayEmail), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:SecondaryEmail", -1, &(a->ns2__PeopleType::SecondaryEmail), ""))
		return soap->error;
	if (soap_out_PointerTons2__DutyStatusType(soap, "ns2:DutyStatus", -1, &(a->ns2__PeopleType::DutyStatus), ""))
		return soap->error;
	if (soap_out_PointerTons2__PhysicalStatusType(soap, "ns2:PhysicalStatus", -1, &(a->ns2__PeopleType::PhysicalStatus), ""))
		return soap->error;
	if (soap_out_PointerTons2__PhysicalStatus2Type(soap, "ns2:PhysicalStatus2", -1, &(a->ns2__PeopleType::PhysicalStatus2), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:Summary", -1, &(a->ns2__PeopleType::Summary), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__PeopleType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PeopleType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PeopleType * SOAP_FMAC4 soap_in_ns2__PeopleType(struct soap *soap, const char *tag, ns2__PeopleType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PeopleType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PeopleType, sizeof(ns2__PeopleType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__PeopleType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__PeopleType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Type21 = 1;
	size_t soap_flag_Rank1 = 1;
	size_t soap_flag_Gender1 = 1;
	size_t soap_flag_Company1 = 1;
	size_t soap_flag_BusinessPhone1 = 1;
	size_t soap_flag_MobilePhone1 = 1;
	size_t soap_flag_Fax1 = 1;
	size_t soap_flag_PrimayEmail1 = 1;
	size_t soap_flag_SecondaryEmail1 = 1;
	size_t soap_flag_DutyStatus1 = 1;
	size_t soap_flag_PhysicalStatus1 = 1;
	size_t soap_flag_PhysicalStatus21 = 1;
	size_t soap_flag_Summary1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PeopleTypeType(soap, "ns2:Type", &(a->ns2__PeopleType::Type), "ns2:PeopleTypeType"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap_flag_Type21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PeopleType2Type(soap, "ns2:Type2", &(a->ns2__PeopleType::Type2), "ns2:PeopleType2Type"))
				{	soap_flag_Type21--;
					continue;
				}
			if (soap_flag_Rank1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RankType(soap, "ns2:Rank", &(a->ns2__PeopleType::Rank), "ns2:RankType"))
				{	soap_flag_Rank1--;
					continue;
				}
			if (soap_flag_Gender1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__GenderType(soap, "ns2:Gender", &(a->ns2__PeopleType::Gender), "ns2:GenderType"))
				{	soap_flag_Gender1--;
					continue;
				}
			if (soap_flag_Company1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Company", &(a->ns2__PeopleType::Company), "xsd:string"))
				{	soap_flag_Company1--;
					continue;
				}
			if (soap_flag_BusinessPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:BusinessPhone", &(a->ns2__PeopleType::BusinessPhone), "xsd:string"))
				{	soap_flag_BusinessPhone1--;
					continue;
				}
			if (soap_flag_MobilePhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:MobilePhone", &(a->ns2__PeopleType::MobilePhone), "xsd:string"))
				{	soap_flag_MobilePhone1--;
					continue;
				}
			if (soap_flag_Fax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Fax", &(a->ns2__PeopleType::Fax), "xsd:string"))
				{	soap_flag_Fax1--;
					continue;
				}
			if (soap_flag_PrimayEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:PrimayEmail", &(a->ns2__PeopleType::PrimayEmail), "xsd:string"))
				{	soap_flag_PrimayEmail1--;
					continue;
				}
			if (soap_flag_SecondaryEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:SecondaryEmail", &(a->ns2__PeopleType::SecondaryEmail), "xsd:string"))
				{	soap_flag_SecondaryEmail1--;
					continue;
				}
			if (soap_flag_DutyStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DutyStatusType(soap, "ns2:DutyStatus", &(a->ns2__PeopleType::DutyStatus), "ns2:DutyStatusType"))
				{	soap_flag_DutyStatus1--;
					continue;
				}
			if (soap_flag_PhysicalStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PhysicalStatusType(soap, "ns2:PhysicalStatus", &(a->ns2__PeopleType::PhysicalStatus), "ns2:PhysicalStatusType"))
				{	soap_flag_PhysicalStatus1--;
					continue;
				}
			if (soap_flag_PhysicalStatus21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PhysicalStatus2Type(soap, "ns2:PhysicalStatus2", &(a->ns2__PeopleType::PhysicalStatus2), "ns2:PhysicalStatus2Type"))
				{	soap_flag_PhysicalStatus21--;
					continue;
				}
			if (soap_flag_Summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:Summary", &(a->ns2__PeopleType::Summary), "xsd:string"))
				{	soap_flag_Summary1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PeopleType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PeopleType, 0, sizeof(ns2__PeopleType), 0, soap_copy_ns2__PeopleType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Company1 > 0 || soap_flag_BusinessPhone1 > 0 || soap_flag_MobilePhone1 > 0 || soap_flag_Fax1 > 0 || soap_flag_PrimayEmail1 > 0 || soap_flag_SecondaryEmail1 > 0 || soap_flag_Summary1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__PeopleType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__PeopleType);
	if (this->soap_out(soap, tag?tag:"ns2:PeopleType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PeopleType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PeopleType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PeopleType * SOAP_FMAC4 soap_get_ns2__PeopleType(struct soap *soap, ns2__PeopleType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PeopleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__PeopleType * SOAP_FMAC2 soap_instantiate_ns2__PeopleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PeopleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__PeopleType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__PeopleType);
		if (size)
			*size = sizeof(ns2__PeopleType);
		((ns2__PeopleType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__PeopleType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__PeopleType);
		for (int i = 0; i < n; i++)
			((ns2__PeopleType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__PeopleType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__PeopleType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__PeopleType %p -> %p\n", q, p));
	*(ns2__PeopleType*)p = *(ns2__PeopleType*)q;
}

void ns2__SpecialReportType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__SpecialReportType::__union_SpecialReportType = 0;
	this->ns2__ReportType::ns3__timePeriod = NULL;
	this->ns2__ReportType::locationList = NULL;
	this->ns2__ReportType::children = NULL;
	this->ns2__ReportType::parents = NULL;
	this->ns2__ReportType::annotations = NULL;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__SpecialReportType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_SpecialReportType(soap, this->ns2__SpecialReportType::__union_SpecialReportType, &this->ns2__SpecialReportType::union_SpecialReportType);
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__ReportType::ns3__timePeriod);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__ReportType::locationList);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ReportType::children);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ReportType::parents);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ReportType::annotations);
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__SpecialReportType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SpecialReportType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SpecialReportType(struct soap *soap, const char *tag, int id, const ns2__SpecialReportType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SpecialReportType), "ns2:SpecialReportType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__ReportType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__ReportType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__ReportType::children), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", -1, &(a->ns2__ReportType::parents), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", -1, &(a->ns2__ReportType::annotations), ""))
		return soap->error;
	if (soap_out__ns2__union_SpecialReportType(soap, a->ns2__SpecialReportType::__union_SpecialReportType, &a->ns2__SpecialReportType::union_SpecialReportType))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__SpecialReportType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SpecialReportType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SpecialReportType * SOAP_FMAC4 soap_in_ns2__SpecialReportType(struct soap *soap, const char *tag, ns2__SpecialReportType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SpecialReportType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SpecialReportType, sizeof(ns2__SpecialReportType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SpecialReportType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SpecialReportType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory3 = 1;
	size_t soap_flag_localUpdateTime3 = 1;
	size_t soap_flag_securityInfo3 = 1;
	size_t soap_flag_title3 = 1;
	size_t soap_flag_description3 = 1;
	size_t soap_flag_unit3 = 1;
	size_t soap_flag_extId3 = 1;
	size_t soap_flag_ns3__timePeriod2 = 1;
	size_t soap_flag_locationList2 = 1;
	size_t soap_flag_children2 = 1;
	size_t soap_flag_parents2 = 1;
	size_t soap_flag_annotations2 = 1;
	size_t soap_flag_union_SpecialReportType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory3--;
					continue;
				}
			if (soap_flag_localUpdateTime3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime3--;
					continue;
				}
			if (soap_flag_securityInfo3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo3--;
					continue;
				}
			if (soap_flag_title3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title3--;
					continue;
				}
			if (soap_flag_description3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description3--;
					continue;
				}
			if (soap_flag_unit3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit3--;
					continue;
				}
			if (soap_flag_extId3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_ns3__timePeriod2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__ReportType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod2--;
					continue;
				}
			if (soap_flag_locationList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__ReportType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList2--;
					continue;
				}
			if (soap_flag_children2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__ReportType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children2--;
					continue;
				}
			if (soap_flag_parents2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", &(a->ns2__ReportType::parents), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_parents2--;
					continue;
				}
			if (soap_flag_annotations2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", &(a->ns2__ReportType::annotations), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_annotations2--;
					continue;
				}
			if (soap_flag_union_SpecialReportType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_SpecialReportType(soap, &a->ns2__SpecialReportType::__union_SpecialReportType, &a->ns2__SpecialReportType::union_SpecialReportType))
				{	soap_flag_union_SpecialReportType1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SpecialReportType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SpecialReportType, 0, sizeof(ns2__SpecialReportType), 0, soap_copy_ns2__SpecialReportType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory3 > 0 || soap_flag_localUpdateTime3 > 0 || soap_flag_securityInfo3 > 0 || soap_flag_title3 > 0 || soap_flag_ns3__timePeriod2 > 0 || soap_flag_union_SpecialReportType1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SpecialReportType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SpecialReportType);
	if (this->soap_out(soap, tag?tag:"ns2:SpecialReportType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SpecialReportType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SpecialReportType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SpecialReportType * SOAP_FMAC4 soap_get_ns2__SpecialReportType(struct soap *soap, ns2__SpecialReportType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SpecialReportType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SpecialReportType * SOAP_FMAC2 soap_instantiate_ns2__SpecialReportType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SpecialReportType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SpecialReportType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialReportType);
		if (size)
			*size = sizeof(ns2__SpecialReportType);
		((ns2__SpecialReportType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialReportType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SpecialReportType);
		for (int i = 0; i < n; i++)
			((ns2__SpecialReportType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SpecialReportType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SpecialReportType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SpecialReportType %p -> %p\n", q, p));
	*(ns2__SpecialReportType*)p = *(ns2__SpecialReportType*)q;
}

void ns2__SpecialReportUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__SpecialReportUserPropertiesType::__union_SpecialReportUserPropertiesType = 0;
	this->ns2__ReportUserPropertiesType::ns3__timePeriod = NULL;
	this->ns2__ReportUserPropertiesType::locationList = NULL;
	this->ns2__ReportUserPropertiesType::children = NULL;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__SpecialReportUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_SpecialReportUserPropertiesType(soap, this->ns2__SpecialReportUserPropertiesType::__union_SpecialReportUserPropertiesType, &this->ns2__SpecialReportUserPropertiesType::union_SpecialReportUserPropertiesType);
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__ReportUserPropertiesType::ns3__timePeriod);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__ReportUserPropertiesType::locationList);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ReportUserPropertiesType::children);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__SpecialReportUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SpecialReportUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SpecialReportUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__SpecialReportUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SpecialReportUserPropertiesType), "ns2:SpecialReportUserPropertiesType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__ReportUserPropertiesType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__ReportUserPropertiesType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__ReportUserPropertiesType::children), ""))
		return soap->error;
	if (soap_out__ns2__union_SpecialReportUserPropertiesType(soap, a->ns2__SpecialReportUserPropertiesType::__union_SpecialReportUserPropertiesType, &a->ns2__SpecialReportUserPropertiesType::union_SpecialReportUserPropertiesType))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__SpecialReportUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SpecialReportUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SpecialReportUserPropertiesType * SOAP_FMAC4 soap_in_ns2__SpecialReportUserPropertiesType(struct soap *soap, const char *tag, ns2__SpecialReportUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SpecialReportUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SpecialReportUserPropertiesType, sizeof(ns2__SpecialReportUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SpecialReportUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SpecialReportUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo3 = 1;
	size_t soap_flag_title3 = 1;
	size_t soap_flag_description3 = 1;
	size_t soap_flag_unit3 = 1;
	size_t soap_flag_extId3 = 1;
	size_t soap_flag_ns3__timePeriod2 = 1;
	size_t soap_flag_locationList2 = 1;
	size_t soap_flag_children2 = 1;
	size_t soap_flag_union_SpecialReportUserPropertiesType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo3--;
					continue;
				}
			if (soap_flag_title3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title3--;
					continue;
				}
			if (soap_flag_description3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description3--;
					continue;
				}
			if (soap_flag_unit3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit3--;
					continue;
				}
			if (soap_flag_extId3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_ns3__timePeriod2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__ReportUserPropertiesType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod2--;
					continue;
				}
			if (soap_flag_locationList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__ReportUserPropertiesType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList2--;
					continue;
				}
			if (soap_flag_children2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__ReportUserPropertiesType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children2--;
					continue;
				}
			if (soap_flag_union_SpecialReportUserPropertiesType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_SpecialReportUserPropertiesType(soap, &a->ns2__SpecialReportUserPropertiesType::__union_SpecialReportUserPropertiesType, &a->ns2__SpecialReportUserPropertiesType::union_SpecialReportUserPropertiesType))
				{	soap_flag_union_SpecialReportUserPropertiesType1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SpecialReportUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SpecialReportUserPropertiesType, 0, sizeof(ns2__SpecialReportUserPropertiesType), 0, soap_copy_ns2__SpecialReportUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo3 > 0 || soap_flag_title3 > 0 || soap_flag_ns3__timePeriod2 > 0 || soap_flag_union_SpecialReportUserPropertiesType1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SpecialReportUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SpecialReportUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:SpecialReportUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SpecialReportUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SpecialReportUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SpecialReportUserPropertiesType * SOAP_FMAC4 soap_get_ns2__SpecialReportUserPropertiesType(struct soap *soap, ns2__SpecialReportUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SpecialReportUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SpecialReportUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__SpecialReportUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SpecialReportUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SpecialReportUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialReportUserPropertiesType);
		if (size)
			*size = sizeof(ns2__SpecialReportUserPropertiesType);
		((ns2__SpecialReportUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialReportUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SpecialReportUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__SpecialReportUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SpecialReportUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SpecialReportUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SpecialReportUserPropertiesType %p -> %p\n", q, p));
	*(ns2__SpecialReportUserPropertiesType*)p = *(ns2__SpecialReportUserPropertiesType*)q;
}

void ns2__DeletedType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__DeletedType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__DeletedType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DeletedType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DeletedType(struct soap *soap, const char *tag, int id, const ns2__DeletedType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DeletedType), "ns2:DeletedType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DeletedType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DeletedType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DeletedType * SOAP_FMAC4 soap_in_ns2__DeletedType(struct soap *soap, const char *tag, ns2__DeletedType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DeletedType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DeletedType, sizeof(ns2__DeletedType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DeletedType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DeletedType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory2 = 1;
	size_t soap_flag_localUpdateTime2 = 1;
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory2--;
					continue;
				}
			if (soap_flag_localUpdateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime2--;
					continue;
				}
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DeletedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DeletedType, 0, sizeof(ns2__DeletedType), 0, soap_copy_ns2__DeletedType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory2 > 0 || soap_flag_localUpdateTime2 > 0 || soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__DeletedType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DeletedType);
	if (this->soap_out(soap, tag?tag:"ns2:DeletedType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DeletedType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DeletedType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DeletedType * SOAP_FMAC4 soap_get_ns2__DeletedType(struct soap *soap, ns2__DeletedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DeletedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DeletedType * SOAP_FMAC2 soap_instantiate_ns2__DeletedType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DeletedType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DeletedType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DeletedType);
		if (size)
			*size = sizeof(ns2__DeletedType);
		((ns2__DeletedType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__DeletedType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__DeletedType);
		for (int i = 0; i < n; i++)
			((ns2__DeletedType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__DeletedType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DeletedType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DeletedType %p -> %p\n", q, p));
	*(ns2__DeletedType*)p = *(ns2__DeletedType*)q;
}

void ns2__ForumPostType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ForumPostType::children = NULL;
	this->ns2__ForumPostType::parent = NULL;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__ForumPostType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ForumPostType::children);
	soap_serialize_PointerTons2__AbstractContentReferenceHolderType(soap, &this->ns2__ForumPostType::parent);
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__ForumPostType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ForumPostType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ForumPostType(struct soap *soap, const char *tag, int id, const ns2__ForumPostType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ForumPostType), "ns2:ForumPostType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__ForumPostType::children), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceHolderType(soap, "ns2:parent", -1, &(a->ns2__ForumPostType::parent), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ForumPostType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ForumPostType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ForumPostType * SOAP_FMAC4 soap_in_ns2__ForumPostType(struct soap *soap, const char *tag, ns2__ForumPostType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ForumPostType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ForumPostType, sizeof(ns2__ForumPostType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ForumPostType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ForumPostType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory2 = 1;
	size_t soap_flag_localUpdateTime2 = 1;
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_children1 = 1;
	size_t soap_flag_parent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory2--;
					continue;
				}
			if (soap_flag_localUpdateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime2--;
					continue;
				}
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__ForumPostType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap_flag_parent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceHolderType(soap, "ns2:parent", &(a->ns2__ForumPostType::parent), "ns2:AbstractContentReferenceHolderType"))
				{	soap_flag_parent1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ForumPostType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ForumPostType, 0, sizeof(ns2__ForumPostType), 0, soap_copy_ns2__ForumPostType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory2 > 0 || soap_flag_localUpdateTime2 > 0 || soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_parent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ForumPostType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ForumPostType);
	if (this->soap_out(soap, tag?tag:"ns2:ForumPostType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ForumPostType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ForumPostType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ForumPostType * SOAP_FMAC4 soap_get_ns2__ForumPostType(struct soap *soap, ns2__ForumPostType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ForumPostType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ForumPostType * SOAP_FMAC2 soap_instantiate_ns2__ForumPostType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ForumPostType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ForumPostType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ForumPostType);
		if (size)
			*size = sizeof(ns2__ForumPostType);
		((ns2__ForumPostType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ForumPostType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ForumPostType);
		for (int i = 0; i < n; i++)
			((ns2__ForumPostType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ForumPostType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ForumPostType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ForumPostType %p -> %p\n", q, p));
	*(ns2__ForumPostType*)p = *(ns2__ForumPostType*)q;
}

void ns2__ForumPostUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ForumPostUserPropertiesType::children = NULL;
	this->ns2__ForumPostUserPropertiesType::parent = NULL;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__ForumPostUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ForumPostUserPropertiesType::children);
	soap_serialize_PointerTons2__AbstractContentReferenceHolderType(soap, &this->ns2__ForumPostUserPropertiesType::parent);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__ForumPostUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ForumPostUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ForumPostUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__ForumPostUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ForumPostUserPropertiesType), "ns2:ForumPostUserPropertiesType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__ForumPostUserPropertiesType::children), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceHolderType(soap, "ns2:parent", -1, &(a->ns2__ForumPostUserPropertiesType::parent), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ForumPostUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ForumPostUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ForumPostUserPropertiesType * SOAP_FMAC4 soap_in_ns2__ForumPostUserPropertiesType(struct soap *soap, const char *tag, ns2__ForumPostUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ForumPostUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ForumPostUserPropertiesType, sizeof(ns2__ForumPostUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ForumPostUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ForumPostUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_children1 = 1;
	size_t soap_flag_parent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__ForumPostUserPropertiesType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap_flag_parent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceHolderType(soap, "ns2:parent", &(a->ns2__ForumPostUserPropertiesType::parent), "ns2:AbstractContentReferenceHolderType"))
				{	soap_flag_parent1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ForumPostUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ForumPostUserPropertiesType, 0, sizeof(ns2__ForumPostUserPropertiesType), 0, soap_copy_ns2__ForumPostUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_parent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ForumPostUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ForumPostUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:ForumPostUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ForumPostUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ForumPostUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ForumPostUserPropertiesType * SOAP_FMAC4 soap_get_ns2__ForumPostUserPropertiesType(struct soap *soap, ns2__ForumPostUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ForumPostUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ForumPostUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__ForumPostUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ForumPostUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ForumPostUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ForumPostUserPropertiesType);
		if (size)
			*size = sizeof(ns2__ForumPostUserPropertiesType);
		((ns2__ForumPostUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ForumPostUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ForumPostUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__ForumPostUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ForumPostUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ForumPostUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ForumPostUserPropertiesType %p -> %p\n", q, p));
	*(ns2__ForumPostUserPropertiesType*)p = *(ns2__ForumPostUserPropertiesType*)q;
}

void ns2__ForumTopicType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ForumTopicType::categoryList = NULL;
	this->ns2__ForumTopicType::children = NULL;
	this->ns2__ForumTopicType::posts = NULL;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__ForumTopicType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CategoryListType(soap, &this->ns2__ForumTopicType::categoryList);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ForumTopicType::children);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ForumTopicType::posts);
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__ForumTopicType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ForumTopicType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ForumTopicType(struct soap *soap, const char *tag, int id, const ns2__ForumTopicType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ForumTopicType), "ns2:ForumTopicType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__CategoryListType(soap, "ns2:categoryList", -1, &(a->ns2__ForumTopicType::categoryList), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__ForumTopicType::children), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:posts", -1, &(a->ns2__ForumTopicType::posts), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ForumTopicType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ForumTopicType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ForumTopicType * SOAP_FMAC4 soap_in_ns2__ForumTopicType(struct soap *soap, const char *tag, ns2__ForumTopicType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ForumTopicType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ForumTopicType, sizeof(ns2__ForumTopicType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ForumTopicType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ForumTopicType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory2 = 1;
	size_t soap_flag_localUpdateTime2 = 1;
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_categoryList1 = 1;
	size_t soap_flag_children1 = 1;
	size_t soap_flag_posts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory2--;
					continue;
				}
			if (soap_flag_localUpdateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime2--;
					continue;
				}
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_categoryList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CategoryListType(soap, "ns2:categoryList", &(a->ns2__ForumTopicType::categoryList), "ns2:CategoryListType"))
				{	soap_flag_categoryList1--;
					continue;
				}
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__ForumTopicType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap_flag_posts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:posts", &(a->ns2__ForumTopicType::posts), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_posts1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ForumTopicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ForumTopicType, 0, sizeof(ns2__ForumTopicType), 0, soap_copy_ns2__ForumTopicType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory2 > 0 || soap_flag_localUpdateTime2 > 0 || soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_categoryList1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ForumTopicType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ForumTopicType);
	if (this->soap_out(soap, tag?tag:"ns2:ForumTopicType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ForumTopicType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ForumTopicType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ForumTopicType * SOAP_FMAC4 soap_get_ns2__ForumTopicType(struct soap *soap, ns2__ForumTopicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ForumTopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ForumTopicType * SOAP_FMAC2 soap_instantiate_ns2__ForumTopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ForumTopicType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ForumTopicType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ForumTopicType);
		if (size)
			*size = sizeof(ns2__ForumTopicType);
		((ns2__ForumTopicType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ForumTopicType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ForumTopicType);
		for (int i = 0; i < n; i++)
			((ns2__ForumTopicType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ForumTopicType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ForumTopicType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ForumTopicType %p -> %p\n", q, p));
	*(ns2__ForumTopicType*)p = *(ns2__ForumTopicType*)q;
}

void ns2__ForumTopicUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ForumTopicUserPropertiesType::categoryList = NULL;
	this->ns2__ForumTopicUserPropertiesType::children = NULL;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__ForumTopicUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CategoryListType(soap, &this->ns2__ForumTopicUserPropertiesType::categoryList);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ForumTopicUserPropertiesType::children);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__ForumTopicUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ForumTopicUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ForumTopicUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__ForumTopicUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ForumTopicUserPropertiesType), "ns2:ForumTopicUserPropertiesType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__CategoryListType(soap, "ns2:categoryList", -1, &(a->ns2__ForumTopicUserPropertiesType::categoryList), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__ForumTopicUserPropertiesType::children), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ForumTopicUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ForumTopicUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ForumTopicUserPropertiesType * SOAP_FMAC4 soap_in_ns2__ForumTopicUserPropertiesType(struct soap *soap, const char *tag, ns2__ForumTopicUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ForumTopicUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ForumTopicUserPropertiesType, sizeof(ns2__ForumTopicUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ForumTopicUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ForumTopicUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_categoryList1 = 1;
	size_t soap_flag_children1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_categoryList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CategoryListType(soap, "ns2:categoryList", &(a->ns2__ForumTopicUserPropertiesType::categoryList), "ns2:CategoryListType"))
				{	soap_flag_categoryList1--;
					continue;
				}
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__ForumTopicUserPropertiesType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ForumTopicUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ForumTopicUserPropertiesType, 0, sizeof(ns2__ForumTopicUserPropertiesType), 0, soap_copy_ns2__ForumTopicUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_categoryList1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ForumTopicUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ForumTopicUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:ForumTopicUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ForumTopicUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ForumTopicUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ForumTopicUserPropertiesType * SOAP_FMAC4 soap_get_ns2__ForumTopicUserPropertiesType(struct soap *soap, ns2__ForumTopicUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ForumTopicUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ForumTopicUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__ForumTopicUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ForumTopicUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ForumTopicUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ForumTopicUserPropertiesType);
		if (size)
			*size = sizeof(ns2__ForumTopicUserPropertiesType);
		((ns2__ForumTopicUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ForumTopicUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ForumTopicUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__ForumTopicUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ForumTopicUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ForumTopicUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ForumTopicUserPropertiesType %p -> %p\n", q, p));
	*(ns2__ForumTopicUserPropertiesType*)p = *(ns2__ForumTopicUserPropertiesType*)q;
}

void ns2__CollectionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CollectionType::children = NULL;
	this->ns2__CollectionType::parents = NULL;
	this->ns2__CollectionType::annotations = NULL;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__CollectionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__CollectionType::children);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__CollectionType::parents);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__CollectionType::annotations);
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__CollectionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CollectionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CollectionType(struct soap *soap, const char *tag, int id, const ns2__CollectionType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CollectionType), "ns2:CollectionType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__CollectionType::children), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", -1, &(a->ns2__CollectionType::parents), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", -1, &(a->ns2__CollectionType::annotations), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CollectionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CollectionType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CollectionType * SOAP_FMAC4 soap_in_ns2__CollectionType(struct soap *soap, const char *tag, ns2__CollectionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CollectionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CollectionType, sizeof(ns2__CollectionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CollectionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CollectionType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory2 = 1;
	size_t soap_flag_localUpdateTime2 = 1;
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_children1 = 1;
	size_t soap_flag_parents1 = 1;
	size_t soap_flag_annotations1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory2--;
					continue;
				}
			if (soap_flag_localUpdateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime2--;
					continue;
				}
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__CollectionType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap_flag_parents1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", &(a->ns2__CollectionType::parents), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_parents1--;
					continue;
				}
			if (soap_flag_annotations1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", &(a->ns2__CollectionType::annotations), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_annotations1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CollectionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CollectionType, 0, sizeof(ns2__CollectionType), 0, soap_copy_ns2__CollectionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory2 > 0 || soap_flag_localUpdateTime2 > 0 || soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__CollectionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CollectionType);
	if (this->soap_out(soap, tag?tag:"ns2:CollectionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CollectionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CollectionType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CollectionType * SOAP_FMAC4 soap_get_ns2__CollectionType(struct soap *soap, ns2__CollectionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CollectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CollectionType * SOAP_FMAC2 soap_instantiate_ns2__CollectionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CollectionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CollectionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:SpecialCollectionType"))
	{	cp->type = SOAP_TYPE_ns2__SpecialCollectionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialCollectionType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SpecialCollectionType);
			((ns2__SpecialCollectionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialCollectionType[n]);
			if (size)
				*size = n * sizeof(ns2__SpecialCollectionType);
			for (int i = 0; i < n; i++)
				((ns2__SpecialCollectionType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SpecialCollectionType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CollectionType);
		if (size)
			*size = sizeof(ns2__CollectionType);
		((ns2__CollectionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CollectionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CollectionType);
		for (int i = 0; i < n; i++)
			((ns2__CollectionType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CollectionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CollectionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CollectionType %p -> %p\n", q, p));
	*(ns2__CollectionType*)p = *(ns2__CollectionType*)q;
}

void ns2__CollectionUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CollectionUserPropertiesType::children = NULL;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__CollectionUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__CollectionUserPropertiesType::children);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__CollectionUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CollectionUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CollectionUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__CollectionUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CollectionUserPropertiesType), "ns2:CollectionUserPropertiesType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__CollectionUserPropertiesType::children), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CollectionUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CollectionUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CollectionUserPropertiesType * SOAP_FMAC4 soap_in_ns2__CollectionUserPropertiesType(struct soap *soap, const char *tag, ns2__CollectionUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CollectionUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CollectionUserPropertiesType, sizeof(ns2__CollectionUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CollectionUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CollectionUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_children1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__CollectionUserPropertiesType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CollectionUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CollectionUserPropertiesType, 0, sizeof(ns2__CollectionUserPropertiesType), 0, soap_copy_ns2__CollectionUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__CollectionUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CollectionUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:CollectionUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CollectionUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CollectionUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CollectionUserPropertiesType * SOAP_FMAC4 soap_get_ns2__CollectionUserPropertiesType(struct soap *soap, ns2__CollectionUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CollectionUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CollectionUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__CollectionUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CollectionUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CollectionUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:SpecialCollectionUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialCollectionUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SpecialCollectionUserPropertiesType);
			((ns2__SpecialCollectionUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialCollectionUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__SpecialCollectionUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__SpecialCollectionUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SpecialCollectionUserPropertiesType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CollectionUserPropertiesType);
		if (size)
			*size = sizeof(ns2__CollectionUserPropertiesType);
		((ns2__CollectionUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CollectionUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CollectionUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__CollectionUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CollectionUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CollectionUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CollectionUserPropertiesType %p -> %p\n", q, p));
	*(ns2__CollectionUserPropertiesType*)p = *(ns2__CollectionUserPropertiesType*)q;
}

void ns2__ReportType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ReportType::ns3__timePeriod = NULL;
	this->ns2__ReportType::locationList = NULL;
	this->ns2__ReportType::children = NULL;
	this->ns2__ReportType::parents = NULL;
	this->ns2__ReportType::annotations = NULL;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__ReportType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__ReportType::ns3__timePeriod);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__ReportType::locationList);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ReportType::children);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ReportType::parents);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ReportType::annotations);
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__ReportType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ReportType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReportType(struct soap *soap, const char *tag, int id, const ns2__ReportType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReportType), "ns2:ReportType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__ReportType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__ReportType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__ReportType::children), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", -1, &(a->ns2__ReportType::parents), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", -1, &(a->ns2__ReportType::annotations), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ReportType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ReportType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ReportType * SOAP_FMAC4 soap_in_ns2__ReportType(struct soap *soap, const char *tag, ns2__ReportType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ReportType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReportType, sizeof(ns2__ReportType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ReportType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ReportType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory2 = 1;
	size_t soap_flag_localUpdateTime2 = 1;
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_ns3__timePeriod1 = 1;
	size_t soap_flag_locationList1 = 1;
	size_t soap_flag_children1 = 1;
	size_t soap_flag_parents1 = 1;
	size_t soap_flag_annotations1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory2--;
					continue;
				}
			if (soap_flag_localUpdateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime2--;
					continue;
				}
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_ns3__timePeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__ReportType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod1--;
					continue;
				}
			if (soap_flag_locationList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__ReportType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList1--;
					continue;
				}
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__ReportType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap_flag_parents1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", &(a->ns2__ReportType::parents), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_parents1--;
					continue;
				}
			if (soap_flag_annotations1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", &(a->ns2__ReportType::annotations), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_annotations1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ReportType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReportType, 0, sizeof(ns2__ReportType), 0, soap_copy_ns2__ReportType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory2 > 0 || soap_flag_localUpdateTime2 > 0 || soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_ns3__timePeriod1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ReportType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ReportType);
	if (this->soap_out(soap, tag?tag:"ns2:ReportType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ReportType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ReportType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ReportType * SOAP_FMAC4 soap_get_ns2__ReportType(struct soap *soap, ns2__ReportType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReportType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ReportType * SOAP_FMAC2 soap_instantiate_ns2__ReportType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ReportType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ReportType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:SpecialReportType"))
	{	cp->type = SOAP_TYPE_ns2__SpecialReportType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialReportType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SpecialReportType);
			((ns2__SpecialReportType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialReportType[n]);
			if (size)
				*size = n * sizeof(ns2__SpecialReportType);
			for (int i = 0; i < n; i++)
				((ns2__SpecialReportType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SpecialReportType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ReportType);
		if (size)
			*size = sizeof(ns2__ReportType);
		((ns2__ReportType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ReportType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ReportType);
		for (int i = 0; i < n; i++)
			((ns2__ReportType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ReportType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ReportType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ReportType %p -> %p\n", q, p));
	*(ns2__ReportType*)p = *(ns2__ReportType*)q;
}

void ns2__ReportUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ReportUserPropertiesType::ns3__timePeriod = NULL;
	this->ns2__ReportUserPropertiesType::locationList = NULL;
	this->ns2__ReportUserPropertiesType::children = NULL;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__ReportUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__ReportUserPropertiesType::ns3__timePeriod);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__ReportUserPropertiesType::locationList);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__ReportUserPropertiesType::children);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__ReportUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ReportUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReportUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__ReportUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReportUserPropertiesType), "ns2:ReportUserPropertiesType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__ReportUserPropertiesType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__ReportUserPropertiesType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__ReportUserPropertiesType::children), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ReportUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ReportUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ReportUserPropertiesType * SOAP_FMAC4 soap_in_ns2__ReportUserPropertiesType(struct soap *soap, const char *tag, ns2__ReportUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ReportUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReportUserPropertiesType, sizeof(ns2__ReportUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ReportUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ReportUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_ns3__timePeriod1 = 1;
	size_t soap_flag_locationList1 = 1;
	size_t soap_flag_children1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_ns3__timePeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__ReportUserPropertiesType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod1--;
					continue;
				}
			if (soap_flag_locationList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__ReportUserPropertiesType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList1--;
					continue;
				}
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__ReportUserPropertiesType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ReportUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReportUserPropertiesType, 0, sizeof(ns2__ReportUserPropertiesType), 0, soap_copy_ns2__ReportUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_ns3__timePeriod1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ReportUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ReportUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:ReportUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ReportUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ReportUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ReportUserPropertiesType * SOAP_FMAC4 soap_get_ns2__ReportUserPropertiesType(struct soap *soap, ns2__ReportUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReportUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ReportUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__ReportUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ReportUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ReportUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:SpecialReportUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__SpecialReportUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialReportUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SpecialReportUserPropertiesType);
			((ns2__SpecialReportUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialReportUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__SpecialReportUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__SpecialReportUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SpecialReportUserPropertiesType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ReportUserPropertiesType);
		if (size)
			*size = sizeof(ns2__ReportUserPropertiesType);
		((ns2__ReportUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ReportUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ReportUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__ReportUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ReportUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ReportUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ReportUserPropertiesType %p -> %p\n", q, p));
	*(ns2__ReportUserPropertiesType*)p = *(ns2__ReportUserPropertiesType*)q;
}

void ns2__PlaceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PlaceType::categoryList = NULL;
	this->ns2__PlaceType::locationList = NULL;
	this->ns2__PlaceType::ns3__timePeriod = NULL;
	this->ns2__PlaceType::children = NULL;
	this->ns2__PlaceType::parents = NULL;
	this->ns2__PlaceType::annotations = NULL;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__PlaceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CategoryListType(soap, &this->ns2__PlaceType::categoryList);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__PlaceType::locationList);
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__PlaceType::ns3__timePeriod);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__PlaceType::children);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__PlaceType::parents);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__PlaceType::annotations);
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__PlaceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PlaceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PlaceType(struct soap *soap, const char *tag, int id, const ns2__PlaceType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PlaceType), "ns2:PlaceType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__CategoryListType(soap, "ns2:categoryList", -1, &(a->ns2__PlaceType::categoryList), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__PlaceType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__PlaceType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__PlaceType::children), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", -1, &(a->ns2__PlaceType::parents), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", -1, &(a->ns2__PlaceType::annotations), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PlaceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PlaceType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PlaceType * SOAP_FMAC4 soap_in_ns2__PlaceType(struct soap *soap, const char *tag, ns2__PlaceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PlaceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PlaceType, sizeof(ns2__PlaceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__PlaceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__PlaceType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory2 = 1;
	size_t soap_flag_localUpdateTime2 = 1;
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_categoryList1 = 1;
	size_t soap_flag_locationList1 = 1;
	size_t soap_flag_ns3__timePeriod1 = 1;
	size_t soap_flag_children1 = 1;
	size_t soap_flag_parents1 = 1;
	size_t soap_flag_annotations1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory2--;
					continue;
				}
			if (soap_flag_localUpdateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime2--;
					continue;
				}
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_categoryList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CategoryListType(soap, "ns2:categoryList", &(a->ns2__PlaceType::categoryList), "ns2:CategoryListType"))
				{	soap_flag_categoryList1--;
					continue;
				}
			if (soap_flag_locationList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__PlaceType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList1--;
					continue;
				}
			if (soap_flag_ns3__timePeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__PlaceType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod1--;
					continue;
				}
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__PlaceType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap_flag_parents1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", &(a->ns2__PlaceType::parents), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_parents1--;
					continue;
				}
			if (soap_flag_annotations1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", &(a->ns2__PlaceType::annotations), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_annotations1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PlaceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PlaceType, 0, sizeof(ns2__PlaceType), 0, soap_copy_ns2__PlaceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory2 > 0 || soap_flag_localUpdateTime2 > 0 || soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_categoryList1 > 0 || soap_flag_locationList1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__PlaceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__PlaceType);
	if (this->soap_out(soap, tag?tag:"ns2:PlaceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PlaceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PlaceType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PlaceType * SOAP_FMAC4 soap_get_ns2__PlaceType(struct soap *soap, ns2__PlaceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PlaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__PlaceType * SOAP_FMAC2 soap_instantiate_ns2__PlaceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PlaceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__PlaceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:SpecialPlaceType"))
	{	cp->type = SOAP_TYPE_ns2__SpecialPlaceType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialPlaceType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SpecialPlaceType);
			((ns2__SpecialPlaceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialPlaceType[n]);
			if (size)
				*size = n * sizeof(ns2__SpecialPlaceType);
			for (int i = 0; i < n; i++)
				((ns2__SpecialPlaceType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SpecialPlaceType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__PlaceType);
		if (size)
			*size = sizeof(ns2__PlaceType);
		((ns2__PlaceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__PlaceType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__PlaceType);
		for (int i = 0; i < n; i++)
			((ns2__PlaceType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__PlaceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__PlaceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__PlaceType %p -> %p\n", q, p));
	*(ns2__PlaceType*)p = *(ns2__PlaceType*)q;
}

void ns2__PlaceUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PlaceUserPropertiesType::categoryList = NULL;
	this->ns2__PlaceUserPropertiesType::locationList = NULL;
	this->ns2__PlaceUserPropertiesType::ns3__timePeriod = NULL;
	this->ns2__PlaceUserPropertiesType::children = NULL;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__PlaceUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CategoryListType(soap, &this->ns2__PlaceUserPropertiesType::categoryList);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__PlaceUserPropertiesType::locationList);
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__PlaceUserPropertiesType::ns3__timePeriod);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__PlaceUserPropertiesType::children);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__PlaceUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PlaceUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PlaceUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__PlaceUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PlaceUserPropertiesType), "ns2:PlaceUserPropertiesType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__CategoryListType(soap, "ns2:categoryList", -1, &(a->ns2__PlaceUserPropertiesType::categoryList), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__PlaceUserPropertiesType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__PlaceUserPropertiesType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__PlaceUserPropertiesType::children), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PlaceUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PlaceUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PlaceUserPropertiesType * SOAP_FMAC4 soap_in_ns2__PlaceUserPropertiesType(struct soap *soap, const char *tag, ns2__PlaceUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PlaceUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PlaceUserPropertiesType, sizeof(ns2__PlaceUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__PlaceUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__PlaceUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_categoryList1 = 1;
	size_t soap_flag_locationList1 = 1;
	size_t soap_flag_ns3__timePeriod1 = 1;
	size_t soap_flag_children1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_categoryList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CategoryListType(soap, "ns2:categoryList", &(a->ns2__PlaceUserPropertiesType::categoryList), "ns2:CategoryListType"))
				{	soap_flag_categoryList1--;
					continue;
				}
			if (soap_flag_locationList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__PlaceUserPropertiesType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList1--;
					continue;
				}
			if (soap_flag_ns3__timePeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__PlaceUserPropertiesType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod1--;
					continue;
				}
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__PlaceUserPropertiesType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PlaceUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PlaceUserPropertiesType, 0, sizeof(ns2__PlaceUserPropertiesType), 0, soap_copy_ns2__PlaceUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_categoryList1 > 0 || soap_flag_locationList1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__PlaceUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__PlaceUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:PlaceUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PlaceUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PlaceUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PlaceUserPropertiesType * SOAP_FMAC4 soap_get_ns2__PlaceUserPropertiesType(struct soap *soap, ns2__PlaceUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PlaceUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__PlaceUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__PlaceUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PlaceUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__PlaceUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:SpecialPlaceUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialPlaceUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SpecialPlaceUserPropertiesType);
			((ns2__SpecialPlaceUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialPlaceUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__SpecialPlaceUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__SpecialPlaceUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SpecialPlaceUserPropertiesType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__PlaceUserPropertiesType);
		if (size)
			*size = sizeof(ns2__PlaceUserPropertiesType);
		((ns2__PlaceUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__PlaceUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__PlaceUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__PlaceUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__PlaceUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__PlaceUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__PlaceUserPropertiesType %p -> %p\n", q, p));
	*(ns2__PlaceUserPropertiesType*)p = *(ns2__PlaceUserPropertiesType*)q;
}

void ns2__EventType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__EventType::categoryList = NULL;
	this->ns2__EventType::locationList = NULL;
	this->ns2__EventType::ns3__timePeriod = NULL;
	this->ns2__EventType::children = NULL;
	this->ns2__EventType::parents = NULL;
	this->ns2__EventType::annotations = NULL;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__EventType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CategoryListType(soap, &this->ns2__EventType::categoryList);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__EventType::locationList);
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__EventType::ns3__timePeriod);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__EventType::children);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__EventType::parents);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__EventType::annotations);
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__EventType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EventType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EventType(struct soap *soap, const char *tag, int id, const ns2__EventType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EventType), "ns2:EventType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__CategoryListType(soap, "ns2:categoryList", -1, &(a->ns2__EventType::categoryList), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__EventType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__EventType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__EventType::children), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", -1, &(a->ns2__EventType::parents), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", -1, &(a->ns2__EventType::annotations), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__EventType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EventType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EventType * SOAP_FMAC4 soap_in_ns2__EventType(struct soap *soap, const char *tag, ns2__EventType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EventType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EventType, sizeof(ns2__EventType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__EventType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__EventType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory2 = 1;
	size_t soap_flag_localUpdateTime2 = 1;
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_categoryList1 = 1;
	size_t soap_flag_locationList1 = 1;
	size_t soap_flag_ns3__timePeriod1 = 1;
	size_t soap_flag_children1 = 1;
	size_t soap_flag_parents1 = 1;
	size_t soap_flag_annotations1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory2--;
					continue;
				}
			if (soap_flag_localUpdateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime2--;
					continue;
				}
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_categoryList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CategoryListType(soap, "ns2:categoryList", &(a->ns2__EventType::categoryList), "ns2:CategoryListType"))
				{	soap_flag_categoryList1--;
					continue;
				}
			if (soap_flag_locationList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__EventType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList1--;
					continue;
				}
			if (soap_flag_ns3__timePeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__EventType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod1--;
					continue;
				}
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__EventType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap_flag_parents1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", &(a->ns2__EventType::parents), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_parents1--;
					continue;
				}
			if (soap_flag_annotations1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", &(a->ns2__EventType::annotations), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_annotations1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__EventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EventType, 0, sizeof(ns2__EventType), 0, soap_copy_ns2__EventType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory2 > 0 || soap_flag_localUpdateTime2 > 0 || soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_categoryList1 > 0 || soap_flag_locationList1 > 0 || soap_flag_ns3__timePeriod1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__EventType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__EventType);
	if (this->soap_out(soap, tag?tag:"ns2:EventType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EventType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EventType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EventType * SOAP_FMAC4 soap_get_ns2__EventType(struct soap *soap, ns2__EventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__EventType * SOAP_FMAC2 soap_instantiate_ns2__EventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__EventType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__EventType);
		if (size)
			*size = sizeof(ns2__EventType);
		((ns2__EventType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__EventType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__EventType);
		for (int i = 0; i < n; i++)
			((ns2__EventType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__EventType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__EventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__EventType %p -> %p\n", q, p));
	*(ns2__EventType*)p = *(ns2__EventType*)q;
}

void ns2__EventUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__EventUserPropertiesType::categoryList = NULL;
	this->ns2__EventUserPropertiesType::locationList = NULL;
	this->ns2__EventUserPropertiesType::ns3__timePeriod = NULL;
	this->ns2__EventUserPropertiesType::children = NULL;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__EventUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CategoryListType(soap, &this->ns2__EventUserPropertiesType::categoryList);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__EventUserPropertiesType::locationList);
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__EventUserPropertiesType::ns3__timePeriod);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__EventUserPropertiesType::children);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__EventUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EventUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EventUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__EventUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EventUserPropertiesType), "ns2:EventUserPropertiesType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__CategoryListType(soap, "ns2:categoryList", -1, &(a->ns2__EventUserPropertiesType::categoryList), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__EventUserPropertiesType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__EventUserPropertiesType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__EventUserPropertiesType::children), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__EventUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EventUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EventUserPropertiesType * SOAP_FMAC4 soap_in_ns2__EventUserPropertiesType(struct soap *soap, const char *tag, ns2__EventUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EventUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EventUserPropertiesType, sizeof(ns2__EventUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__EventUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__EventUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_categoryList1 = 1;
	size_t soap_flag_locationList1 = 1;
	size_t soap_flag_ns3__timePeriod1 = 1;
	size_t soap_flag_children1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_categoryList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CategoryListType(soap, "ns2:categoryList", &(a->ns2__EventUserPropertiesType::categoryList), "ns2:CategoryListType"))
				{	soap_flag_categoryList1--;
					continue;
				}
			if (soap_flag_locationList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__EventUserPropertiesType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList1--;
					continue;
				}
			if (soap_flag_ns3__timePeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__EventUserPropertiesType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod1--;
					continue;
				}
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__EventUserPropertiesType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__EventUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EventUserPropertiesType, 0, sizeof(ns2__EventUserPropertiesType), 0, soap_copy_ns2__EventUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_categoryList1 > 0 || soap_flag_locationList1 > 0 || soap_flag_ns3__timePeriod1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__EventUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__EventUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:EventUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EventUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EventUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EventUserPropertiesType * SOAP_FMAC4 soap_get_ns2__EventUserPropertiesType(struct soap *soap, ns2__EventUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EventUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__EventUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__EventUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EventUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__EventUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__EventUserPropertiesType);
		if (size)
			*size = sizeof(ns2__EventUserPropertiesType);
		((ns2__EventUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__EventUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__EventUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__EventUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__EventUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__EventUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__EventUserPropertiesType %p -> %p\n", q, p));
	*(ns2__EventUserPropertiesType*)p = *(ns2__EventUserPropertiesType*)q;
}

void ns2__ImageType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ImageType::direction = NULL;
	soap_default_xsd__positiveInteger(soap, &this->ns2__ImageType::width);
	soap_default_xsd__positiveInteger(soap, &this->ns2__ImageType::height);
	this->ns2__MediaType::fileReference = NULL;
	this->ns2__MediaType::locationList = NULL;
	this->ns2__MediaType::ns3__timePeriod = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__MediaType::mfid);
	this->ns2__MediaType::name = NULL;
	soap_default_ns3__MimeType(soap, &this->ns2__MediaType::type);
	soap_default_std__vectorTemplateOfPointerTons2__MediaFileUrlType(soap, &this->ns2__MediaType::url);
	this->ns2__MediaType::parents = NULL;
	this->ns2__MediaType::annotations = NULL;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__ImageType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns2__ImageType::direction);
	soap_serialize_xsd__positiveInteger(soap, &this->ns2__ImageType::width);
	soap_serialize_xsd__positiveInteger(soap, &this->ns2__ImageType::height);
	soap_serialize_PointerTons3__NonEmptyStringType(soap, &this->ns2__MediaType::fileReference);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__MediaType::locationList);
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__MediaType::ns3__timePeriod);
	soap_serialize_ns3__GuidType(soap, &this->ns2__MediaType::mfid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MediaType::name);
	soap_serialize_ns3__MimeType(soap, &this->ns2__MediaType::type);
	soap_serialize_std__vectorTemplateOfPointerTons2__MediaFileUrlType(soap, &this->ns2__MediaType::url);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__MediaType::parents);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__MediaType::annotations);
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__ImageType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ImageType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImageType(struct soap *soap, const char *tag, int id, const ns2__ImageType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImageType), "ns2:ImageType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons3__NonEmptyStringType(soap, "ns2:fileReference", -1, &(a->ns2__MediaType::fileReference), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__MediaType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__MediaType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_ns3__GuidType(soap, "ns2:mfid", -1, &(a->ns2__MediaType::mfid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:name", -1, &(a->ns2__MediaType::name), ""))
		return soap->error;
	if (soap_out_ns3__MimeType(soap, "ns2:type", -1, &(a->ns2__MediaType::type), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__MediaFileUrlType(soap, "ns2:url", -1, &(a->ns2__MediaType::url), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", -1, &(a->ns2__MediaType::parents), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", -1, &(a->ns2__MediaType::annotations), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:direction", -1, &(a->ns2__ImageType::direction), ""))
		return soap->error;
	if (soap_out_xsd__positiveInteger(soap, "ns2:width", -1, &(a->ns2__ImageType::width), ""))
		return soap->error;
	if (soap_out_xsd__positiveInteger(soap, "ns2:height", -1, &(a->ns2__ImageType::height), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ImageType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ImageType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ImageType * SOAP_FMAC4 soap_in_ns2__ImageType(struct soap *soap, const char *tag, ns2__ImageType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ImageType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImageType, sizeof(ns2__ImageType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ImageType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ImageType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory3 = 1;
	size_t soap_flag_localUpdateTime3 = 1;
	size_t soap_flag_securityInfo3 = 1;
	size_t soap_flag_title3 = 1;
	size_t soap_flag_description3 = 1;
	size_t soap_flag_unit3 = 1;
	size_t soap_flag_extId3 = 1;
	size_t soap_flag_fileReference2 = 1;
	size_t soap_flag_locationList2 = 1;
	size_t soap_flag_ns3__timePeriod2 = 1;
	size_t soap_flag_mfid2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_type2 = 1;
	size_t soap_flag_parents2 = 1;
	size_t soap_flag_annotations2 = 1;
	size_t soap_flag_direction1 = 1;
	size_t soap_flag_width1 = 1;
	size_t soap_flag_height1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory3--;
					continue;
				}
			if (soap_flag_localUpdateTime3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime3--;
					continue;
				}
			if (soap_flag_securityInfo3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo3--;
					continue;
				}
			if (soap_flag_title3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title3--;
					continue;
				}
			if (soap_flag_description3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description3--;
					continue;
				}
			if (soap_flag_unit3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit3--;
					continue;
				}
			if (soap_flag_extId3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_fileReference2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons3__NonEmptyStringType(soap, "ns2:fileReference", &(a->ns2__MediaType::fileReference), "ns3:NonEmptyStringType"))
				{	soap_flag_fileReference2--;
					continue;
				}
			if (soap_flag_locationList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__MediaType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList2--;
					continue;
				}
			if (soap_flag_ns3__timePeriod2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__MediaType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod2--;
					continue;
				}
			if (soap_flag_mfid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__GuidType(soap, "ns2:mfid", &(a->ns2__MediaType::mfid), "ns3:GuidType"))
				{	soap_flag_mfid2--;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:name", &(a->ns2__MediaType::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_type2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__MimeType(soap, "ns2:type", &(a->ns2__MediaType::type), "ns3:MimeType"))
				{	soap_flag_type2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__MediaFileUrlType(soap, "ns2:url", &(a->ns2__MediaType::url), "ns2:MediaFileUrlType"))
					continue;
			if (soap_flag_parents2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", &(a->ns2__MediaType::parents), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_parents2--;
					continue;
				}
			if (soap_flag_annotations2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", &(a->ns2__MediaType::annotations), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_annotations2--;
					continue;
				}
			if (soap_flag_direction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:direction", &(a->ns2__ImageType::direction), "xsd:int"))
				{	soap_flag_direction1--;
					continue;
				}
			if (soap_flag_width1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__positiveInteger(soap, "ns2:width", &(a->ns2__ImageType::width), "xsd:positiveInteger"))
				{	soap_flag_width1--;
					continue;
				}
			if (soap_flag_height1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__positiveInteger(soap, "ns2:height", &(a->ns2__ImageType::height), "xsd:positiveInteger"))
				{	soap_flag_height1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ImageType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImageType, 0, sizeof(ns2__ImageType), 0, soap_copy_ns2__ImageType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory3 > 0 || soap_flag_localUpdateTime3 > 0 || soap_flag_securityInfo3 > 0 || soap_flag_title3 > 0 || soap_flag_mfid2 > 0 || soap_flag_type2 > 0 || a->ns2__MediaType::url.size() < 1 || a->ns2__MediaType::url.size() > 3 || soap_flag_width1 > 0 || soap_flag_height1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ImageType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ImageType);
	if (this->soap_out(soap, tag?tag:"ns2:ImageType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ImageType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ImageType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ImageType * SOAP_FMAC4 soap_get_ns2__ImageType(struct soap *soap, ns2__ImageType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ImageType * SOAP_FMAC2 soap_instantiate_ns2__ImageType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ImageType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ImageType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ImageType);
		if (size)
			*size = sizeof(ns2__ImageType);
		((ns2__ImageType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ImageType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ImageType);
		for (int i = 0; i < n; i++)
			((ns2__ImageType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ImageType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ImageType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ImageType %p -> %p\n", q, p));
	*(ns2__ImageType*)p = *(ns2__ImageType*)q;
}

void ns2__ImageUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ImageUserPropertiesType::direction = NULL;
	this->ns2__MediaUserPropertiesType::fileReference = NULL;
	this->ns2__MediaUserPropertiesType::locationList = NULL;
	this->ns2__MediaUserPropertiesType::ns3__timePeriod = NULL;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__ImageUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns2__ImageUserPropertiesType::direction);
	soap_serialize_PointerTons3__NonEmptyStringType(soap, &this->ns2__MediaUserPropertiesType::fileReference);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__MediaUserPropertiesType::locationList);
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__MediaUserPropertiesType::ns3__timePeriod);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__ImageUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ImageUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ImageUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__ImageUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ImageUserPropertiesType), "ns2:ImageUserPropertiesType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons3__NonEmptyStringType(soap, "ns2:fileReference", -1, &(a->ns2__MediaUserPropertiesType::fileReference), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__MediaUserPropertiesType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__MediaUserPropertiesType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns2:direction", -1, &(a->ns2__ImageUserPropertiesType::direction), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ImageUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ImageUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ImageUserPropertiesType * SOAP_FMAC4 soap_in_ns2__ImageUserPropertiesType(struct soap *soap, const char *tag, ns2__ImageUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ImageUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ImageUserPropertiesType, sizeof(ns2__ImageUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ImageUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ImageUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo3 = 1;
	size_t soap_flag_title3 = 1;
	size_t soap_flag_description3 = 1;
	size_t soap_flag_unit3 = 1;
	size_t soap_flag_extId3 = 1;
	size_t soap_flag_fileReference2 = 1;
	size_t soap_flag_locationList2 = 1;
	size_t soap_flag_ns3__timePeriod2 = 1;
	size_t soap_flag_direction1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo3--;
					continue;
				}
			if (soap_flag_title3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title3--;
					continue;
				}
			if (soap_flag_description3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description3--;
					continue;
				}
			if (soap_flag_unit3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit3--;
					continue;
				}
			if (soap_flag_extId3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId3--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_fileReference2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons3__NonEmptyStringType(soap, "ns2:fileReference", &(a->ns2__MediaUserPropertiesType::fileReference), "ns3:NonEmptyStringType"))
				{	soap_flag_fileReference2--;
					continue;
				}
			if (soap_flag_locationList2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__MediaUserPropertiesType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList2--;
					continue;
				}
			if (soap_flag_ns3__timePeriod2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__MediaUserPropertiesType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod2--;
					continue;
				}
			if (soap_flag_direction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns2:direction", &(a->ns2__ImageUserPropertiesType::direction), "xsd:int"))
				{	soap_flag_direction1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ImageUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ImageUserPropertiesType, 0, sizeof(ns2__ImageUserPropertiesType), 0, soap_copy_ns2__ImageUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo3 > 0 || soap_flag_title3 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ImageUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ImageUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:ImageUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ImageUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ImageUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ImageUserPropertiesType * SOAP_FMAC4 soap_get_ns2__ImageUserPropertiesType(struct soap *soap, ns2__ImageUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ImageUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ImageUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__ImageUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ImageUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ImageUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ImageUserPropertiesType);
		if (size)
			*size = sizeof(ns2__ImageUserPropertiesType);
		((ns2__ImageUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ImageUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ImageUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__ImageUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ImageUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ImageUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ImageUserPropertiesType %p -> %p\n", q, p));
	*(ns2__ImageUserPropertiesType*)p = *(ns2__ImageUserPropertiesType*)q;
}

void ns2__MediaType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MediaType::fileReference = NULL;
	this->ns2__MediaType::locationList = NULL;
	this->ns2__MediaType::ns3__timePeriod = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__MediaType::mfid);
	this->ns2__MediaType::name = NULL;
	soap_default_ns3__MimeType(soap, &this->ns2__MediaType::type);
	soap_default_std__vectorTemplateOfPointerTons2__MediaFileUrlType(soap, &this->ns2__MediaType::url);
	this->ns2__MediaType::parents = NULL;
	this->ns2__MediaType::annotations = NULL;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__MediaType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__NonEmptyStringType(soap, &this->ns2__MediaType::fileReference);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__MediaType::locationList);
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__MediaType::ns3__timePeriod);
	soap_serialize_ns3__GuidType(soap, &this->ns2__MediaType::mfid);
	soap_serialize_PointerTostd__string(soap, &this->ns2__MediaType::name);
	soap_serialize_ns3__MimeType(soap, &this->ns2__MediaType::type);
	soap_serialize_std__vectorTemplateOfPointerTons2__MediaFileUrlType(soap, &this->ns2__MediaType::url);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__MediaType::parents);
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__MediaType::annotations);
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__MediaType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MediaType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MediaType(struct soap *soap, const char *tag, int id, const ns2__MediaType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MediaType), "ns2:MediaType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons3__NonEmptyStringType(soap, "ns2:fileReference", -1, &(a->ns2__MediaType::fileReference), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__MediaType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__MediaType::ns3__timePeriod), ""))
		return soap->error;
	if (soap_out_ns3__GuidType(soap, "ns2:mfid", -1, &(a->ns2__MediaType::mfid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:name", -1, &(a->ns2__MediaType::name), ""))
		return soap->error;
	if (soap_out_ns3__MimeType(soap, "ns2:type", -1, &(a->ns2__MediaType::type), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__MediaFileUrlType(soap, "ns2:url", -1, &(a->ns2__MediaType::url), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", -1, &(a->ns2__MediaType::parents), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", -1, &(a->ns2__MediaType::annotations), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__MediaType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MediaType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MediaType * SOAP_FMAC4 soap_in_ns2__MediaType(struct soap *soap, const char *tag, ns2__MediaType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MediaType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MediaType, sizeof(ns2__MediaType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MediaType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MediaType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory2 = 1;
	size_t soap_flag_localUpdateTime2 = 1;
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_fileReference1 = 1;
	size_t soap_flag_locationList1 = 1;
	size_t soap_flag_ns3__timePeriod1 = 1;
	size_t soap_flag_mfid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_parents1 = 1;
	size_t soap_flag_annotations1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory2--;
					continue;
				}
			if (soap_flag_localUpdateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime2--;
					continue;
				}
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_fileReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons3__NonEmptyStringType(soap, "ns2:fileReference", &(a->ns2__MediaType::fileReference), "ns3:NonEmptyStringType"))
				{	soap_flag_fileReference1--;
					continue;
				}
			if (soap_flag_locationList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__MediaType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList1--;
					continue;
				}
			if (soap_flag_ns3__timePeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__MediaType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod1--;
					continue;
				}
			if (soap_flag_mfid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__GuidType(soap, "ns2:mfid", &(a->ns2__MediaType::mfid), "ns3:GuidType"))
				{	soap_flag_mfid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:name", &(a->ns2__MediaType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__MimeType(soap, "ns2:type", &(a->ns2__MediaType::type), "ns3:MimeType"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__MediaFileUrlType(soap, "ns2:url", &(a->ns2__MediaType::url), "ns2:MediaFileUrlType"))
					continue;
			if (soap_flag_parents1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:parents", &(a->ns2__MediaType::parents), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_parents1--;
					continue;
				}
			if (soap_flag_annotations1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:annotations", &(a->ns2__MediaType::annotations), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_annotations1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MediaType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MediaType, 0, sizeof(ns2__MediaType), 0, soap_copy_ns2__MediaType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory2 > 0 || soap_flag_localUpdateTime2 > 0 || soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_mfid1 > 0 || soap_flag_type1 > 0 || a->ns2__MediaType::url.size() < 1 || a->ns2__MediaType::url.size() > 3))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MediaType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MediaType);
	if (this->soap_out(soap, tag?tag:"ns2:MediaType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MediaType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MediaType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MediaType * SOAP_FMAC4 soap_get_ns2__MediaType(struct soap *soap, ns2__MediaType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MediaType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MediaType * SOAP_FMAC2 soap_instantiate_ns2__MediaType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MediaType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MediaType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:ImageType"))
	{	cp->type = SOAP_TYPE_ns2__ImageType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ImageType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ImageType);
			((ns2__ImageType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ImageType[n]);
			if (size)
				*size = n * sizeof(ns2__ImageType);
			for (int i = 0; i < n; i++)
				((ns2__ImageType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ImageType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MediaType);
		if (size)
			*size = sizeof(ns2__MediaType);
		((ns2__MediaType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MediaType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MediaType);
		for (int i = 0; i < n; i++)
			((ns2__MediaType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MediaType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MediaType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MediaType %p -> %p\n", q, p));
	*(ns2__MediaType*)p = *(ns2__MediaType*)q;
}

void ns2__MediaFileUrlType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->ns2__MediaFileUrlType::__item);
	soap_default_ns3__MediaFileFormType(soap, &this->ns2__MediaFileUrlType::form);
	soap_default_xsd__nonNegativeInteger(soap, &this->ns2__MediaFileUrlType::size);
	/* transient soap skipped */
}

void ns2__MediaFileUrlType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__MediaFileUrlType::__item, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->ns2__MediaFileUrlType::__item);
	/* transient soap skipped */
}

int ns2__MediaFileUrlType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MediaFileUrlType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MediaFileUrlType(struct soap *soap, const char *tag, int id, const ns2__MediaFileUrlType *a, const char *type)
{
	soap_set_attr(soap, "form", soap_ns3__MediaFileFormType2s(soap, ((ns2__MediaFileUrlType*)a)->form), 1);
	if (!((ns2__MediaFileUrlType*)a)->size.empty())
		soap_set_attr(soap, "size", ((ns2__MediaFileUrlType*)a)->size.c_str(), 1);
	return soap_out_xsd__anyURI(soap, tag, id, &a->ns2__MediaFileUrlType::__item, "");
}

void *ns2__MediaFileUrlType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MediaFileUrlType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MediaFileUrlType * SOAP_FMAC4 soap_in_ns2__MediaFileUrlType(struct soap *soap, const char *tag, ns2__MediaFileUrlType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__MediaFileUrlType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MediaFileUrlType, sizeof(ns2__MediaFileUrlType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MediaFileUrlType)
			return (ns2__MediaFileUrlType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2ns3__MediaFileFormType(soap, soap_attr_value(soap, "form", 1), &((ns2__MediaFileUrlType*)a)->form))
		return NULL;
	{	const char *t = soap_attr_value(soap, "size", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__MediaFileUrlType*)a)->size.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_in_xsd__anyURI(soap, tag, &(a->ns2__MediaFileUrlType::__item), "ns2:MediaFileUrlType"))
		return NULL;
	return a;
}

int ns2__MediaFileUrlType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MediaFileUrlType);
	if (this->soap_out(soap, tag?tag:"ns2:MediaFileUrlType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MediaFileUrlType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MediaFileUrlType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MediaFileUrlType * SOAP_FMAC4 soap_get_ns2__MediaFileUrlType(struct soap *soap, ns2__MediaFileUrlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MediaFileUrlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MediaFileUrlType * SOAP_FMAC2 soap_instantiate_ns2__MediaFileUrlType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MediaFileUrlType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MediaFileUrlType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MediaFileUrlType);
		if (size)
			*size = sizeof(ns2__MediaFileUrlType);
		((ns2__MediaFileUrlType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MediaFileUrlType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MediaFileUrlType);
		for (int i = 0; i < n; i++)
			((ns2__MediaFileUrlType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MediaFileUrlType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MediaFileUrlType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MediaFileUrlType %p -> %p\n", q, p));
	*(ns2__MediaFileUrlType*)p = *(ns2__MediaFileUrlType*)q;
}

void ns2__MediaUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MediaUserPropertiesType::fileReference = NULL;
	this->ns2__MediaUserPropertiesType::locationList = NULL;
	this->ns2__MediaUserPropertiesType::ns3__timePeriod = NULL;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__MediaUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__NonEmptyStringType(soap, &this->ns2__MediaUserPropertiesType::fileReference);
	soap_serialize_PointerTons2__LocationListType(soap, &this->ns2__MediaUserPropertiesType::locationList);
	soap_serialize_PointerTons3__TimePeriodType(soap, &this->ns2__MediaUserPropertiesType::ns3__timePeriod);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__MediaUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MediaUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MediaUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__MediaUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MediaUserPropertiesType), "ns2:MediaUserPropertiesType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons3__NonEmptyStringType(soap, "ns2:fileReference", -1, &(a->ns2__MediaUserPropertiesType::fileReference), ""))
		return soap->error;
	if (soap_out_PointerTons2__LocationListType(soap, "ns2:locationList", -1, &(a->ns2__MediaUserPropertiesType::locationList), ""))
		return soap->error;
	if (soap_out_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", -1, &(a->ns2__MediaUserPropertiesType::ns3__timePeriod), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__MediaUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MediaUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MediaUserPropertiesType * SOAP_FMAC4 soap_in_ns2__MediaUserPropertiesType(struct soap *soap, const char *tag, ns2__MediaUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MediaUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MediaUserPropertiesType, sizeof(ns2__MediaUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MediaUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MediaUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_fileReference1 = 1;
	size_t soap_flag_locationList1 = 1;
	size_t soap_flag_ns3__timePeriod1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_fileReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTons3__NonEmptyStringType(soap, "ns2:fileReference", &(a->ns2__MediaUserPropertiesType::fileReference), "ns3:NonEmptyStringType"))
				{	soap_flag_fileReference1--;
					continue;
				}
			if (soap_flag_locationList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LocationListType(soap, "ns2:locationList", &(a->ns2__MediaUserPropertiesType::locationList), "ns2:LocationListType"))
				{	soap_flag_locationList1--;
					continue;
				}
			if (soap_flag_ns3__timePeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__TimePeriodType(soap, "ns3:timePeriod", &(a->ns2__MediaUserPropertiesType::ns3__timePeriod), "ns3:TimePeriodType"))
				{	soap_flag_ns3__timePeriod1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MediaUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MediaUserPropertiesType, 0, sizeof(ns2__MediaUserPropertiesType), 0, soap_copy_ns2__MediaUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MediaUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MediaUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:MediaUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MediaUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MediaUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MediaUserPropertiesType * SOAP_FMAC4 soap_get_ns2__MediaUserPropertiesType(struct soap *soap, ns2__MediaUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MediaUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MediaUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__MediaUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MediaUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MediaUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:ImageUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__ImageUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ImageUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ImageUserPropertiesType);
			((ns2__ImageUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ImageUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__ImageUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__ImageUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ImageUserPropertiesType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MediaUserPropertiesType);
		if (size)
			*size = sizeof(ns2__MediaUserPropertiesType);
		((ns2__MediaUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__MediaUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__MediaUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__MediaUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__MediaUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MediaUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MediaUserPropertiesType %p -> %p\n", q, p));
	*(ns2__MediaUserPropertiesType*)p = *(ns2__MediaUserPropertiesType*)q;
}

void ns2__AnnotationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AnnotationType::children = NULL;
	this->ns2__AnnotationType::parent = NULL;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__AnnotationType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__AnnotationType::children);
	soap_serialize_PointerTons2__AbstractContentReferenceHolderType(soap, &this->ns2__AnnotationType::parent);
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__AnnotationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AnnotationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AnnotationType(struct soap *soap, const char *tag, int id, const ns2__AnnotationType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AnnotationType), "ns2:AnnotationType"))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__AnnotationType::children), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceHolderType(soap, "ns2:parent", -1, &(a->ns2__AnnotationType::parent), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AnnotationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AnnotationType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AnnotationType * SOAP_FMAC4 soap_in_ns2__AnnotationType(struct soap *soap, const char *tag, ns2__AnnotationType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AnnotationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AnnotationType, sizeof(ns2__AnnotationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AnnotationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AnnotationType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory2 = 1;
	size_t soap_flag_localUpdateTime2 = 1;
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_children1 = 1;
	size_t soap_flag_parent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory2--;
					continue;
				}
			if (soap_flag_localUpdateTime2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime2--;
					continue;
				}
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__AnnotationType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap_flag_parent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceHolderType(soap, "ns2:parent", &(a->ns2__AnnotationType::parent), "ns2:AbstractContentReferenceHolderType"))
				{	soap_flag_parent1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AnnotationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AnnotationType, 0, sizeof(ns2__AnnotationType), 0, soap_copy_ns2__AnnotationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory2 > 0 || soap_flag_localUpdateTime2 > 0 || soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_parent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__AnnotationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AnnotationType);
	if (this->soap_out(soap, tag?tag:"ns2:AnnotationType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AnnotationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AnnotationType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AnnotationType * SOAP_FMAC4 soap_get_ns2__AnnotationType(struct soap *soap, ns2__AnnotationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AnnotationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AnnotationType * SOAP_FMAC2 soap_instantiate_ns2__AnnotationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AnnotationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AnnotationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AnnotationType);
		if (size)
			*size = sizeof(ns2__AnnotationType);
		((ns2__AnnotationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AnnotationType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AnnotationType);
		for (int i = 0; i < n; i++)
			((ns2__AnnotationType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AnnotationType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AnnotationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AnnotationType %p -> %p\n", q, p));
	*(ns2__AnnotationType*)p = *(ns2__AnnotationType*)q;
}

void ns2__AnnotationUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AnnotationUserPropertiesType::children = NULL;
	this->ns2__AnnotationUserPropertiesType::parent = NULL;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__AnnotationUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__AbstractContentReferenceListType(soap, &this->ns2__AnnotationUserPropertiesType::children);
	soap_serialize_PointerTons2__AbstractContentReferenceHolderType(soap, &this->ns2__AnnotationUserPropertiesType::parent);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__AnnotationUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AnnotationUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AnnotationUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__AnnotationUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AnnotationUserPropertiesType), "ns2:AnnotationUserPropertiesType"))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", -1, &(a->ns2__AnnotationUserPropertiesType::children), ""))
		return soap->error;
	if (soap_out_PointerTons2__AbstractContentReferenceHolderType(soap, "ns2:parent", -1, &(a->ns2__AnnotationUserPropertiesType::parent), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AnnotationUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AnnotationUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AnnotationUserPropertiesType * SOAP_FMAC4 soap_in_ns2__AnnotationUserPropertiesType(struct soap *soap, const char *tag, ns2__AnnotationUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AnnotationUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AnnotationUserPropertiesType, sizeof(ns2__AnnotationUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AnnotationUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AnnotationUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_description2 = 1;
	size_t soap_flag_unit2 = 1;
	size_t soap_flag_extId2 = 1;
	size_t soap_flag_children1 = 1;
	size_t soap_flag_parent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title2--;
					continue;
				}
			if (soap_flag_description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description2--;
					continue;
				}
			if (soap_flag_unit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit2--;
					continue;
				}
			if (soap_flag_extId2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_children1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceListType(soap, "ns2:children", &(a->ns2__AnnotationUserPropertiesType::children), "ns2:AbstractContentReferenceListType"))
				{	soap_flag_children1--;
					continue;
				}
			if (soap_flag_parent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AbstractContentReferenceHolderType(soap, "ns2:parent", &(a->ns2__AnnotationUserPropertiesType::parent), "ns2:AbstractContentReferenceHolderType"))
				{	soap_flag_parent1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AnnotationUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AnnotationUserPropertiesType, 0, sizeof(ns2__AnnotationUserPropertiesType), 0, soap_copy_ns2__AnnotationUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo2 > 0 || soap_flag_title2 > 0 || soap_flag_parent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__AnnotationUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AnnotationUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:AnnotationUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AnnotationUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AnnotationUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AnnotationUserPropertiesType * SOAP_FMAC4 soap_get_ns2__AnnotationUserPropertiesType(struct soap *soap, ns2__AnnotationUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AnnotationUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AnnotationUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__AnnotationUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AnnotationUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AnnotationUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AnnotationUserPropertiesType);
		if (size)
			*size = sizeof(ns2__AnnotationUserPropertiesType);
		((ns2__AnnotationUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AnnotationUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AnnotationUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__AnnotationUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AnnotationUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AnnotationUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AnnotationUserPropertiesType %p -> %p\n", q, p));
	*(ns2__AnnotationUserPropertiesType*)p = *(ns2__AnnotationUserPropertiesType*)q;
}

void ns2__CategoryListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__CategoryListType::category);
	/* transient soap skipped */
}

void ns2__CategoryListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__CategoryListType::category);
	/* transient soap skipped */
}

int ns2__CategoryListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CategoryListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CategoryListType(struct soap *soap, const char *tag, int id, const ns2__CategoryListType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CategoryListType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns2:category", -1, &(a->ns2__CategoryListType::category), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CategoryListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CategoryListType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CategoryListType * SOAP_FMAC4 soap_in_ns2__CategoryListType(struct soap *soap, const char *tag, ns2__CategoryListType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CategoryListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CategoryListType, sizeof(ns2__CategoryListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CategoryListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CategoryListType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns2:category", &(a->ns2__CategoryListType::category), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CategoryListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CategoryListType, 0, sizeof(ns2__CategoryListType), 0, soap_copy_ns2__CategoryListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__CategoryListType::category.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__CategoryListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CategoryListType);
	if (this->soap_out(soap, tag?tag:"ns2:CategoryListType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CategoryListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CategoryListType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CategoryListType * SOAP_FMAC4 soap_get_ns2__CategoryListType(struct soap *soap, ns2__CategoryListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CategoryListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CategoryListType * SOAP_FMAC2 soap_instantiate_ns2__CategoryListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CategoryListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CategoryListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CategoryListType);
		if (size)
			*size = sizeof(ns2__CategoryListType);
		((ns2__CategoryListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CategoryListType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CategoryListType);
		for (int i = 0; i < n; i++)
			((ns2__CategoryListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CategoryListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CategoryListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CategoryListType %p -> %p\n", q, p));
	*(ns2__CategoryListType*)p = *(ns2__CategoryListType*)q;
}

void ns2__LocationListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__LocationListType::__sizeAbstractGeometry = 0;
	this->ns2__LocationListType::__union_LocationListType = NULL;
	/* transient soap skipped */
}

void ns2__LocationListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns2__LocationListType::__union_LocationListType)
	{	int i;
		for (i = 0; i < this->ns2__LocationListType::__sizeAbstractGeometry; i++)
		{
			this->ns2__LocationListType::__union_LocationListType[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int ns2__LocationListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LocationListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LocationListType(struct soap *soap, const char *tag, int id, const ns2__LocationListType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LocationListType), type))
		return soap->error;
	if (a->ns2__LocationListType::__union_LocationListType)
	{	int i;
		for (i = 0; i < a->ns2__LocationListType::__sizeAbstractGeometry; i++)
			if (a->ns2__LocationListType::__union_LocationListType[i].soap_out(soap, "-union-LocationListType", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__LocationListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LocationListType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LocationListType * SOAP_FMAC4 soap_in_ns2__LocationListType(struct soap *soap, const char *tag, ns2__LocationListType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LocationListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LocationListType, sizeof(ns2__LocationListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__LocationListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__LocationListType *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___union_LocationListType1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns2__LocationListType::__union_LocationListType == NULL)
				{	if (soap_blist___union_LocationListType1 == NULL)
						soap_blist___union_LocationListType1 = soap_new_block(soap);
					a->ns2__LocationListType::__union_LocationListType = (__ns2__union_LocationListType *)soap_push_block(soap, soap_blist___union_LocationListType1, sizeof(__ns2__union_LocationListType));
					if (a->ns2__LocationListType::__union_LocationListType == NULL)
						return NULL;
					__ns2__union_LocationListType p;
					memcpy(a->ns2__LocationListType::__union_LocationListType, &p, sizeof(__ns2__union_LocationListType)); // a bit rough but portable
					a->ns2__LocationListType::__union_LocationListType->soap_default(soap);
				}
				if (soap_in___ns2__union_LocationListType(soap, "-union-LocationListType", a->ns2__LocationListType::__union_LocationListType, "-ns2:union-LocationListType"))
				{	a->ns2__LocationListType::__sizeAbstractGeometry++;
					a->ns2__LocationListType::__union_LocationListType = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__LocationListType::__union_LocationListType)
			soap_pop_block(soap, soap_blist___union_LocationListType1);
		if (a->ns2__LocationListType::__sizeAbstractGeometry)
			a->ns2__LocationListType::__union_LocationListType = (__ns2__union_LocationListType *)soap_save_block(soap, soap_blist___union_LocationListType1, NULL, 1);
		else
		{	a->ns2__LocationListType::__union_LocationListType = NULL;
			if (soap_blist___union_LocationListType1)
				soap_end_block(soap, soap_blist___union_LocationListType1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LocationListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LocationListType, 0, sizeof(ns2__LocationListType), 0, soap_copy_ns2__LocationListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__LocationListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__LocationListType);
	if (this->soap_out(soap, tag?tag:"ns2:LocationListType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LocationListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LocationListType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LocationListType * SOAP_FMAC4 soap_get_ns2__LocationListType(struct soap *soap, ns2__LocationListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LocationListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__LocationListType * SOAP_FMAC2 soap_instantiate_ns2__LocationListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LocationListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__LocationListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__LocationListType);
		if (size)
			*size = sizeof(ns2__LocationListType);
		((ns2__LocationListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__LocationListType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__LocationListType);
		for (int i = 0; i < n; i++)
			((ns2__LocationListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__LocationListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__LocationListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__LocationListType %p -> %p\n", q, p));
	*(ns2__LocationListType*)p = *(ns2__LocationListType*)q;
}

void ns2__AbstractContentUserPropertiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	this->ns2__AbstractContentUserPropertiesType::description = NULL;
	this->ns2__AbstractContentUserPropertiesType::unit = NULL;
	this->ns2__AbstractContentUserPropertiesType::extId = NULL;
	/* transient soap skipped */
}

void ns2__AbstractContentUserPropertiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentUserPropertiesType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentUserPropertiesType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentUserPropertiesType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentUserPropertiesType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentUserPropertiesType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentUserPropertiesType::extId);
	/* transient soap skipped */
}

int ns2__AbstractContentUserPropertiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AbstractContentUserPropertiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AbstractContentUserPropertiesType(struct soap *soap, const char *tag, int id, const ns2__AbstractContentUserPropertiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AbstractContentUserPropertiesType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentUserPropertiesType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentUserPropertiesType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentUserPropertiesType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentUserPropertiesType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentUserPropertiesType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AbstractContentUserPropertiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AbstractContentUserPropertiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AbstractContentUserPropertiesType * SOAP_FMAC4 soap_in_ns2__AbstractContentUserPropertiesType(struct soap *soap, const char *tag, ns2__AbstractContentUserPropertiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AbstractContentUserPropertiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AbstractContentUserPropertiesType, sizeof(ns2__AbstractContentUserPropertiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AbstractContentUserPropertiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AbstractContentUserPropertiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_securityInfo1 = 1;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_unit1 = 1;
	size_t soap_flag_extId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_securityInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentUserPropertiesType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentUserPropertiesType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentUserPropertiesType::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentUserPropertiesType::unit), "ns2:UnitType"))
				{	soap_flag_unit1--;
					continue;
				}
			if (soap_flag_extId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentUserPropertiesType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AbstractContentUserPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AbstractContentUserPropertiesType, 0, sizeof(ns2__AbstractContentUserPropertiesType), 0, soap_copy_ns2__AbstractContentUserPropertiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_securityInfo1 > 0 || soap_flag_title1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__AbstractContentUserPropertiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AbstractContentUserPropertiesType);
	if (this->soap_out(soap, tag?tag:"ns2:AbstractContentUserPropertiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AbstractContentUserPropertiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AbstractContentUserPropertiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AbstractContentUserPropertiesType * SOAP_FMAC4 soap_get_ns2__AbstractContentUserPropertiesType(struct soap *soap, ns2__AbstractContentUserPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AbstractContentUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AbstractContentUserPropertiesType * SOAP_FMAC2 soap_instantiate_ns2__AbstractContentUserPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AbstractContentUserPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AbstractContentUserPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:AnnotationUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__AnnotationUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__AnnotationUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__AnnotationUserPropertiesType);
			((ns2__AnnotationUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__AnnotationUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__AnnotationUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__AnnotationUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__AnnotationUserPropertiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:MediaUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__MediaUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__MediaUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__MediaUserPropertiesType);
			((ns2__MediaUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__MediaUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__MediaUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__MediaUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__MediaUserPropertiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:EventUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__EventUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__EventUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__EventUserPropertiesType);
			((ns2__EventUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__EventUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__EventUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__EventUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__EventUserPropertiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:PlaceUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__PlaceUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__PlaceUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__PlaceUserPropertiesType);
			((ns2__PlaceUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__PlaceUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__PlaceUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__PlaceUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__PlaceUserPropertiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ReportUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__ReportUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ReportUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ReportUserPropertiesType);
			((ns2__ReportUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ReportUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__ReportUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__ReportUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ReportUserPropertiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:CollectionUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__CollectionUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__CollectionUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__CollectionUserPropertiesType);
			((ns2__CollectionUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__CollectionUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__CollectionUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__CollectionUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__CollectionUserPropertiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ForumTopicUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__ForumTopicUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ForumTopicUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ForumTopicUserPropertiesType);
			((ns2__ForumTopicUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ForumTopicUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__ForumTopicUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__ForumTopicUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ForumTopicUserPropertiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ForumPostUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__ForumPostUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ForumPostUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ForumPostUserPropertiesType);
			((ns2__ForumPostUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ForumPostUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__ForumPostUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__ForumPostUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ForumPostUserPropertiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ImageUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__ImageUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ImageUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ImageUserPropertiesType);
			((ns2__ImageUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ImageUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__ImageUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__ImageUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ImageUserPropertiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:SpecialReportUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__SpecialReportUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialReportUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SpecialReportUserPropertiesType);
			((ns2__SpecialReportUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialReportUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__SpecialReportUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__SpecialReportUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SpecialReportUserPropertiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:SpecialPlaceUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialPlaceUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SpecialPlaceUserPropertiesType);
			((ns2__SpecialPlaceUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialPlaceUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__SpecialPlaceUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__SpecialPlaceUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SpecialPlaceUserPropertiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:SpecialCollectionUserPropertiesType"))
	{	cp->type = SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialCollectionUserPropertiesType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SpecialCollectionUserPropertiesType);
			((ns2__SpecialCollectionUserPropertiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialCollectionUserPropertiesType[n]);
			if (size)
				*size = n * sizeof(ns2__SpecialCollectionUserPropertiesType);
			for (int i = 0; i < n; i++)
				((ns2__SpecialCollectionUserPropertiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SpecialCollectionUserPropertiesType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AbstractContentUserPropertiesType);
		if (size)
			*size = sizeof(ns2__AbstractContentUserPropertiesType);
		((ns2__AbstractContentUserPropertiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AbstractContentUserPropertiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AbstractContentUserPropertiesType);
		for (int i = 0; i < n; i++)
			((ns2__AbstractContentUserPropertiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AbstractContentUserPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AbstractContentUserPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AbstractContentUserPropertiesType %p -> %p\n", q, p));
	*(ns2__AbstractContentUserPropertiesType*)p = *(ns2__AbstractContentUserPropertiesType*)q;
}

void ns2__AbstractContentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AbstractContentType::revisionHistory = NULL;
	soap_default_time(soap, &this->ns2__AbstractContentType::localUpdateTime);
	soap_default_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	this->ns2__AbstractContentType::description = NULL;
	this->ns2__AbstractContentType::unit = NULL;
	this->ns2__AbstractContentType::extId = NULL;
	soap_default_ns3__GuidType(soap, &this->ns2__AbstractContentType::cid);
	soap_default_xsd__anyURI(soap, &this->ns2__AbstractContentType::contentURL);
	/* transient soap skipped */
}

void ns2__AbstractContentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ContentVersionInfoListType(soap, &this->ns2__AbstractContentType::revisionHistory);
	soap_embedded(soap, &this->ns2__AbstractContentType::localUpdateTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__AbstractContentType::securityInfo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__AbstractContentType::securityInfo);
	soap_embedded(soap, &this->ns2__AbstractContentType::title, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__AbstractContentType::title);
	soap_serialize_PointerTostd__string(soap, &this->ns2__AbstractContentType::description);
	soap_serialize_PointerTons2__UnitType(soap, &this->ns2__AbstractContentType::unit);
	soap_serialize_PointerTons2__ExternalIdType(soap, &this->ns2__AbstractContentType::extId);
	/* transient soap skipped */
}

int ns2__AbstractContentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AbstractContentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AbstractContentType(struct soap *soap, const char *tag, int id, const ns2__AbstractContentType *a, const char *type)
{
	if (!((ns2__AbstractContentType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__AbstractContentType*)a)->cid.c_str(), 1);
	if (!((ns2__AbstractContentType*)a)->contentURL.empty())
		soap_set_attr(soap, "contentURL", ((ns2__AbstractContentType*)a)->contentURL.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AbstractContentType), type))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", -1, &(a->ns2__AbstractContentType::revisionHistory), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:localUpdateTime", -1, &(a->ns2__AbstractContentType::localUpdateTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:securityInfo", -1, &(a->ns2__AbstractContentType::securityInfo), ""))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:title", -1, &(a->ns2__AbstractContentType::title), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:description", -1, &(a->ns2__AbstractContentType::description), ""))
		return soap->error;
	if (soap_out_PointerTons2__UnitType(soap, "ns2:unit", -1, &(a->ns2__AbstractContentType::unit), ""))
		return soap->error;
	if (soap_out_PointerTons2__ExternalIdType(soap, "ns2:extId", -1, &(a->ns2__AbstractContentType::extId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AbstractContentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AbstractContentType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AbstractContentType * SOAP_FMAC4 soap_in_ns2__AbstractContentType(struct soap *soap, const char *tag, ns2__AbstractContentType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AbstractContentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AbstractContentType, sizeof(ns2__AbstractContentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AbstractContentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AbstractContentType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__AbstractContentType*)a)->contentURL.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_revisionHistory1 = 1;
	size_t soap_flag_localUpdateTime1 = 1;
	size_t soap_flag_securityInfo1 = 1;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_unit1 = 1;
	size_t soap_flag_extId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_revisionHistory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoListType(soap, "ns2:revisionHistory", &(a->ns2__AbstractContentType::revisionHistory), "ns2:ContentVersionInfoListType"))
				{	soap_flag_revisionHistory1--;
					continue;
				}
			if (soap_flag_localUpdateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:localUpdateTime", &(a->ns2__AbstractContentType::localUpdateTime), "xsd:dateTime"))
				{	soap_flag_localUpdateTime1--;
					continue;
				}
			if (soap_flag_securityInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:securityInfo", &(a->ns2__AbstractContentType::securityInfo), "xsd:string"))
				{	soap_flag_securityInfo1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:title", &(a->ns2__AbstractContentType::title), "ns3:NonEmptyStringType"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:description", &(a->ns2__AbstractContentType::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_unit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnitType(soap, "ns2:unit", &(a->ns2__AbstractContentType::unit), "ns2:UnitType"))
				{	soap_flag_unit1--;
					continue;
				}
			if (soap_flag_extId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExternalIdType(soap, "ns2:extId", &(a->ns2__AbstractContentType::extId), "ns2:ExternalIdType"))
				{	soap_flag_extId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AbstractContentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AbstractContentType, 0, sizeof(ns2__AbstractContentType), 0, soap_copy_ns2__AbstractContentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_revisionHistory1 > 0 || soap_flag_localUpdateTime1 > 0 || soap_flag_securityInfo1 > 0 || soap_flag_title1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__AbstractContentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AbstractContentType);
	if (this->soap_out(soap, tag?tag:"ns2:AbstractContentType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AbstractContentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AbstractContentType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AbstractContentType * SOAP_FMAC4 soap_get_ns2__AbstractContentType(struct soap *soap, ns2__AbstractContentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AbstractContentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AbstractContentType * SOAP_FMAC2 soap_instantiate_ns2__AbstractContentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AbstractContentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AbstractContentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:AnnotationType"))
	{	cp->type = SOAP_TYPE_ns2__AnnotationType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__AnnotationType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__AnnotationType);
			((ns2__AnnotationType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__AnnotationType[n]);
			if (size)
				*size = n * sizeof(ns2__AnnotationType);
			for (int i = 0; i < n; i++)
				((ns2__AnnotationType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__AnnotationType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:MediaType"))
	{	cp->type = SOAP_TYPE_ns2__MediaType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__MediaType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__MediaType);
			((ns2__MediaType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__MediaType[n]);
			if (size)
				*size = n * sizeof(ns2__MediaType);
			for (int i = 0; i < n; i++)
				((ns2__MediaType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__MediaType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:EventType"))
	{	cp->type = SOAP_TYPE_ns2__EventType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__EventType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__EventType);
			((ns2__EventType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__EventType[n]);
			if (size)
				*size = n * sizeof(ns2__EventType);
			for (int i = 0; i < n; i++)
				((ns2__EventType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__EventType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:PlaceType"))
	{	cp->type = SOAP_TYPE_ns2__PlaceType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__PlaceType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__PlaceType);
			((ns2__PlaceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__PlaceType[n]);
			if (size)
				*size = n * sizeof(ns2__PlaceType);
			for (int i = 0; i < n; i++)
				((ns2__PlaceType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__PlaceType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ReportType"))
	{	cp->type = SOAP_TYPE_ns2__ReportType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ReportType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ReportType);
			((ns2__ReportType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ReportType[n]);
			if (size)
				*size = n * sizeof(ns2__ReportType);
			for (int i = 0; i < n; i++)
				((ns2__ReportType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ReportType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:CollectionType"))
	{	cp->type = SOAP_TYPE_ns2__CollectionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__CollectionType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__CollectionType);
			((ns2__CollectionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__CollectionType[n]);
			if (size)
				*size = n * sizeof(ns2__CollectionType);
			for (int i = 0; i < n; i++)
				((ns2__CollectionType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__CollectionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ForumTopicType"))
	{	cp->type = SOAP_TYPE_ns2__ForumTopicType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ForumTopicType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ForumTopicType);
			((ns2__ForumTopicType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ForumTopicType[n]);
			if (size)
				*size = n * sizeof(ns2__ForumTopicType);
			for (int i = 0; i < n; i++)
				((ns2__ForumTopicType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ForumTopicType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ForumPostType"))
	{	cp->type = SOAP_TYPE_ns2__ForumPostType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ForumPostType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ForumPostType);
			((ns2__ForumPostType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ForumPostType[n]);
			if (size)
				*size = n * sizeof(ns2__ForumPostType);
			for (int i = 0; i < n; i++)
				((ns2__ForumPostType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ForumPostType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:DeletedType"))
	{	cp->type = SOAP_TYPE_ns2__DeletedType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__DeletedType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__DeletedType);
			((ns2__DeletedType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__DeletedType[n]);
			if (size)
				*size = n * sizeof(ns2__DeletedType);
			for (int i = 0; i < n; i++)
				((ns2__DeletedType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__DeletedType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ImageType"))
	{	cp->type = SOAP_TYPE_ns2__ImageType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ImageType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ImageType);
			((ns2__ImageType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ImageType[n]);
			if (size)
				*size = n * sizeof(ns2__ImageType);
			for (int i = 0; i < n; i++)
				((ns2__ImageType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ImageType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:SpecialReportType"))
	{	cp->type = SOAP_TYPE_ns2__SpecialReportType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialReportType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SpecialReportType);
			((ns2__SpecialReportType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialReportType[n]);
			if (size)
				*size = n * sizeof(ns2__SpecialReportType);
			for (int i = 0; i < n; i++)
				((ns2__SpecialReportType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SpecialReportType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:SpecialPlaceType"))
	{	cp->type = SOAP_TYPE_ns2__SpecialPlaceType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialPlaceType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SpecialPlaceType);
			((ns2__SpecialPlaceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialPlaceType[n]);
			if (size)
				*size = n * sizeof(ns2__SpecialPlaceType);
			for (int i = 0; i < n; i++)
				((ns2__SpecialPlaceType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SpecialPlaceType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:SpecialCollectionType"))
	{	cp->type = SOAP_TYPE_ns2__SpecialCollectionType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialCollectionType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__SpecialCollectionType);
			((ns2__SpecialCollectionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__SpecialCollectionType[n]);
			if (size)
				*size = n * sizeof(ns2__SpecialCollectionType);
			for (int i = 0; i < n; i++)
				((ns2__SpecialCollectionType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__SpecialCollectionType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AbstractContentType);
		if (size)
			*size = sizeof(ns2__AbstractContentType);
		((ns2__AbstractContentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AbstractContentType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AbstractContentType);
		for (int i = 0; i < n; i++)
			((ns2__AbstractContentType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AbstractContentType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AbstractContentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AbstractContentType %p -> %p\n", q, p));
	*(ns2__AbstractContentType*)p = *(ns2__AbstractContentType*)q;
}

void ns2__ContentIdentifierReferenceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__GuidType(soap, &this->ns2__ContentIdentifierReferenceType::cid);
	this->ns2__ContentIdentifierReferenceType::type = NULL;
	this->ns2__ContentIdentifierReferenceType::contentURL = NULL;
	this->ns2__ContentIdentifierReferenceType::mediaFileUrl = NULL;
	this->ns2__ContentIdentifierReferenceType::mediaFileForm = NULL;
	this->ns2__ContentIdentifierReferenceType::localUpdateTime = NULL;
	/* transient soap skipped */
}

void ns2__ContentIdentifierReferenceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__ContentIdentifierReferenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ContentIdentifierReferenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContentIdentifierReferenceType(struct soap *soap, const char *tag, int id, const ns2__ContentIdentifierReferenceType *a, const char *type)
{
	if (!((ns2__ContentIdentifierReferenceType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__ContentIdentifierReferenceType*)a)->cid.c_str(), 1);
	if (((ns2__ContentIdentifierReferenceType*)a)->type)
		soap_set_attr(soap, "type", soap_QName2s(soap, ((ns2__ContentIdentifierReferenceType*)a)->type->c_str()), 1);
	if (((ns2__ContentIdentifierReferenceType*)a)->contentURL)
		soap_set_attr(soap, "contentURL", ((ns2__ContentIdentifierReferenceType*)a)->contentURL->c_str(), 1);
	if (((ns2__ContentIdentifierReferenceType*)a)->mediaFileUrl)
		soap_set_attr(soap, "mediaFileUrl", ((ns2__ContentIdentifierReferenceType*)a)->mediaFileUrl->c_str(), 1);
	if (((ns2__ContentIdentifierReferenceType*)a)->mediaFileForm)
		soap_set_attr(soap, "mediaFileForm", soap_ns3__MediaFileFormType2s(soap, *((ns2__ContentIdentifierReferenceType*)a)->mediaFileForm), 1);
	if (((ns2__ContentIdentifierReferenceType*)a)->localUpdateTime)
		soap_set_attr(soap, "localUpdateTime", soap_dateTime2s(soap, *((ns2__ContentIdentifierReferenceType*)a)->localUpdateTime), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContentIdentifierReferenceType), "ns2:ContentIdentifierReferenceType"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ContentIdentifierReferenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ContentIdentifierReferenceType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ContentIdentifierReferenceType * SOAP_FMAC4 soap_in_ns2__ContentIdentifierReferenceType(struct soap *soap, const char *tag, ns2__ContentIdentifierReferenceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ContentIdentifierReferenceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContentIdentifierReferenceType, sizeof(ns2__ContentIdentifierReferenceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ContentIdentifierReferenceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ContentIdentifierReferenceType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__ContentIdentifierReferenceType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "type", 0);
		if (t)
		{
			if (!(((ns2__ContentIdentifierReferenceType*)a)->type = (xsd__QName *)soap_malloc(soap, sizeof(xsd__QName))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			char *s = NULL;
			if (soap_s2QName(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((ns2__ContentIdentifierReferenceType*)a)->type = soap_new_std__string(soap, -1);
				((ns2__ContentIdentifierReferenceType*)a)->type->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "contentURL", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((ns2__ContentIdentifierReferenceType*)a)->contentURL = soap_new_std__string(soap, -1);
				((ns2__ContentIdentifierReferenceType*)a)->contentURL->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "mediaFileUrl", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((ns2__ContentIdentifierReferenceType*)a)->mediaFileUrl = soap_new_std__string(soap, -1);
				((ns2__ContentIdentifierReferenceType*)a)->mediaFileUrl->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "mediaFileForm", 0);
		if (t)
		{
			if (!(((ns2__ContentIdentifierReferenceType*)a)->mediaFileForm = (enum ns3__MediaFileFormType *)soap_malloc(soap, sizeof(enum ns3__MediaFileFormType))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2ns3__MediaFileFormType(soap, t, ((ns2__ContentIdentifierReferenceType*)a)->mediaFileForm))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "localUpdateTime", 0);
		if (t)
		{
			if (!(((ns2__ContentIdentifierReferenceType*)a)->localUpdateTime = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, ((ns2__ContentIdentifierReferenceType*)a)->localUpdateTime))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ContentIdentifierReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContentIdentifierReferenceType, 0, sizeof(ns2__ContentIdentifierReferenceType), 0, soap_copy_ns2__ContentIdentifierReferenceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ContentIdentifierReferenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ContentIdentifierReferenceType);
	if (this->soap_out(soap, tag?tag:"ns2:ContentIdentifierReferenceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ContentIdentifierReferenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ContentIdentifierReferenceType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ContentIdentifierReferenceType * SOAP_FMAC4 soap_get_ns2__ContentIdentifierReferenceType(struct soap *soap, ns2__ContentIdentifierReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContentIdentifierReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ContentIdentifierReferenceType * SOAP_FMAC2 soap_instantiate_ns2__ContentIdentifierReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ContentIdentifierReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ContentIdentifierReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentIdentifierReferenceType);
		if (size)
			*size = sizeof(ns2__ContentIdentifierReferenceType);
		((ns2__ContentIdentifierReferenceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentIdentifierReferenceType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ContentIdentifierReferenceType);
		for (int i = 0; i < n; i++)
			((ns2__ContentIdentifierReferenceType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ContentIdentifierReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ContentIdentifierReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ContentIdentifierReferenceType %p -> %p\n", q, p));
	*(ns2__ContentIdentifierReferenceType*)p = *(ns2__ContentIdentifierReferenceType*)q;
}

void ns2__AbstractContentReferenceHolderType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AbstractContentReferenceHolderType::__unionAbstractContentReference = 0;
	/* transient soap skipped */
}

void ns2__AbstractContentReferenceHolderType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_AbstractContentReferenceHolderType(soap, this->ns2__AbstractContentReferenceHolderType::__unionAbstractContentReference, &this->ns2__AbstractContentReferenceHolderType::__union_AbstractContentReferenceHolderType);
	/* transient soap skipped */
}

int ns2__AbstractContentReferenceHolderType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AbstractContentReferenceHolderType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AbstractContentReferenceHolderType(struct soap *soap, const char *tag, int id, const ns2__AbstractContentReferenceHolderType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AbstractContentReferenceHolderType), type))
		return soap->error;
	if (soap_out__ns2__union_AbstractContentReferenceHolderType(soap, a->ns2__AbstractContentReferenceHolderType::__unionAbstractContentReference, &a->ns2__AbstractContentReferenceHolderType::__union_AbstractContentReferenceHolderType))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AbstractContentReferenceHolderType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AbstractContentReferenceHolderType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AbstractContentReferenceHolderType * SOAP_FMAC4 soap_in_ns2__AbstractContentReferenceHolderType(struct soap *soap, const char *tag, ns2__AbstractContentReferenceHolderType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AbstractContentReferenceHolderType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AbstractContentReferenceHolderType, sizeof(ns2__AbstractContentReferenceHolderType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AbstractContentReferenceHolderType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AbstractContentReferenceHolderType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___union_AbstractContentReferenceHolderType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___union_AbstractContentReferenceHolderType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_AbstractContentReferenceHolderType(soap, &a->ns2__AbstractContentReferenceHolderType::__unionAbstractContentReference, &a->ns2__AbstractContentReferenceHolderType::__union_AbstractContentReferenceHolderType))
				{	soap_flag___union_AbstractContentReferenceHolderType1 = 0;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AbstractContentReferenceHolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AbstractContentReferenceHolderType, 0, sizeof(ns2__AbstractContentReferenceHolderType), 0, soap_copy_ns2__AbstractContentReferenceHolderType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__AbstractContentReferenceHolderType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AbstractContentReferenceHolderType);
	if (this->soap_out(soap, tag?tag:"ns2:AbstractContentReferenceHolderType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AbstractContentReferenceHolderType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AbstractContentReferenceHolderType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AbstractContentReferenceHolderType * SOAP_FMAC4 soap_get_ns2__AbstractContentReferenceHolderType(struct soap *soap, ns2__AbstractContentReferenceHolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AbstractContentReferenceHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AbstractContentReferenceHolderType * SOAP_FMAC2 soap_instantiate_ns2__AbstractContentReferenceHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AbstractContentReferenceHolderType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AbstractContentReferenceHolderType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AbstractContentReferenceHolderType);
		if (size)
			*size = sizeof(ns2__AbstractContentReferenceHolderType);
		((ns2__AbstractContentReferenceHolderType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AbstractContentReferenceHolderType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AbstractContentReferenceHolderType);
		for (int i = 0; i < n; i++)
			((ns2__AbstractContentReferenceHolderType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AbstractContentReferenceHolderType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AbstractContentReferenceHolderType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AbstractContentReferenceHolderType %p -> %p\n", q, p));
	*(ns2__AbstractContentReferenceHolderType*)p = *(ns2__AbstractContentReferenceHolderType*)q;
}

void ns2__AbstractContentReferenceListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AbstractContentReferenceListType::__sizeAbstractContentReference = 0;
	this->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType = NULL;
	/* transient soap skipped */
}

void ns2__AbstractContentReferenceListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType)
	{	int i;
		for (i = 0; i < this->ns2__AbstractContentReferenceListType::__sizeAbstractContentReference; i++)
		{
			this->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int ns2__AbstractContentReferenceListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AbstractContentReferenceListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AbstractContentReferenceListType(struct soap *soap, const char *tag, int id, const ns2__AbstractContentReferenceListType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AbstractContentReferenceListType), type))
		return soap->error;
	if (a->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType)
	{	int i;
		for (i = 0; i < a->ns2__AbstractContentReferenceListType::__sizeAbstractContentReference; i++)
			if (a->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType[i].soap_out(soap, "-union-AbstractContentReferenceListType", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AbstractContentReferenceListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AbstractContentReferenceListType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AbstractContentReferenceListType * SOAP_FMAC4 soap_in_ns2__AbstractContentReferenceListType(struct soap *soap, const char *tag, ns2__AbstractContentReferenceListType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AbstractContentReferenceListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AbstractContentReferenceListType, sizeof(ns2__AbstractContentReferenceListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AbstractContentReferenceListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AbstractContentReferenceListType *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___union_AbstractContentReferenceListType1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType == NULL)
				{	if (soap_blist___union_AbstractContentReferenceListType1 == NULL)
						soap_blist___union_AbstractContentReferenceListType1 = soap_new_block(soap);
					a->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType = (__ns2__union_AbstractContentReferenceListType *)soap_push_block(soap, soap_blist___union_AbstractContentReferenceListType1, sizeof(__ns2__union_AbstractContentReferenceListType));
					if (a->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType == NULL)
						return NULL;
					__ns2__union_AbstractContentReferenceListType p;
					memcpy(a->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType, &p, sizeof(__ns2__union_AbstractContentReferenceListType)); // a bit rough but portable
					a->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType->soap_default(soap);
				}
				if (soap_in___ns2__union_AbstractContentReferenceListType(soap, "-union-AbstractContentReferenceListType", a->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType, "-ns2:union-AbstractContentReferenceListType"))
				{	a->ns2__AbstractContentReferenceListType::__sizeAbstractContentReference++;
					a->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType)
			soap_pop_block(soap, soap_blist___union_AbstractContentReferenceListType1);
		if (a->ns2__AbstractContentReferenceListType::__sizeAbstractContentReference)
			a->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType = (__ns2__union_AbstractContentReferenceListType *)soap_save_block(soap, soap_blist___union_AbstractContentReferenceListType1, NULL, 1);
		else
		{	a->ns2__AbstractContentReferenceListType::__union_AbstractContentReferenceListType = NULL;
			if (soap_blist___union_AbstractContentReferenceListType1)
				soap_end_block(soap, soap_blist___union_AbstractContentReferenceListType1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AbstractContentReferenceListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AbstractContentReferenceListType, 0, sizeof(ns2__AbstractContentReferenceListType), 0, soap_copy_ns2__AbstractContentReferenceListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__AbstractContentReferenceListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AbstractContentReferenceListType);
	if (this->soap_out(soap, tag?tag:"ns2:AbstractContentReferenceListType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AbstractContentReferenceListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AbstractContentReferenceListType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AbstractContentReferenceListType * SOAP_FMAC4 soap_get_ns2__AbstractContentReferenceListType(struct soap *soap, ns2__AbstractContentReferenceListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AbstractContentReferenceListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AbstractContentReferenceListType * SOAP_FMAC2 soap_instantiate_ns2__AbstractContentReferenceListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AbstractContentReferenceListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AbstractContentReferenceListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AbstractContentReferenceListType);
		if (size)
			*size = sizeof(ns2__AbstractContentReferenceListType);
		((ns2__AbstractContentReferenceListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AbstractContentReferenceListType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AbstractContentReferenceListType);
		for (int i = 0; i < n; i++)
			((ns2__AbstractContentReferenceListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AbstractContentReferenceListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AbstractContentReferenceListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AbstractContentReferenceListType %p -> %p\n", q, p));
	*(ns2__AbstractContentReferenceListType*)p = *(ns2__AbstractContentReferenceListType*)q;
}

void ns2__AbstractContentReferenceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns2__AbstractContentReferenceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__AbstractContentReferenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AbstractContentReferenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AbstractContentReferenceType(struct soap *soap, const char *tag, int id, const ns2__AbstractContentReferenceType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AbstractContentReferenceType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AbstractContentReferenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AbstractContentReferenceType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AbstractContentReferenceType * SOAP_FMAC4 soap_in_ns2__AbstractContentReferenceType(struct soap *soap, const char *tag, ns2__AbstractContentReferenceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AbstractContentReferenceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AbstractContentReferenceType, sizeof(ns2__AbstractContentReferenceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AbstractContentReferenceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AbstractContentReferenceType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AbstractContentReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AbstractContentReferenceType, 0, sizeof(ns2__AbstractContentReferenceType), 0, soap_copy_ns2__AbstractContentReferenceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__AbstractContentReferenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AbstractContentReferenceType);
	if (this->soap_out(soap, tag?tag:"ns2:AbstractContentReferenceType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AbstractContentReferenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AbstractContentReferenceType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AbstractContentReferenceType * SOAP_FMAC4 soap_get_ns2__AbstractContentReferenceType(struct soap *soap, ns2__AbstractContentReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AbstractContentReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AbstractContentReferenceType * SOAP_FMAC2 soap_instantiate_ns2__AbstractContentReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AbstractContentReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AbstractContentReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns2:ContentIdentifierReferenceType"))
	{	cp->type = SOAP_TYPE_ns2__ContentIdentifierReferenceType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ContentIdentifierReferenceType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__ContentIdentifierReferenceType);
			((ns2__ContentIdentifierReferenceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__ContentIdentifierReferenceType[n]);
			if (size)
				*size = n * sizeof(ns2__ContentIdentifierReferenceType);
			for (int i = 0; i < n; i++)
				((ns2__ContentIdentifierReferenceType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__ContentIdentifierReferenceType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AbstractContentReferenceType);
		if (size)
			*size = sizeof(ns2__AbstractContentReferenceType);
		((ns2__AbstractContentReferenceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__AbstractContentReferenceType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__AbstractContentReferenceType);
		for (int i = 0; i < n; i++)
			((ns2__AbstractContentReferenceType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__AbstractContentReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AbstractContentReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AbstractContentReferenceType %p -> %p\n", q, p));
	*(ns2__AbstractContentReferenceType*)p = *(ns2__AbstractContentReferenceType*)q;
}

void ns2__UnitType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__UnitType::__item);
	/* transient soap skipped */
}

void ns2__UnitType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__UnitType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__UnitType::__item);
	/* transient soap skipped */
}

int ns2__UnitType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__UnitType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UnitType(struct soap *soap, const char *tag, int id, const ns2__UnitType *a, const char *type)
{
	return soap_out_std__string(soap, tag, id, &a->ns2__UnitType::__item, "");
}

void *ns2__UnitType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__UnitType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__UnitType * SOAP_FMAC4 soap_in_ns2__UnitType(struct soap *soap, const char *tag, ns2__UnitType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__UnitType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UnitType, sizeof(ns2__UnitType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__UnitType)
			return (ns2__UnitType *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_std__string(soap, tag, &(a->ns2__UnitType::__item), "ns2:UnitType"))
		return NULL;
	return a;
}

int ns2__UnitType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__UnitType);
	if (this->soap_out(soap, tag?tag:"ns2:UnitType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__UnitType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__UnitType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__UnitType * SOAP_FMAC4 soap_get_ns2__UnitType(struct soap *soap, ns2__UnitType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UnitType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__UnitType * SOAP_FMAC2 soap_instantiate_ns2__UnitType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__UnitType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__UnitType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__UnitType);
		if (size)
			*size = sizeof(ns2__UnitType);
		((ns2__UnitType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__UnitType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__UnitType);
		for (int i = 0; i < n; i++)
			((ns2__UnitType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__UnitType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__UnitType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__UnitType %p -> %p\n", q, p));
	*(ns2__UnitType*)p = *(ns2__UnitType*)q;
}

void ns2__ContentVersionInfoListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ContentVersionInfoListType::created = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(soap, &this->ns2__ContentVersionInfoListType::revised);
	/* transient soap skipped */
}

void ns2__ContentVersionInfoListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ContentVersionInfoType(soap, &this->ns2__ContentVersionInfoListType::created);
	soap_serialize_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(soap, &this->ns2__ContentVersionInfoListType::revised);
	/* transient soap skipped */
}

int ns2__ContentVersionInfoListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ContentVersionInfoListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContentVersionInfoListType(struct soap *soap, const char *tag, int id, const ns2__ContentVersionInfoListType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContentVersionInfoListType), type))
		return soap->error;
	if (soap_out_PointerTons2__ContentVersionInfoType(soap, "ns2:created", -1, &(a->ns2__ContentVersionInfoListType::created), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(soap, "ns2:revised", -1, &(a->ns2__ContentVersionInfoListType::revised), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ContentVersionInfoListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ContentVersionInfoListType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ContentVersionInfoListType * SOAP_FMAC4 soap_in_ns2__ContentVersionInfoListType(struct soap *soap, const char *tag, ns2__ContentVersionInfoListType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ContentVersionInfoListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContentVersionInfoListType, sizeof(ns2__ContentVersionInfoListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ContentVersionInfoListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ContentVersionInfoListType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_created1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_created1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentVersionInfoType(soap, "ns2:created", &(a->ns2__ContentVersionInfoListType::created), "ns2:ContentVersionInfoType"))
				{	soap_flag_created1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(soap, "ns2:revised", &(a->ns2__ContentVersionInfoListType::revised), "ns2:ContentVersionInfoType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ContentVersionInfoListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContentVersionInfoListType, 0, sizeof(ns2__ContentVersionInfoListType), 0, soap_copy_ns2__ContentVersionInfoListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_created1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ContentVersionInfoListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ContentVersionInfoListType);
	if (this->soap_out(soap, tag?tag:"ns2:ContentVersionInfoListType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ContentVersionInfoListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ContentVersionInfoListType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ContentVersionInfoListType * SOAP_FMAC4 soap_get_ns2__ContentVersionInfoListType(struct soap *soap, ns2__ContentVersionInfoListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContentVersionInfoListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ContentVersionInfoListType * SOAP_FMAC2 soap_instantiate_ns2__ContentVersionInfoListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ContentVersionInfoListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ContentVersionInfoListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentVersionInfoListType);
		if (size)
			*size = sizeof(ns2__ContentVersionInfoListType);
		((ns2__ContentVersionInfoListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentVersionInfoListType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ContentVersionInfoListType);
		for (int i = 0; i < n; i++)
			((ns2__ContentVersionInfoListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ContentVersionInfoListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ContentVersionInfoListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ContentVersionInfoListType %p -> %p\n", q, p));
	*(ns2__ContentVersionInfoListType*)p = *(ns2__ContentVersionInfoListType*)q;
}

void ns2__ContentVersionInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__NonEmptyStringType(soap, &this->ns2__ContentVersionInfoType::userName);
	soap_default_time(soap, &this->ns2__ContentVersionInfoType::dateTime);
	this->ns2__ContentVersionInfoType::userInfo = NULL;
	/* transient soap skipped */
}

void ns2__ContentVersionInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__ContentVersionInfoType::userName, SOAP_TYPE_ns3__NonEmptyStringType);
	soap_serialize_ns3__NonEmptyStringType(soap, &this->ns2__ContentVersionInfoType::userName);
	soap_embedded(soap, &this->ns2__ContentVersionInfoType::dateTime, SOAP_TYPE_time);
	soap_serialize_PointerTons2__UserInfoType(soap, &this->ns2__ContentVersionInfoType::userInfo);
	/* transient soap skipped */
}

int ns2__ContentVersionInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ContentVersionInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContentVersionInfoType(struct soap *soap, const char *tag, int id, const ns2__ContentVersionInfoType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContentVersionInfoType), type))
		return soap->error;
	if (soap_out_ns3__NonEmptyStringType(soap, "ns2:userName", -1, &(a->ns2__ContentVersionInfoType::userName), ""))
		return soap->error;
	if (soap_out_time(soap, "ns2:dateTime", -1, &(a->ns2__ContentVersionInfoType::dateTime), ""))
		return soap->error;
	if (soap_out_PointerTons2__UserInfoType(soap, "ns2:userInfo", -1, &(a->ns2__ContentVersionInfoType::userInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ContentVersionInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ContentVersionInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ContentVersionInfoType * SOAP_FMAC4 soap_in_ns2__ContentVersionInfoType(struct soap *soap, const char *tag, ns2__ContentVersionInfoType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ContentVersionInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContentVersionInfoType, sizeof(ns2__ContentVersionInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ContentVersionInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ContentVersionInfoType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_dateTime1 = 1;
	size_t soap_flag_userInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__NonEmptyStringType(soap, "ns2:userName", &(a->ns2__ContentVersionInfoType::userName), "ns3:NonEmptyStringType"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "ns2:dateTime", &(a->ns2__ContentVersionInfoType::dateTime), "xsd:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap_flag_userInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UserInfoType(soap, "ns2:userInfo", &(a->ns2__ContentVersionInfoType::userInfo), "ns2:UserInfoType"))
				{	soap_flag_userInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ContentVersionInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContentVersionInfoType, 0, sizeof(ns2__ContentVersionInfoType), 0, soap_copy_ns2__ContentVersionInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userName1 > 0 || soap_flag_dateTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ContentVersionInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ContentVersionInfoType);
	if (this->soap_out(soap, tag?tag:"ns2:ContentVersionInfoType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ContentVersionInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ContentVersionInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ContentVersionInfoType * SOAP_FMAC4 soap_get_ns2__ContentVersionInfoType(struct soap *soap, ns2__ContentVersionInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContentVersionInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ContentVersionInfoType * SOAP_FMAC2 soap_instantiate_ns2__ContentVersionInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ContentVersionInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ContentVersionInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentVersionInfoType);
		if (size)
			*size = sizeof(ns2__ContentVersionInfoType);
		((ns2__ContentVersionInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentVersionInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ContentVersionInfoType);
		for (int i = 0; i < n; i++)
			((ns2__ContentVersionInfoType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ContentVersionInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ContentVersionInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ContentVersionInfoType %p -> %p\n", q, p));
	*(ns2__ContentVersionInfoType*)p = *(ns2__ContentVersionInfoType*)q;
}

void ns2__UserInfoType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__UserInfoType::firstName);
	soap_default_std__string(soap, &this->ns2__UserInfoType::lastName);
	soap_default_std__string(soap, &this->ns2__UserInfoType::title);
	soap_default_std__string(soap, &this->ns2__UserInfoType::email);
	/* transient soap skipped */
}

void ns2__UserInfoType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__UserInfoType::firstName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__UserInfoType::firstName);
	soap_embedded(soap, &this->ns2__UserInfoType::lastName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__UserInfoType::lastName);
	soap_embedded(soap, &this->ns2__UserInfoType::title, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__UserInfoType::title);
	soap_embedded(soap, &this->ns2__UserInfoType::email, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__UserInfoType::email);
	/* transient soap skipped */
}

int ns2__UserInfoType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__UserInfoType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UserInfoType(struct soap *soap, const char *tag, int id, const ns2__UserInfoType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UserInfoType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:firstName", -1, &(a->ns2__UserInfoType::firstName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:lastName", -1, &(a->ns2__UserInfoType::lastName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:title", -1, &(a->ns2__UserInfoType::title), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:email", -1, &(a->ns2__UserInfoType::email), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__UserInfoType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__UserInfoType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__UserInfoType * SOAP_FMAC4 soap_in_ns2__UserInfoType(struct soap *soap, const char *tag, ns2__UserInfoType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__UserInfoType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UserInfoType, sizeof(ns2__UserInfoType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__UserInfoType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__UserInfoType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_firstName1 = 1;
	size_t soap_flag_lastName1 = 1;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:firstName", &(a->ns2__UserInfoType::firstName), "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:lastName", &(a->ns2__UserInfoType::lastName), "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:title", &(a->ns2__UserInfoType::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:email", &(a->ns2__UserInfoType::email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__UserInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UserInfoType, 0, sizeof(ns2__UserInfoType), 0, soap_copy_ns2__UserInfoType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_firstName1 > 0 || soap_flag_lastName1 > 0 || soap_flag_title1 > 0 || soap_flag_email1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__UserInfoType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__UserInfoType);
	if (this->soap_out(soap, tag?tag:"ns2:UserInfoType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__UserInfoType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__UserInfoType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__UserInfoType * SOAP_FMAC4 soap_get_ns2__UserInfoType(struct soap *soap, ns2__UserInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UserInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__UserInfoType * SOAP_FMAC2 soap_instantiate_ns2__UserInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__UserInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__UserInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__UserInfoType);
		if (size)
			*size = sizeof(ns2__UserInfoType);
		((ns2__UserInfoType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__UserInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__UserInfoType);
		for (int i = 0; i < n; i++)
			((ns2__UserInfoType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__UserInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__UserInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__UserInfoType %p -> %p\n", q, p));
	*(ns2__UserInfoType*)p = *(ns2__UserInfoType*)q;
}

void ns2__ExternalIdType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__ExternalIdType::source);
	soap_default_std__string(soap, &this->ns2__ExternalIdType::id);
	/* transient soap skipped */
}

void ns2__ExternalIdType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__ExternalIdType::source, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__ExternalIdType::source);
	soap_embedded(soap, &this->ns2__ExternalIdType::id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__ExternalIdType::id);
	/* transient soap skipped */
}

int ns2__ExternalIdType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ExternalIdType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ExternalIdType(struct soap *soap, const char *tag, int id, const ns2__ExternalIdType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ExternalIdType), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:source", -1, &(a->ns2__ExternalIdType::source), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ns2:id", -1, &(a->ns2__ExternalIdType::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ExternalIdType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ExternalIdType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ExternalIdType * SOAP_FMAC4 soap_in_ns2__ExternalIdType(struct soap *soap, const char *tag, ns2__ExternalIdType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ExternalIdType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ExternalIdType, sizeof(ns2__ExternalIdType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ExternalIdType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ExternalIdType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_source1 = 1;
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_source1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:source", &(a->ns2__ExternalIdType::source), "xsd:string"))
				{	soap_flag_source1--;
					continue;
				}
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns2:id", &(a->ns2__ExternalIdType::id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ExternalIdType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ExternalIdType, 0, sizeof(ns2__ExternalIdType), 0, soap_copy_ns2__ExternalIdType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_source1 > 0 || soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ExternalIdType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ExternalIdType);
	if (this->soap_out(soap, tag?tag:"ns2:ExternalIdType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ExternalIdType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ExternalIdType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ExternalIdType * SOAP_FMAC4 soap_get_ns2__ExternalIdType(struct soap *soap, ns2__ExternalIdType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ExternalIdType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ExternalIdType * SOAP_FMAC2 soap_instantiate_ns2__ExternalIdType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ExternalIdType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ExternalIdType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ExternalIdType);
		if (size)
			*size = sizeof(ns2__ExternalIdType);
		((ns2__ExternalIdType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ExternalIdType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ExternalIdType);
		for (int i = 0; i < n; i++)
			((ns2__ExternalIdType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ExternalIdType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ExternalIdType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ExternalIdType %p -> %p\n", q, p));
	*(ns2__ExternalIdType*)p = *(ns2__ExternalIdType*)q;
}

void ns2__SecurityInfoListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns2__SecurityInfoListType::securityInfo);
	/* transient soap skipped */
}

void ns2__SecurityInfoListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns2__SecurityInfoListType::securityInfo);
	/* transient soap skipped */
}

int ns2__SecurityInfoListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SecurityInfoListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SecurityInfoListType(struct soap *soap, const char *tag, int id, const ns2__SecurityInfoListType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SecurityInfoListType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns2:securityInfo", -1, &(a->ns2__SecurityInfoListType::securityInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SecurityInfoListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SecurityInfoListType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SecurityInfoListType * SOAP_FMAC4 soap_in_ns2__SecurityInfoListType(struct soap *soap, const char *tag, ns2__SecurityInfoListType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SecurityInfoListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SecurityInfoListType, sizeof(ns2__SecurityInfoListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SecurityInfoListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SecurityInfoListType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns2:securityInfo", &(a->ns2__SecurityInfoListType::securityInfo), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SecurityInfoListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SecurityInfoListType, 0, sizeof(ns2__SecurityInfoListType), 0, soap_copy_ns2__SecurityInfoListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__SecurityInfoListType::securityInfo.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SecurityInfoListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SecurityInfoListType);
	if (this->soap_out(soap, tag?tag:"ns2:SecurityInfoListType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SecurityInfoListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SecurityInfoListType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SecurityInfoListType * SOAP_FMAC4 soap_get_ns2__SecurityInfoListType(struct soap *soap, ns2__SecurityInfoListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SecurityInfoListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SecurityInfoListType * SOAP_FMAC2 soap_instantiate_ns2__SecurityInfoListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SecurityInfoListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SecurityInfoListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SecurityInfoListType);
		if (size)
			*size = sizeof(ns2__SecurityInfoListType);
		((ns2__SecurityInfoListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SecurityInfoListType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SecurityInfoListType);
		for (int i = 0; i < n; i++)
			((ns2__SecurityInfoListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SecurityInfoListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SecurityInfoListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SecurityInfoListType %p -> %p\n", q, p));
	*(ns2__SecurityInfoListType*)p = *(ns2__SecurityInfoListType*)q;
}

void ns2__ContentAssociationModelListType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(soap, &this->ns2__ContentAssociationModelListType::association);
	/* transient soap skipped */
}

void ns2__ContentAssociationModelListType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(soap, &this->ns2__ContentAssociationModelListType::association);
	/* transient soap skipped */
}

int ns2__ContentAssociationModelListType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ContentAssociationModelListType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContentAssociationModelListType(struct soap *soap, const char *tag, int id, const ns2__ContentAssociationModelListType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContentAssociationModelListType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(soap, "ns2:association", -1, &(a->ns2__ContentAssociationModelListType::association), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ContentAssociationModelListType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ContentAssociationModelListType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ContentAssociationModelListType * SOAP_FMAC4 soap_in_ns2__ContentAssociationModelListType(struct soap *soap, const char *tag, ns2__ContentAssociationModelListType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ContentAssociationModelListType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContentAssociationModelListType, sizeof(ns2__ContentAssociationModelListType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ContentAssociationModelListType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ContentAssociationModelListType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(soap, "ns2:association", &(a->ns2__ContentAssociationModelListType::association), "ns2:ContentAssociationModelType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ContentAssociationModelListType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContentAssociationModelListType, 0, sizeof(ns2__ContentAssociationModelListType), 0, soap_copy_ns2__ContentAssociationModelListType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__ContentAssociationModelListType::association.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ContentAssociationModelListType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ContentAssociationModelListType);
	if (this->soap_out(soap, tag?tag:"ns2:ContentAssociationModelListType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ContentAssociationModelListType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ContentAssociationModelListType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ContentAssociationModelListType * SOAP_FMAC4 soap_get_ns2__ContentAssociationModelListType(struct soap *soap, ns2__ContentAssociationModelListType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContentAssociationModelListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ContentAssociationModelListType * SOAP_FMAC2 soap_instantiate_ns2__ContentAssociationModelListType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ContentAssociationModelListType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ContentAssociationModelListType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentAssociationModelListType);
		if (size)
			*size = sizeof(ns2__ContentAssociationModelListType);
		((ns2__ContentAssociationModelListType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentAssociationModelListType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ContentAssociationModelListType);
		for (int i = 0; i < n; i++)
			((ns2__ContentAssociationModelListType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ContentAssociationModelListType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ContentAssociationModelListType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ContentAssociationModelListType %p -> %p\n", q, p));
	*(ns2__ContentAssociationModelListType*)p = *(ns2__ContentAssociationModelListType*)q;
}

void ns2__ContentAssociationModelMemberType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__QName(soap, &this->ns2__ContentAssociationModelMemberType::typeName);
	soap_default_ns2__CardinalityType(soap, &this->ns2__ContentAssociationModelMemberType::cardinality);
	this->ns2__ContentAssociationModelMemberType::associationPropertyName = NULL;
	/* transient soap skipped */
}

void ns2__ContentAssociationModelMemberType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__ContentAssociationModelMemberType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ContentAssociationModelMemberType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContentAssociationModelMemberType(struct soap *soap, const char *tag, int id, const ns2__ContentAssociationModelMemberType *a, const char *type)
{
	if (!((ns2__ContentAssociationModelMemberType*)a)->typeName.empty())
		soap_set_attr(soap, "typeName", soap_QName2s(soap, ((ns2__ContentAssociationModelMemberType*)a)->typeName.c_str()), 1);
	soap_set_attr(soap, "cardinality", soap_ns2__CardinalityType2s(soap, ((ns2__ContentAssociationModelMemberType*)a)->cardinality), 1);
	if (((ns2__ContentAssociationModelMemberType*)a)->associationPropertyName)
		soap_set_attr(soap, "associationPropertyName", ((ns2__ContentAssociationModelMemberType*)a)->associationPropertyName->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContentAssociationModelMemberType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ContentAssociationModelMemberType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ContentAssociationModelMemberType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ContentAssociationModelMemberType * SOAP_FMAC4 soap_in_ns2__ContentAssociationModelMemberType(struct soap *soap, const char *tag, ns2__ContentAssociationModelMemberType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ContentAssociationModelMemberType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContentAssociationModelMemberType, sizeof(ns2__ContentAssociationModelMemberType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ContentAssociationModelMemberType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ContentAssociationModelMemberType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "typeName", 1);
		if (t)
		{	char *s;
			if (soap_s2QName(soap, t, &s, -1, -1))
				return NULL;
			((ns2__ContentAssociationModelMemberType*)a)->typeName.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2ns2__CardinalityType(soap, soap_attr_value(soap, "cardinality", 1), &((ns2__ContentAssociationModelMemberType*)a)->cardinality))
		return NULL;
	{	const char *t = soap_attr_value(soap, "associationPropertyName", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((ns2__ContentAssociationModelMemberType*)a)->associationPropertyName = soap_new_std__string(soap, -1);
				((ns2__ContentAssociationModelMemberType*)a)->associationPropertyName->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ContentAssociationModelMemberType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContentAssociationModelMemberType, 0, sizeof(ns2__ContentAssociationModelMemberType), 0, soap_copy_ns2__ContentAssociationModelMemberType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ContentAssociationModelMemberType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ContentAssociationModelMemberType);
	if (this->soap_out(soap, tag?tag:"ns2:ContentAssociationModelMemberType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ContentAssociationModelMemberType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ContentAssociationModelMemberType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ContentAssociationModelMemberType * SOAP_FMAC4 soap_get_ns2__ContentAssociationModelMemberType(struct soap *soap, ns2__ContentAssociationModelMemberType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContentAssociationModelMemberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ContentAssociationModelMemberType * SOAP_FMAC2 soap_instantiate_ns2__ContentAssociationModelMemberType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ContentAssociationModelMemberType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ContentAssociationModelMemberType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentAssociationModelMemberType);
		if (size)
			*size = sizeof(ns2__ContentAssociationModelMemberType);
		((ns2__ContentAssociationModelMemberType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentAssociationModelMemberType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ContentAssociationModelMemberType);
		for (int i = 0; i < n; i++)
			((ns2__ContentAssociationModelMemberType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ContentAssociationModelMemberType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ContentAssociationModelMemberType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ContentAssociationModelMemberType %p -> %p\n", q, p));
	*(ns2__ContentAssociationModelMemberType*)p = *(ns2__ContentAssociationModelMemberType*)q;
}

void ns2__ContentAssociationModelType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ContentAssociationModelType::parent = NULL;
	this->ns2__ContentAssociationModelType::child = NULL;
	/* transient soap skipped */
}

void ns2__ContentAssociationModelType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ContentAssociationModelMemberType(soap, &this->ns2__ContentAssociationModelType::parent);
	soap_serialize_PointerTons2__ContentAssociationModelMemberType(soap, &this->ns2__ContentAssociationModelType::child);
	/* transient soap skipped */
}

int ns2__ContentAssociationModelType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ContentAssociationModelType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContentAssociationModelType(struct soap *soap, const char *tag, int id, const ns2__ContentAssociationModelType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContentAssociationModelType), type))
		return soap->error;
	if (soap_out_PointerTons2__ContentAssociationModelMemberType(soap, "ns2:parent", -1, &(a->ns2__ContentAssociationModelType::parent), ""))
		return soap->error;
	if (soap_out_PointerTons2__ContentAssociationModelMemberType(soap, "ns2:child", -1, &(a->ns2__ContentAssociationModelType::child), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ContentAssociationModelType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ContentAssociationModelType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ContentAssociationModelType * SOAP_FMAC4 soap_in_ns2__ContentAssociationModelType(struct soap *soap, const char *tag, ns2__ContentAssociationModelType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ContentAssociationModelType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContentAssociationModelType, sizeof(ns2__ContentAssociationModelType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ContentAssociationModelType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ContentAssociationModelType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_parent1 = 1;
	size_t soap_flag_child1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_parent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentAssociationModelMemberType(soap, "ns2:parent", &(a->ns2__ContentAssociationModelType::parent), "ns2:ContentAssociationModelMemberType"))
				{	soap_flag_parent1--;
					continue;
				}
			if (soap_flag_child1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentAssociationModelMemberType(soap, "ns2:child", &(a->ns2__ContentAssociationModelType::child), "ns2:ContentAssociationModelMemberType"))
				{	soap_flag_child1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ContentAssociationModelType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContentAssociationModelType, 0, sizeof(ns2__ContentAssociationModelType), 0, soap_copy_ns2__ContentAssociationModelType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_parent1 > 0 || soap_flag_child1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ContentAssociationModelType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ContentAssociationModelType);
	if (this->soap_out(soap, tag?tag:"ns2:ContentAssociationModelType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ContentAssociationModelType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ContentAssociationModelType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ContentAssociationModelType * SOAP_FMAC4 soap_get_ns2__ContentAssociationModelType(struct soap *soap, ns2__ContentAssociationModelType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContentAssociationModelType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ContentAssociationModelType * SOAP_FMAC2 soap_instantiate_ns2__ContentAssociationModelType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ContentAssociationModelType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ContentAssociationModelType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentAssociationModelType);
		if (size)
			*size = sizeof(ns2__ContentAssociationModelType);
		((ns2__ContentAssociationModelType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentAssociationModelType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ContentAssociationModelType);
		for (int i = 0; i < n; i++)
			((ns2__ContentAssociationModelType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ContentAssociationModelType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ContentAssociationModelType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ContentAssociationModelType %p -> %p\n", q, p));
	*(ns2__ContentAssociationModelType*)p = *(ns2__ContentAssociationModelType*)q;
}

void ns2__ContentServiceCapabilitiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__positiveInteger(soap, &this->ns2__ContentServiceCapabilitiesType::maxResultsLimit);
	soap_default_xsd__anyURI(soap, &this->ns2__ContentServiceCapabilitiesType::defaultCRS);
	soap_default_ns3__URIListType(soap, &this->ns2__ContentServiceCapabilitiesType::supportedCRSList);
	soap_default_ns3__QNameListType(soap, &this->ns2__ContentServiceCapabilitiesType::contentTypes);
	this->ns2__ContentServiceCapabilitiesType::contentAssociationModels = NULL;
	this->ns2__ContentServiceCapabilitiesType::securityInfoList = NULL;
	soap_default_ns3__VersionType(soap, &this->ns3__BaseServiceCapabilitiesType::version);
	/* transient soap skipped */
}

void ns2__ContentServiceCapabilitiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__positiveInteger(soap, &this->ns2__ContentServiceCapabilitiesType::maxResultsLimit);
	soap_embedded(soap, &this->ns2__ContentServiceCapabilitiesType::defaultCRS, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->ns2__ContentServiceCapabilitiesType::defaultCRS);
	soap_serialize_ns3__URIListType(soap, &this->ns2__ContentServiceCapabilitiesType::supportedCRSList);
	soap_serialize_ns3__QNameListType(soap, &this->ns2__ContentServiceCapabilitiesType::contentTypes);
	soap_serialize_PointerTons2__ContentAssociationModelListType(soap, &this->ns2__ContentServiceCapabilitiesType::contentAssociationModels);
	soap_serialize_PointerTons2__SecurityInfoListType(soap, &this->ns2__ContentServiceCapabilitiesType::securityInfoList);
	/* transient soap skipped */
}

int ns2__ContentServiceCapabilitiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ContentServiceCapabilitiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContentServiceCapabilitiesType(struct soap *soap, const char *tag, int id, const ns2__ContentServiceCapabilitiesType *a, const char *type)
{
	if (!((ns3__BaseServiceCapabilitiesType*)a)->version.empty())
		soap_set_attr(soap, "version", ((ns3__BaseServiceCapabilitiesType*)a)->version.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContentServiceCapabilitiesType), "ns2:ContentServiceCapabilitiesType"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "ns2:maxResultsLimit");
	if (soap_out_xsd__positiveInteger(soap, "ns2:maxResultsLimit", -1, &(a->ns2__ContentServiceCapabilitiesType::maxResultsLimit), ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "ns2:defaultCRS", -1, &(a->ns2__ContentServiceCapabilitiesType::defaultCRS), ""))
		return soap->error;
	if (soap_out_ns3__URIListType(soap, "ns2:supportedCRSList", -1, &(a->ns2__ContentServiceCapabilitiesType::supportedCRSList), ""))
		return soap->error;
	if (soap_out_ns3__QNameListType(soap, "ns2:contentTypes", -1, &(a->ns2__ContentServiceCapabilitiesType::contentTypes), ""))
		return soap->error;
	if (soap_out_PointerTons2__ContentAssociationModelListType(soap, "ns2:contentAssociationModels", -1, &(a->ns2__ContentServiceCapabilitiesType::contentAssociationModels), ""))
		return soap->error;
	if (soap_out_PointerTons2__SecurityInfoListType(soap, "ns2:securityInfoList", -1, &(a->ns2__ContentServiceCapabilitiesType::securityInfoList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ContentServiceCapabilitiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ContentServiceCapabilitiesType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ContentServiceCapabilitiesType * SOAP_FMAC4 soap_in_ns2__ContentServiceCapabilitiesType(struct soap *soap, const char *tag, ns2__ContentServiceCapabilitiesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ContentServiceCapabilitiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContentServiceCapabilitiesType, sizeof(ns2__ContentServiceCapabilitiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ContentServiceCapabilitiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ContentServiceCapabilitiesType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "version", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns3__BaseServiceCapabilitiesType*)a)->version.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_maxResultsLimit1 = 1;
	size_t soap_flag_defaultCRS1 = 1;
	size_t soap_flag_supportedCRSList1 = 1;
	size_t soap_flag_contentTypes1 = 1;
	size_t soap_flag_contentAssociationModels1 = 1;
	size_t soap_flag_securityInfoList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_maxResultsLimit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__positiveInteger(soap, "ns2:maxResultsLimit", &(a->ns2__ContentServiceCapabilitiesType::maxResultsLimit), "xsd:positiveInteger"))
				{	soap_flag_maxResultsLimit1--;
					continue;
				}
			if (soap_flag_defaultCRS1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "ns2:defaultCRS", &(a->ns2__ContentServiceCapabilitiesType::defaultCRS), "xsd:anyURI"))
				{	soap_flag_defaultCRS1--;
					continue;
				}
			if (soap_flag_supportedCRSList1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__URIListType(soap, "ns2:supportedCRSList", &(a->ns2__ContentServiceCapabilitiesType::supportedCRSList), "ns3:URIListType"))
				{	soap_flag_supportedCRSList1--;
					continue;
				}
			if (soap_flag_contentTypes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__QNameListType(soap, "ns2:contentTypes", &(a->ns2__ContentServiceCapabilitiesType::contentTypes), "ns3:QNameListType"))
				{	soap_flag_contentTypes1--;
					continue;
				}
			if (soap_flag_contentAssociationModels1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentAssociationModelListType(soap, "ns2:contentAssociationModels", &(a->ns2__ContentServiceCapabilitiesType::contentAssociationModels), "ns2:ContentAssociationModelListType"))
				{	soap_flag_contentAssociationModels1--;
					continue;
				}
			if (soap_flag_securityInfoList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SecurityInfoListType(soap, "ns2:securityInfoList", &(a->ns2__ContentServiceCapabilitiesType::securityInfoList), "ns2:SecurityInfoListType"))
				{	soap_flag_securityInfoList1--;
					continue;
				}
			soap_check_result(soap, "ns2:maxResultsLimit");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ContentServiceCapabilitiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContentServiceCapabilitiesType, 0, sizeof(ns2__ContentServiceCapabilitiesType), 0, soap_copy_ns2__ContentServiceCapabilitiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_maxResultsLimit1 > 0 || soap_flag_defaultCRS1 > 0 || soap_flag_supportedCRSList1 > 0 || soap_flag_contentTypes1 > 0 || soap_flag_contentAssociationModels1 > 0 || soap_flag_securityInfoList1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ContentServiceCapabilitiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ContentServiceCapabilitiesType);
	if (this->soap_out(soap, tag?tag:"ns2:ContentServiceCapabilitiesType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ContentServiceCapabilitiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ContentServiceCapabilitiesType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ContentServiceCapabilitiesType * SOAP_FMAC4 soap_get_ns2__ContentServiceCapabilitiesType(struct soap *soap, ns2__ContentServiceCapabilitiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContentServiceCapabilitiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ContentServiceCapabilitiesType * SOAP_FMAC2 soap_instantiate_ns2__ContentServiceCapabilitiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ContentServiceCapabilitiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ContentServiceCapabilitiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentServiceCapabilitiesType);
		if (size)
			*size = sizeof(ns2__ContentServiceCapabilitiesType);
		((ns2__ContentServiceCapabilitiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentServiceCapabilitiesType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ContentServiceCapabilitiesType);
		for (int i = 0; i < n; i++)
			((ns2__ContentServiceCapabilitiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ContentServiceCapabilitiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ContentServiceCapabilitiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ContentServiceCapabilitiesType %p -> %p\n", q, p));
	*(ns2__ContentServiceCapabilitiesType*)p = *(ns2__ContentServiceCapabilitiesType*)q;
}

void ns2__GetResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__GetResponseType::__size_GetResponseType = 0;
	this->ns2__GetResponseType::__union_GetResponseType = NULL;
	soap_default_xsd__nonNegativeInteger(soap, &this->ns2__GetResponseType::count);
	this->ns2__GetResponseType::first = NULL;
	this->ns2__GetResponseType::last = NULL;
	this->ns2__GetResponseType::newestLocalUpdateTime = NULL;
	/* transient soap skipped */
}

void ns2__GetResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns2__GetResponseType::__union_GetResponseType)
	{	int i;
		for (i = 0; i < this->ns2__GetResponseType::__size_GetResponseType; i++)
		{
			this->ns2__GetResponseType::__union_GetResponseType[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int ns2__GetResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__GetResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__GetResponseType(struct soap *soap, const char *tag, int id, const ns2__GetResponseType *a, const char *type)
{
	if (!((ns2__GetResponseType*)a)->count.empty())
		soap_set_attr(soap, "count", ((ns2__GetResponseType*)a)->count.c_str(), 1);
	if (((ns2__GetResponseType*)a)->first)
		soap_set_attr(soap, "first", ((ns2__GetResponseType*)a)->first->c_str(), 1);
	if (((ns2__GetResponseType*)a)->last)
		soap_set_attr(soap, "last", ((ns2__GetResponseType*)a)->last->c_str(), 1);
	if (((ns2__GetResponseType*)a)->newestLocalUpdateTime)
		soap_set_attr(soap, "newestLocalUpdateTime", soap_dateTime2s(soap, *((ns2__GetResponseType*)a)->newestLocalUpdateTime), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__GetResponseType), type))
		return soap->error;
	soap_element_result(soap, "-size-GetResponseType");
	if (a->ns2__GetResponseType::__union_GetResponseType)
	{	int i;
		for (i = 0; i < a->ns2__GetResponseType::__size_GetResponseType; i++)
			if (a->ns2__GetResponseType::__union_GetResponseType[i].soap_out(soap, "-union-GetResponseType", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__GetResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__GetResponseType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__GetResponseType * SOAP_FMAC4 soap_in_ns2__GetResponseType(struct soap *soap, const char *tag, ns2__GetResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__GetResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__GetResponseType, sizeof(ns2__GetResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__GetResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__GetResponseType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__GetResponseType*)a)->count.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "first", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((ns2__GetResponseType*)a)->first = soap_new_std__string(soap, -1);
				((ns2__GetResponseType*)a)->first->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "last", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((ns2__GetResponseType*)a)->last = soap_new_std__string(soap, -1);
				((ns2__GetResponseType*)a)->last->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "newestLocalUpdateTime", 0);
		if (t)
		{
			if (!(((ns2__GetResponseType*)a)->newestLocalUpdateTime = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, ((ns2__GetResponseType*)a)->newestLocalUpdateTime))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	struct soap_blist *soap_blist___union_GetResponseType1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->ns2__GetResponseType::__union_GetResponseType == NULL)
				{	if (soap_blist___union_GetResponseType1 == NULL)
						soap_blist___union_GetResponseType1 = soap_new_block(soap);
					a->ns2__GetResponseType::__union_GetResponseType = (__ns2__union_GetResponseType *)soap_push_block(soap, soap_blist___union_GetResponseType1, sizeof(__ns2__union_GetResponseType));
					if (a->ns2__GetResponseType::__union_GetResponseType == NULL)
						return NULL;
					__ns2__union_GetResponseType p;
					memcpy(a->ns2__GetResponseType::__union_GetResponseType, &p, sizeof(__ns2__union_GetResponseType)); // a bit rough but portable
					a->ns2__GetResponseType::__union_GetResponseType->soap_default(soap);
				}
				if (soap_in___ns2__union_GetResponseType(soap, "-union-GetResponseType", a->ns2__GetResponseType::__union_GetResponseType, "-ns2:union-GetResponseType"))
				{	a->ns2__GetResponseType::__size_GetResponseType++;
					a->ns2__GetResponseType::__union_GetResponseType = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-size-GetResponseType");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ns2__GetResponseType::__union_GetResponseType)
			soap_pop_block(soap, soap_blist___union_GetResponseType1);
		if (a->ns2__GetResponseType::__size_GetResponseType)
			a->ns2__GetResponseType::__union_GetResponseType = (__ns2__union_GetResponseType *)soap_save_block(soap, soap_blist___union_GetResponseType1, NULL, 1);
		else
		{	a->ns2__GetResponseType::__union_GetResponseType = NULL;
			if (soap_blist___union_GetResponseType1)
				soap_end_block(soap, soap_blist___union_GetResponseType1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__GetResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__GetResponseType, 0, sizeof(ns2__GetResponseType), 0, soap_copy_ns2__GetResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__GetResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__GetResponseType);
	if (this->soap_out(soap, tag?tag:"ns2:GetResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__GetResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__GetResponseType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__GetResponseType * SOAP_FMAC4 soap_get_ns2__GetResponseType(struct soap *soap, ns2__GetResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__GetResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__GetResponseType * SOAP_FMAC2 soap_instantiate_ns2__GetResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__GetResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__GetResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__GetResponseType);
		if (size)
			*size = sizeof(ns2__GetResponseType);
		((ns2__GetResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__GetResponseType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__GetResponseType);
		for (int i = 0; i < n; i++)
			((ns2__GetResponseType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__GetResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__GetResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__GetResponseType %p -> %p\n", q, p));
	*(ns2__GetResponseType*)p = *(ns2__GetResponseType*)q;
}

void ns2__GetType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__GetType::queryExpression);
	soap_default_xsd__nonNegativeInteger(soap, &this->ns2__GetType::maxResults);
	soap_default_xsd__nonNegativeInteger(soap, &this->ns2__GetType::startFrom);
	this->ns2__GetType::includeUserInfo = (bool)0;
	this->ns2__GetType::useNamesForCategories = (bool)0;
	this->ns2__GetType::useNamesForUnits = (bool)0;
	this->ns2__GetType::showContentReferencesOnly = (bool)0;
	this->ns2__GetType::showAssociationsToDeletedContent = (bool)0;
	/* transient soap skipped */
}

void ns2__GetType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__GetType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__GetType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__GetType(struct soap *soap, const char *tag, int id, const ns2__GetType *a, const char *type)
{
	if (!((ns2__GetType*)a)->queryExpression.empty())
		soap_set_attr(soap, "queryExpression", ((ns2__GetType*)a)->queryExpression.c_str(), 1);
	if (!((ns2__GetType*)a)->maxResults.empty())
		soap_set_attr(soap, "maxResults", ((ns2__GetType*)a)->maxResults.c_str(), 1);
	if (!((ns2__GetType*)a)->startFrom.empty())
		soap_set_attr(soap, "startFrom", ((ns2__GetType*)a)->startFrom.c_str(), 1);
	soap_set_attr(soap, "includeUserInfo", soap_bool2s(soap, ((ns2__GetType*)a)->includeUserInfo), 1);
	soap_set_attr(soap, "useNamesForCategories", soap_bool2s(soap, ((ns2__GetType*)a)->useNamesForCategories), 1);
	soap_set_attr(soap, "useNamesForUnits", soap_bool2s(soap, ((ns2__GetType*)a)->useNamesForUnits), 1);
	soap_set_attr(soap, "showContentReferencesOnly", soap_bool2s(soap, ((ns2__GetType*)a)->showContentReferencesOnly), 1);
	soap_set_attr(soap, "showAssociationsToDeletedContent", soap_bool2s(soap, ((ns2__GetType*)a)->showAssociationsToDeletedContent), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__GetType), "ns2:GetType"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__GetType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__GetType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__GetType * SOAP_FMAC4 soap_in_ns2__GetType(struct soap *soap, const char *tag, ns2__GetType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__GetType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__GetType, sizeof(ns2__GetType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__GetType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__GetType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "queryExpression", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__GetType*)a)->queryExpression.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "maxResults", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__GetType*)a)->maxResults.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "startFrom", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__GetType*)a)->startFrom.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "includeUserInfo", 0), &((ns2__GetType*)a)->includeUserInfo))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "useNamesForCategories", 0), &((ns2__GetType*)a)->useNamesForCategories))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "useNamesForUnits", 0), &((ns2__GetType*)a)->useNamesForUnits))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "showContentReferencesOnly", 0), &((ns2__GetType*)a)->showContentReferencesOnly))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "showAssociationsToDeletedContent", 0), &((ns2__GetType*)a)->showAssociationsToDeletedContent))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__GetType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__GetType, 0, sizeof(ns2__GetType), 0, soap_copy_ns2__GetType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__GetType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__GetType);
	if (this->soap_out(soap, tag?tag:"ns2:GetType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__GetType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__GetType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__GetType * SOAP_FMAC4 soap_get_ns2__GetType(struct soap *soap, ns2__GetType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__GetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__GetType * SOAP_FMAC2 soap_instantiate_ns2__GetType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__GetType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__GetType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__GetType);
		if (size)
			*size = sizeof(ns2__GetType);
		((ns2__GetType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__GetType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__GetType);
		for (int i = 0; i < n; i++)
			((ns2__GetType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__GetType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__GetType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__GetType %p -> %p\n", q, p));
	*(ns2__GetType*)p = *(ns2__GetType*)q;
}

void ns2__DeleteResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns2__DeleteResponseType_status(soap, &this->ns2__DeleteResponseType::status);
	/* transient soap skipped */
}

void ns2__DeleteResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__DeleteResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DeleteResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DeleteResponseType(struct soap *soap, const char *tag, int id, const ns2__DeleteResponseType *a, const char *type)
{
	soap_set_attr(soap, "status", soap__ns2__DeleteResponseType_status2s(soap, ((ns2__DeleteResponseType*)a)->status), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DeleteResponseType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DeleteResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DeleteResponseType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DeleteResponseType * SOAP_FMAC4 soap_in_ns2__DeleteResponseType(struct soap *soap, const char *tag, ns2__DeleteResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DeleteResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DeleteResponseType, sizeof(ns2__DeleteResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DeleteResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DeleteResponseType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2_ns2__DeleteResponseType_status(soap, soap_attr_value(soap, "status", 1), &((ns2__DeleteResponseType*)a)->status))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DeleteResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DeleteResponseType, 0, sizeof(ns2__DeleteResponseType), 0, soap_copy_ns2__DeleteResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__DeleteResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DeleteResponseType);
	if (this->soap_out(soap, tag?tag:"ns2:DeleteResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DeleteResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DeleteResponseType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DeleteResponseType * SOAP_FMAC4 soap_get_ns2__DeleteResponseType(struct soap *soap, ns2__DeleteResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DeleteResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DeleteResponseType * SOAP_FMAC2 soap_instantiate_ns2__DeleteResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DeleteResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DeleteResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DeleteResponseType);
		if (size)
			*size = sizeof(ns2__DeleteResponseType);
		((ns2__DeleteResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__DeleteResponseType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__DeleteResponseType);
		for (int i = 0; i < n; i++)
			((ns2__DeleteResponseType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__DeleteResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DeleteResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DeleteResponseType %p -> %p\n", q, p));
	*(ns2__DeleteResponseType*)p = *(ns2__DeleteResponseType*)q;
}

void ns2__DeleteType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__GuidType(soap, &this->ns2__DeleteType::cid);
	/* transient soap skipped */
}

void ns2__DeleteType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__DeleteType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DeleteType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DeleteType(struct soap *soap, const char *tag, int id, const ns2__DeleteType *a, const char *type)
{
	if (!((ns2__DeleteType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__DeleteType*)a)->cid.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DeleteType), "ns2:DeleteType"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DeleteType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DeleteType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DeleteType * SOAP_FMAC4 soap_in_ns2__DeleteType(struct soap *soap, const char *tag, ns2__DeleteType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DeleteType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DeleteType, sizeof(ns2__DeleteType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DeleteType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DeleteType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__DeleteType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DeleteType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DeleteType, 0, sizeof(ns2__DeleteType), 0, soap_copy_ns2__DeleteType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__DeleteType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DeleteType);
	if (this->soap_out(soap, tag?tag:"ns2:DeleteType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DeleteType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DeleteType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DeleteType * SOAP_FMAC4 soap_get_ns2__DeleteType(struct soap *soap, ns2__DeleteType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DeleteType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DeleteType * SOAP_FMAC2 soap_instantiate_ns2__DeleteType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DeleteType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DeleteType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DeleteType);
		if (size)
			*size = sizeof(ns2__DeleteType);
		((ns2__DeleteType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__DeleteType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__DeleteType);
		for (int i = 0; i < n; i++)
			((ns2__DeleteType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__DeleteType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DeleteType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DeleteType %p -> %p\n", q, p));
	*(ns2__DeleteType*)p = *(ns2__DeleteType*)q;
}

void ns2__UpdateResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__ns2__UpdateResponseType_status(soap, &this->ns2__UpdateResponseType::status);
	/* transient soap skipped */
}

void ns2__UpdateResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__UpdateResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__UpdateResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UpdateResponseType(struct soap *soap, const char *tag, int id, const ns2__UpdateResponseType *a, const char *type)
{
	soap_set_attr(soap, "status", soap__ns2__UpdateResponseType_status2s(soap, ((ns2__UpdateResponseType*)a)->status), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UpdateResponseType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__UpdateResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__UpdateResponseType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__UpdateResponseType * SOAP_FMAC4 soap_in_ns2__UpdateResponseType(struct soap *soap, const char *tag, ns2__UpdateResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__UpdateResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UpdateResponseType, sizeof(ns2__UpdateResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__UpdateResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__UpdateResponseType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2_ns2__UpdateResponseType_status(soap, soap_attr_value(soap, "status", 1), &((ns2__UpdateResponseType*)a)->status))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__UpdateResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UpdateResponseType, 0, sizeof(ns2__UpdateResponseType), 0, soap_copy_ns2__UpdateResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__UpdateResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__UpdateResponseType);
	if (this->soap_out(soap, tag?tag:"ns2:UpdateResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__UpdateResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__UpdateResponseType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__UpdateResponseType * SOAP_FMAC4 soap_get_ns2__UpdateResponseType(struct soap *soap, ns2__UpdateResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UpdateResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__UpdateResponseType * SOAP_FMAC2 soap_instantiate_ns2__UpdateResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__UpdateResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__UpdateResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__UpdateResponseType);
		if (size)
			*size = sizeof(ns2__UpdateResponseType);
		((ns2__UpdateResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__UpdateResponseType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__UpdateResponseType);
		for (int i = 0; i < n; i++)
			((ns2__UpdateResponseType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__UpdateResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__UpdateResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__UpdateResponseType %p -> %p\n", q, p));
	*(ns2__UpdateResponseType*)p = *(ns2__UpdateResponseType*)q;
}

void ns2__UpdateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__UpdateType::__unionAbstractContentUserProperties = 0;
	soap_default_ns3__GuidType(soap, &this->ns2__UpdateType::cid);
	/* transient soap skipped */
}

void ns2__UpdateType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_UpdateType(soap, this->ns2__UpdateType::__unionAbstractContentUserProperties, &this->ns2__UpdateType::__union_UpdateType);
	/* transient soap skipped */
}

int ns2__UpdateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__UpdateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UpdateType(struct soap *soap, const char *tag, int id, const ns2__UpdateType *a, const char *type)
{
	if (!((ns2__UpdateType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__UpdateType*)a)->cid.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UpdateType), "ns2:UpdateType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out__ns2__union_UpdateType(soap, a->ns2__UpdateType::__unionAbstractContentUserProperties, &a->ns2__UpdateType::__union_UpdateType))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__UpdateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__UpdateType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__UpdateType * SOAP_FMAC4 soap_in_ns2__UpdateType(struct soap *soap, const char *tag, ns2__UpdateType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__UpdateType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UpdateType, sizeof(ns2__UpdateType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__UpdateType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__UpdateType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__UpdateType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___union_UpdateType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___union_UpdateType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_UpdateType(soap, &a->ns2__UpdateType::__unionAbstractContentUserProperties, &a->ns2__UpdateType::__union_UpdateType))
				{	soap_flag___union_UpdateType1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__UpdateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UpdateType, 0, sizeof(ns2__UpdateType), 0, soap_copy_ns2__UpdateType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__UpdateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__UpdateType);
	if (this->soap_out(soap, tag?tag:"ns2:UpdateType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__UpdateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__UpdateType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__UpdateType * SOAP_FMAC4 soap_get_ns2__UpdateType(struct soap *soap, ns2__UpdateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UpdateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__UpdateType * SOAP_FMAC2 soap_instantiate_ns2__UpdateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__UpdateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__UpdateType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__UpdateType);
		if (size)
			*size = sizeof(ns2__UpdateType);
		((ns2__UpdateType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__UpdateType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__UpdateType);
		for (int i = 0; i < n; i++)
			((ns2__UpdateType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__UpdateType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__UpdateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__UpdateType %p -> %p\n", q, p));
	*(ns2__UpdateType*)p = *(ns2__UpdateType*)q;
}

void ns2__CreateResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns3__GuidType(soap, &this->ns2__CreateResponseType::cid);
	soap_default_xsd__QName(soap, &this->ns2__CreateResponseType::type);
	/* transient soap skipped */
}

void ns2__CreateResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__CreateResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CreateResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CreateResponseType(struct soap *soap, const char *tag, int id, const ns2__CreateResponseType *a, const char *type)
{
	if (!((ns2__CreateResponseType*)a)->cid.empty())
		soap_set_attr(soap, "cid", ((ns2__CreateResponseType*)a)->cid.c_str(), 1);
	if (!((ns2__CreateResponseType*)a)->type.empty())
		soap_set_attr(soap, "type", soap_QName2s(soap, ((ns2__CreateResponseType*)a)->type.c_str()), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CreateResponseType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CreateResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CreateResponseType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CreateResponseType * SOAP_FMAC4 soap_in_ns2__CreateResponseType(struct soap *soap, const char *tag, ns2__CreateResponseType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CreateResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CreateResponseType, sizeof(ns2__CreateResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CreateResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CreateResponseType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "cid", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((ns2__CreateResponseType*)a)->cid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "type", 1);
		if (t)
		{	char *s;
			if (soap_s2QName(soap, t, &s, -1, -1))
				return NULL;
			((ns2__CreateResponseType*)a)->type.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CreateResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CreateResponseType, 0, sizeof(ns2__CreateResponseType), 0, soap_copy_ns2__CreateResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__CreateResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CreateResponseType);
	if (this->soap_out(soap, tag?tag:"ns2:CreateResponseType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CreateResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CreateResponseType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CreateResponseType * SOAP_FMAC4 soap_get_ns2__CreateResponseType(struct soap *soap, ns2__CreateResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CreateResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CreateResponseType * SOAP_FMAC2 soap_instantiate_ns2__CreateResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CreateResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CreateResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CreateResponseType);
		if (size)
			*size = sizeof(ns2__CreateResponseType);
		((ns2__CreateResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CreateResponseType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CreateResponseType);
		for (int i = 0; i < n; i++)
			((ns2__CreateResponseType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CreateResponseType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CreateResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CreateResponseType %p -> %p\n", q, p));
	*(ns2__CreateResponseType*)p = *(ns2__CreateResponseType*)q;
}

void ns2__CreateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CreateType::__unionAbstractContentUserProperties = 0;
	/* transient soap skipped */
}

void ns2__CreateType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__ns2__union_CreateType(soap, this->ns2__CreateType::__unionAbstractContentUserProperties, &this->ns2__CreateType::__union_CreateType);
	/* transient soap skipped */
}

int ns2__CreateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CreateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CreateType(struct soap *soap, const char *tag, int id, const ns2__CreateType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CreateType), "ns2:CreateType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out__ns2__union_CreateType(soap, a->ns2__CreateType::__unionAbstractContentUserProperties, &a->ns2__CreateType::__union_CreateType))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CreateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CreateType(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CreateType * SOAP_FMAC4 soap_in_ns2__CreateType(struct soap *soap, const char *tag, ns2__CreateType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CreateType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CreateType, sizeof(ns2__CreateType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CreateType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CreateType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___union_CreateType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___union_CreateType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ns2__union_CreateType(soap, &a->ns2__CreateType::__unionAbstractContentUserProperties, &a->ns2__CreateType::__union_CreateType))
				{	soap_flag___union_CreateType1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CreateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CreateType, 0, sizeof(ns2__CreateType), 0, soap_copy_ns2__CreateType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__CreateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CreateType);
	if (this->soap_out(soap, tag?tag:"ns2:CreateType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CreateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CreateType(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CreateType * SOAP_FMAC4 soap_get_ns2__CreateType(struct soap *soap, ns2__CreateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CreateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CreateType * SOAP_FMAC2 soap_instantiate_ns2__CreateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CreateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CreateType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CreateType);
		if (size)
			*size = sizeof(ns2__CreateType);
		((ns2__CreateType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CreateType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CreateType);
		for (int i = 0; i < n; i++)
			((ns2__CreateType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CreateType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CreateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CreateType %p -> %p\n", q, p));
	*(ns2__CreateType*)p = *(ns2__CreateType*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__positiveInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__positiveInteger, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__positiveInteger, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__positiveInteger, 0, sizeof(std::string), 0, soap_copy_xsd__positiveInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger);
	if (soap_out_xsd__positiveInteger(soap, tag?tag:"xsd:positiveInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__nonNegativeInteger, 0, sizeof(std::string), 0, soap_copy_xsd__nonNegativeInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const xsd__QName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__QName), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 2, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__QName, 0, sizeof(std::string), 0, soap_copy_xsd__QName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const xsd__QName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (soap_out_xsd__QName(soap, tag?tag:"xsd:QName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__QName * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, xsd__QName *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__QName * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__QName);
		if (size)
			*size = sizeof(xsd__QName);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__QName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__QName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__QName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__QName %p -> %p\n", q, p));
	*(xsd__QName*)p = *(xsd__QName*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NMTOKEN(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NMTOKEN), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__NMTOKEN(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__NMTOKEN, 0, sizeof(std::string), 0, soap_copy_xsd__NMTOKEN);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NMTOKEN(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NMTOKEN);
	if (soap_out_xsd__NMTOKEN(soap, tag?tag:"xsd:NMTOKEN", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NMTOKEN(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NMTOKEN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetCapabilitiesOperation(struct soap *soap, struct __ns4__GetCapabilitiesOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetCapabilitiesOperation(struct soap *soap, const struct __ns4__GetCapabilitiesOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__GetCapabilitiesType(soap, &a->ns3__GetCapabilities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetCapabilitiesOperation(struct soap *soap, const char *tag, int id, const struct __ns4__GetCapabilitiesOperation *a, const char *type)
{
	if (soap_out_PointerTons3__GetCapabilitiesType(soap, "ns3:GetCapabilities", -1, &a->ns3__GetCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetCapabilitiesOperation * SOAP_FMAC4 soap_in___ns4__GetCapabilitiesOperation(struct soap *soap, const char *tag, struct __ns4__GetCapabilitiesOperation *a, const char *type)
{
	size_t soap_flag_ns3__GetCapabilities = 1;
	short soap_flag;
	a = (struct __ns4__GetCapabilitiesOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetCapabilitiesOperation, sizeof(struct __ns4__GetCapabilitiesOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetCapabilitiesOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__GetCapabilitiesType(soap, "ns3:GetCapabilities", &a->ns3__GetCapabilities, "ns3:GetCapabilitiesType"))
				{	soap_flag_ns3__GetCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetCapabilitiesOperation(struct soap *soap, const struct __ns4__GetCapabilitiesOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetCapabilitiesOperation(soap, tag?tag:"-ns4:GetCapabilitiesOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetCapabilitiesOperation * SOAP_FMAC4 soap_get___ns4__GetCapabilitiesOperation(struct soap *soap, struct __ns4__GetCapabilitiesOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetCapabilitiesOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetCapabilitiesOperation * SOAP_FMAC2 soap_instantiate___ns4__GetCapabilitiesOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetCapabilitiesOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetCapabilitiesOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetCapabilitiesOperation);
		if (size)
			*size = sizeof(struct __ns4__GetCapabilitiesOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetCapabilitiesOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetCapabilitiesOperation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetCapabilitiesOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetCapabilitiesOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetCapabilitiesOperation %p -> %p\n", q, p));
	*(struct __ns4__GetCapabilitiesOperation*)p = *(struct __ns4__GetCapabilitiesOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__UpdateOperation(struct soap *soap, struct __ns4__UpdateOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__Update = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__UpdateOperation(struct soap *soap, const struct __ns4__UpdateOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__UpdateType(soap, &a->ns2__Update);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__UpdateOperation(struct soap *soap, const char *tag, int id, const struct __ns4__UpdateOperation *a, const char *type)
{
	if (soap_out_PointerTons2__UpdateType(soap, "ns2:Update", -1, &a->ns2__Update, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__UpdateOperation * SOAP_FMAC4 soap_in___ns4__UpdateOperation(struct soap *soap, const char *tag, struct __ns4__UpdateOperation *a, const char *type)
{
	size_t soap_flag_ns2__Update = 1;
	short soap_flag;
	a = (struct __ns4__UpdateOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__UpdateOperation, sizeof(struct __ns4__UpdateOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__UpdateOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__Update && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UpdateType(soap, "ns2:Update", &a->ns2__Update, "ns2:UpdateType"))
				{	soap_flag_ns2__Update--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__UpdateOperation(struct soap *soap, const struct __ns4__UpdateOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__UpdateOperation(soap, tag?tag:"-ns4:UpdateOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__UpdateOperation * SOAP_FMAC4 soap_get___ns4__UpdateOperation(struct soap *soap, struct __ns4__UpdateOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__UpdateOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__UpdateOperation * SOAP_FMAC2 soap_instantiate___ns4__UpdateOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__UpdateOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__UpdateOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__UpdateOperation);
		if (size)
			*size = sizeof(struct __ns4__UpdateOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__UpdateOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__UpdateOperation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__UpdateOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__UpdateOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__UpdateOperation %p -> %p\n", q, p));
	*(struct __ns4__UpdateOperation*)p = *(struct __ns4__UpdateOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__UpdateOperationResponse(struct soap *soap, struct __ns4__UpdateOperationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__UpdateOperationResponse(struct soap *soap, const struct __ns4__UpdateOperationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__UpdateOperationResponse(struct soap *soap, const char *tag, int id, const struct __ns4__UpdateOperationResponse *a, const char *type)
{
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__UpdateOperationResponse * SOAP_FMAC4 soap_in___ns4__UpdateOperationResponse(struct soap *soap, const char *tag, struct __ns4__UpdateOperationResponse *a, const char *type)
{
	a = (struct __ns4__UpdateOperationResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__UpdateOperationResponse, sizeof(struct __ns4__UpdateOperationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__UpdateOperationResponse(soap, a);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__UpdateOperationResponse(struct soap *soap, const struct __ns4__UpdateOperationResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__UpdateOperationResponse(soap, tag?tag:"-ns4:UpdateOperationResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__UpdateOperationResponse * SOAP_FMAC4 soap_get___ns4__UpdateOperationResponse(struct soap *soap, struct __ns4__UpdateOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__UpdateOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__UpdateOperationResponse * SOAP_FMAC2 soap_instantiate___ns4__UpdateOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__UpdateOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__UpdateOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__UpdateOperationResponse);
		if (size)
			*size = sizeof(struct __ns4__UpdateOperationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__UpdateOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__UpdateOperationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__UpdateOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__UpdateOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__UpdateOperationResponse %p -> %p\n", q, p));
	*(struct __ns4__UpdateOperationResponse*)p = *(struct __ns4__UpdateOperationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__DeleteOperation(struct soap *soap, struct __ns4__DeleteOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__Delete = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__DeleteOperation(struct soap *soap, const struct __ns4__DeleteOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__DeleteType(soap, &a->ns2__Delete);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__DeleteOperation(struct soap *soap, const char *tag, int id, const struct __ns4__DeleteOperation *a, const char *type)
{
	if (soap_out_PointerTons2__DeleteType(soap, "ns2:Delete", -1, &a->ns2__Delete, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__DeleteOperation * SOAP_FMAC4 soap_in___ns4__DeleteOperation(struct soap *soap, const char *tag, struct __ns4__DeleteOperation *a, const char *type)
{
	size_t soap_flag_ns2__Delete = 1;
	short soap_flag;
	a = (struct __ns4__DeleteOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__DeleteOperation, sizeof(struct __ns4__DeleteOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__DeleteOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__Delete && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DeleteType(soap, "ns2:Delete", &a->ns2__Delete, "ns2:DeleteType"))
				{	soap_flag_ns2__Delete--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__DeleteOperation(struct soap *soap, const struct __ns4__DeleteOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__DeleteOperation(soap, tag?tag:"-ns4:DeleteOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__DeleteOperation * SOAP_FMAC4 soap_get___ns4__DeleteOperation(struct soap *soap, struct __ns4__DeleteOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__DeleteOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__DeleteOperation * SOAP_FMAC2 soap_instantiate___ns4__DeleteOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__DeleteOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__DeleteOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__DeleteOperation);
		if (size)
			*size = sizeof(struct __ns4__DeleteOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__DeleteOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__DeleteOperation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__DeleteOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__DeleteOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__DeleteOperation %p -> %p\n", q, p));
	*(struct __ns4__DeleteOperation*)p = *(struct __ns4__DeleteOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__DeleteOperationResponse(struct soap *soap, struct __ns4__DeleteOperationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__DeleteOperationResponse(struct soap *soap, const struct __ns4__DeleteOperationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__DeleteOperationResponse(struct soap *soap, const char *tag, int id, const struct __ns4__DeleteOperationResponse *a, const char *type)
{
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__DeleteOperationResponse * SOAP_FMAC4 soap_in___ns4__DeleteOperationResponse(struct soap *soap, const char *tag, struct __ns4__DeleteOperationResponse *a, const char *type)
{
	a = (struct __ns4__DeleteOperationResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__DeleteOperationResponse, sizeof(struct __ns4__DeleteOperationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__DeleteOperationResponse(soap, a);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__DeleteOperationResponse(struct soap *soap, const struct __ns4__DeleteOperationResponse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__DeleteOperationResponse(soap, tag?tag:"-ns4:DeleteOperationResponse", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__DeleteOperationResponse * SOAP_FMAC4 soap_get___ns4__DeleteOperationResponse(struct soap *soap, struct __ns4__DeleteOperationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__DeleteOperationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__DeleteOperationResponse * SOAP_FMAC2 soap_instantiate___ns4__DeleteOperationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__DeleteOperationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__DeleteOperationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__DeleteOperationResponse);
		if (size)
			*size = sizeof(struct __ns4__DeleteOperationResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__DeleteOperationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__DeleteOperationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__DeleteOperationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__DeleteOperationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__DeleteOperationResponse %p -> %p\n", q, p));
	*(struct __ns4__DeleteOperationResponse*)p = *(struct __ns4__DeleteOperationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__GetOperation(struct soap *soap, struct __ns4__GetOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__Get = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__GetOperation(struct soap *soap, const struct __ns4__GetOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__GetType(soap, &a->ns2__Get);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__GetOperation(struct soap *soap, const char *tag, int id, const struct __ns4__GetOperation *a, const char *type)
{
	if (soap_out_PointerTons2__GetType(soap, "ns2:Get", -1, &a->ns2__Get, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetOperation * SOAP_FMAC4 soap_in___ns4__GetOperation(struct soap *soap, const char *tag, struct __ns4__GetOperation *a, const char *type)
{
	size_t soap_flag_ns2__Get = 1;
	short soap_flag;
	a = (struct __ns4__GetOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__GetOperation, sizeof(struct __ns4__GetOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__GetOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__Get && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__GetType(soap, "ns2:Get", &a->ns2__Get, "ns2:GetType"))
				{	soap_flag_ns2__Get--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__GetOperation(struct soap *soap, const struct __ns4__GetOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__GetOperation(soap, tag?tag:"-ns4:GetOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__GetOperation * SOAP_FMAC4 soap_get___ns4__GetOperation(struct soap *soap, struct __ns4__GetOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__GetOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__GetOperation * SOAP_FMAC2 soap_instantiate___ns4__GetOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__GetOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__GetOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetOperation);
		if (size)
			*size = sizeof(struct __ns4__GetOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__GetOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__GetOperation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__GetOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__GetOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__GetOperation %p -> %p\n", q, p));
	*(struct __ns4__GetOperation*)p = *(struct __ns4__GetOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__CreateOperation(struct soap *soap, struct __ns4__CreateOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__Create = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__CreateOperation(struct soap *soap, const struct __ns4__CreateOperation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CreateType(soap, &a->ns2__Create);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__CreateOperation(struct soap *soap, const char *tag, int id, const struct __ns4__CreateOperation *a, const char *type)
{
	if (soap_out_PointerTons2__CreateType(soap, "ns2:Create", -1, &a->ns2__Create, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__CreateOperation * SOAP_FMAC4 soap_in___ns4__CreateOperation(struct soap *soap, const char *tag, struct __ns4__CreateOperation *a, const char *type)
{
	size_t soap_flag_ns2__Create = 1;
	short soap_flag;
	a = (struct __ns4__CreateOperation *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__CreateOperation, sizeof(struct __ns4__CreateOperation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__CreateOperation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__Create && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CreateType(soap, "ns2:Create", &a->ns2__Create, "ns2:CreateType"))
				{	soap_flag_ns2__Create--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__CreateOperation(struct soap *soap, const struct __ns4__CreateOperation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__CreateOperation(soap, tag?tag:"-ns4:CreateOperation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__CreateOperation * SOAP_FMAC4 soap_get___ns4__CreateOperation(struct soap *soap, struct __ns4__CreateOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__CreateOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__CreateOperation * SOAP_FMAC2 soap_instantiate___ns4__CreateOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__CreateOperation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__CreateOperation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__CreateOperation);
		if (size)
			*size = sizeof(struct __ns4__CreateOperation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__CreateOperation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__CreateOperation);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__CreateOperation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__CreateOperation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__CreateOperation %p -> %p\n", q, p));
	*(struct __ns4__CreateOperation*)p = *(struct __ns4__CreateOperation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Action);
	soap_serialize_string(soap, &a->SoapAction);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, &a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, &a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:Action", &a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:SoapAction", &a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, 0, sizeof(struct wsa5__ProblemActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ProblemActionType);
	if (soap_out_wsa5__ProblemActionType(soap, tag?tag:"wsa5:ProblemActionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ProblemActionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__ProblemActionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__ProblemActionType);
		if (size)
			*size = sizeof(struct wsa5__ProblemActionType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__ProblemActionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa5__ProblemActionType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa5__ProblemActionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__ProblemActionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__ProblemActionType %p -> %p\n", q, p));
	*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", a->RelationshipType, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelatesToType);
	if (soap_out_wsa5__RelatesToType(soap, tag?tag:"wsa5:RelatesToType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__RelatesToType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__RelatesToType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__RelatesToType);
		if (size)
			*size = sizeof(struct wsa5__RelatesToType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__RelatesToType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa5__RelatesToType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa5__RelatesToType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__RelatesToType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__RelatesToType %p -> %p\n", q, p));
	*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, 0, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__MetadataType);
	if (soap_out_wsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__MetadataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__MetadataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__MetadataType);
		if (size)
			*size = sizeof(struct wsa5__MetadataType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__MetadataType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa5__MetadataType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa5__MetadataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__MetadataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__MetadataType %p -> %p\n", q, p));
	*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, 0, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (soap_out_wsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ReferenceParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__ReferenceParametersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__ReferenceParametersType);
		if (size)
			*size = sizeof(struct wsa5__ReferenceParametersType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__ReferenceParametersType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa5__ReferenceParametersType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa5__ReferenceParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__ReferenceParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__ReferenceParametersType %p -> %p\n", q, p));
	*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Address", -1, &a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:Address", &a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, 0, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__EndpointReferenceType);
	if (soap_out_wsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__EndpointReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__EndpointReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__EndpointReferenceType);
		if (size)
			*size = sizeof(struct wsa5__EndpointReferenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__EndpointReferenceType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct wsa5__EndpointReferenceType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct wsa5__EndpointReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__EndpointReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__EndpointReferenceType %p -> %p\n", q, p));
	*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__Security = NULL;
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
	soap_serialize__wsa5__MessageID(soap, &a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, &a->wsa5__To);
	soap_serialize__wsa5__Action(soap, &a->wsa5__Action);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, &a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, &a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, &a->wsa5__Action, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsse__Security = 1;
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", &a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__To(soap, "wsa5:To", &a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__Action(soap, "wsa5:Action", &a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", a->SOAP_ENV__actor, 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", a->SOAP_ENV__role, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, 0, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Security);
	if (soap_out__wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Security(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Security, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Security);
		if (size)
			*size = sizeof(struct _wsse__Security);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Security[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__Security);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__Security*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Security(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Security %p -> %p\n", q, p));
	*(struct _wsse__Security*)p = *(struct _wsse__Security*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Modulus);
	soap_serialize_string(soap, &a->Exponent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:Modulus", -1, &a->Modulus, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Exponent", -1, &a->Exponent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Modulus", &a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Exponent", &a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, 0, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RSAKeyValueType);
	if (soap_out_ds__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RSAKeyValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__RSAKeyValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__RSAKeyValueType);
		if (size)
			*size = sizeof(struct ds__RSAKeyValueType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__RSAKeyValueType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__RSAKeyValueType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__RSAKeyValueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__RSAKeyValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__RSAKeyValueType %p -> %p\n", q, p));
	*(struct ds__RSAKeyValueType*)p = *(struct ds__RSAKeyValueType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->G);
	soap_serialize_string(soap, &a->Y);
	soap_serialize_string(soap, &a->J);
	soap_serialize_string(soap, &a->P);
	soap_serialize_string(soap, &a->Q);
	soap_serialize_string(soap, &a->Seed);
	soap_serialize_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, &a->G, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Y", -1, &a->Y, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, &a->J, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:P", -1, &a->P, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Q", -1, &a->Q, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Seed", -1, &a->Seed, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:PgenCounter", -1, &a->PgenCounter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:G", &a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Y", &a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:J", &a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:P", &a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Q", &a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Seed", &a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:PgenCounter", &a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, 0, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DSAKeyValueType);
	if (soap_out_ds__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DSAKeyValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__DSAKeyValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__DSAKeyValueType);
		if (size)
			*size = sizeof(struct ds__DSAKeyValueType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__DSAKeyValueType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__DSAKeyValueType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__DSAKeyValueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__DSAKeyValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__DSAKeyValueType %p -> %p\n", q, p));
	*(struct ds__DSAKeyValueType*)p = *(struct ds__DSAKeyValueType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_int(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->X509IssuerName);
	soap_embedded(soap, &a->X509SerialNumber, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:X509IssuerName", -1, &a->X509IssuerName, ""))
		return soap->error;
	if (soap_out_int(soap, "ds:X509SerialNumber", -1, &a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509IssuerName", &a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			if (soap_flag_X509SerialNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ds:X509SerialNumber", &a->X509SerialNumber, "xsd:int"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, 0, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509IssuerSerialType);
	if (soap_out_ds__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509IssuerSerialType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__X509IssuerSerialType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__X509IssuerSerialType);
		if (size)
			*size = sizeof(struct ds__X509IssuerSerialType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__X509IssuerSerialType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__X509IssuerSerialType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__X509IssuerSerialType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__X509IssuerSerialType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__X509IssuerSerialType %p -> %p\n", q, p));
	*(struct ds__X509IssuerSerialType*)p = *(struct ds__X509IssuerSerialType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, &a->X509SKI);
	soap_serialize_string(soap, &a->X509SubjectName);
	soap_serialize_string(soap, &a->X509Certificate);
	soap_serialize_string(soap, &a->X509CRL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SKI", -1, &a->X509SKI, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SubjectName", -1, &a->X509SubjectName, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509Certificate", -1, &a->X509Certificate, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509CRL", -1, &a->X509CRL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SKI", &a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SubjectName", &a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509Certificate", &a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509CRL", &a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, 0, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerSerial > 0 || soap_flag_X509SKI > 0 || soap_flag_X509SubjectName > 0 || soap_flag_X509Certificate > 0 || soap_flag_X509CRL > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509DataType);
	if (soap_out_ds__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509DataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__X509DataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__X509DataType);
		if (size)
			*size = sizeof(struct ds__X509DataType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__X509DataType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__X509DataType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__X509DataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__X509DataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__X509DataType %p -> %p\n", q, p));
	*(struct ds__X509DataType*)p = *(struct ds__X509DataType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, 0, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RetrievalMethodType);
	if (soap_out_ds__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RetrievalMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__RetrievalMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__RetrievalMethodType);
		if (size)
			*size = sizeof(struct ds__RetrievalMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__RetrievalMethodType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__RetrievalMethodType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__RetrievalMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__RetrievalMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__RetrievalMethodType %p -> %p\n", q, p));
	*(struct ds__RetrievalMethodType*)p = *(struct ds__RetrievalMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, 0, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DSAKeyValue > 0 || soap_flag_RSAKeyValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyValueType);
	if (soap_out_ds__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__KeyValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__KeyValueType);
		if (size)
			*size = sizeof(struct ds__KeyValueType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__KeyValueType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__KeyValueType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__KeyValueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__KeyValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__KeyValueType %p -> %p\n", q, p));
	*(struct ds__KeyValueType*)p = *(struct ds__KeyValueType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, 0, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DigestMethodType);
	if (soap_out_ds__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DigestMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__DigestMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__DigestMethodType);
		if (size)
			*size = sizeof(struct ds__DigestMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__DigestMethodType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__DigestMethodType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__DigestMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__DigestMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__DigestMethodType %p -> %p\n", q, p));
	*(struct ds__DigestMethodType*)p = *(struct ds__DigestMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, 0, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformType);
	if (soap_out_ds__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__TransformType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__TransformType);
		if (size)
			*size = sizeof(struct ds__TransformType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__TransformType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__TransformType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__TransformType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__TransformType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__TransformType %p -> %p\n", q, p));
	*(struct ds__TransformType*)p = *(struct ds__TransformType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", a->PrefixList, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, 0, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (soap_out__c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__c14n__InclusiveNamespaces(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__c14n__InclusiveNamespaces, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _c14n__InclusiveNamespaces);
		if (size)
			*size = sizeof(struct _c14n__InclusiveNamespaces);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _c14n__InclusiveNamespaces[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _c14n__InclusiveNamespaces);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _c14n__InclusiveNamespaces*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__c14n__InclusiveNamespaces(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _c14n__InclusiveNamespaces %p -> %p\n", q, p));
	*(struct _c14n__InclusiveNamespaces*)p = *(struct _c14n__InclusiveNamespaces*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_new_block(soap);
					a->Transform = (struct ds__TransformType *)soap_push_block(soap, soap_blist_Transform, sizeof(struct ds__TransformType));
					if (a->Transform == NULL)
						return NULL;
					soap_default_ds__TransformType(soap, a->Transform);
				}soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_pop_block(soap, soap_blist_Transform);
		if (a->__sizeTransform)
			a->Transform = (struct ds__TransformType *)soap_save_block(soap, soap_blist_Transform, NULL, 1);
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_end_block(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, 0, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformsType);
	if (soap_out_ds__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__TransformsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__TransformsType);
		if (size)
			*size = sizeof(struct ds__TransformsType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__TransformsType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__TransformsType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__TransformsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__TransformsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__TransformsType %p -> %p\n", q, p));
	*(struct ds__TransformsType*)p = *(struct ds__TransformsType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, &a->DigestValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:DigestValue", -1, &a->DigestValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:DigestValue", &a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, 0, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__ReferenceType);
	if (soap_out_ds__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__ReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__ReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__ReferenceType);
		if (size)
			*size = sizeof(struct ds__ReferenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__ReferenceType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__ReferenceType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__ReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__ReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__ReferenceType %p -> %p\n", q, p));
	*(struct ds__ReferenceType*)p = *(struct ds__ReferenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, 0, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureMethodType);
	if (soap_out_ds__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__SignatureMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignatureMethodType);
		if (size)
			*size = sizeof(struct ds__SignatureMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignatureMethodType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__SignatureMethodType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__SignatureMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__SignatureMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__SignatureMethodType %p -> %p\n", q, p));
	*(struct ds__SignatureMethodType*)p = *(struct ds__SignatureMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, 0, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (soap_out_ds__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__CanonicalizationMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__CanonicalizationMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__CanonicalizationMethodType);
		if (size)
			*size = sizeof(struct ds__CanonicalizationMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__CanonicalizationMethodType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__CanonicalizationMethodType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__CanonicalizationMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__CanonicalizationMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__CanonicalizationMethodType %p -> %p\n", q, p));
	*(struct ds__CanonicalizationMethodType*)p = *(struct ds__CanonicalizationMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, &a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:KeyName", &a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, 0, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyInfoType);
	if (soap_out_ds__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__KeyInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__KeyInfoType);
		if (size)
			*size = sizeof(struct ds__KeyInfoType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__KeyInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__KeyInfoType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__KeyInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__KeyInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__KeyInfoType %p -> %p\n", q, p));
	*(struct ds__KeyInfoType*)p = *(struct ds__KeyInfoType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
			{	if (a->Reference == NULL)
				{	if (soap_blist_Reference == NULL)
						soap_blist_Reference = soap_new_block(soap);
					a->Reference = (struct ds__ReferenceType **)soap_push_block(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
					if (a->Reference == NULL)
						return NULL;
					*a->Reference = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
				{	a->__sizeReference++;
					a->Reference = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
			a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		else
		{	a->Reference = NULL;
			if (soap_blist_Reference)
				soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, 0, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignedInfoType);
	if (soap_out_ds__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignedInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__SignedInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignedInfoType);
		if (size)
			*size = sizeof(struct ds__SignedInfoType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignedInfoType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__SignedInfoType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__SignedInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__SignedInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__SignedInfoType %p -> %p\n", q, p));
	*(struct ds__SignedInfoType*)p = *(struct ds__SignedInfoType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default_string(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize_string(soap, &a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:SignatureValue", -1, &a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:SignatureValue", &a->SignatureValue, "xsd:string"))
				{	soap_flag_SignatureValue--;
					continue;
				}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, 0, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureType);
	if (soap_out_ds__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__SignatureType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignatureType);
		if (size)
			*size = sizeof(struct ds__SignatureType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignatureType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ds__SignatureType);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ds__SignatureType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__SignatureType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__SignatureType %p -> %p\n", q, p));
	*(struct ds__SignatureType*)p = *(struct ds__SignatureType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->Usage)
		soap_set_attr(soap, "Usage", a->Usage, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, 0, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__SecurityTokenReference);
	if (soap_out__wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__SecurityTokenReference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__SecurityTokenReference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__SecurityTokenReference);
		if (size)
			*size = sizeof(struct _wsse__SecurityTokenReference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__SecurityTokenReference[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__SecurityTokenReference);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__SecurityTokenReference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__SecurityTokenReference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__SecurityTokenReference %p -> %p\n", q, p));
	*(struct _wsse__SecurityTokenReference*)p = *(struct _wsse__SecurityTokenReference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__KeyIdentifier);
	if (soap_out__wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__KeyIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__KeyIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__KeyIdentifier);
		if (size)
			*size = sizeof(struct _wsse__KeyIdentifier);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__KeyIdentifier[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__KeyIdentifier);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__KeyIdentifier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__KeyIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__KeyIdentifier %p -> %p\n", q, p));
	*(struct _wsse__KeyIdentifier*)p = *(struct _wsse__KeyIdentifier*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, 0, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Embedded);
	if (soap_out__wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Embedded(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Embedded, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Embedded);
		if (size)
			*size = sizeof(struct _wsse__Embedded);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Embedded[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__Embedded);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__Embedded*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Embedded(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Embedded %p -> %p\n", q, p));
	*(struct _wsse__Embedded*)p = *(struct _wsse__Embedded*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, 0, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Reference);
	if (soap_out__wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Reference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Reference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Reference);
		if (size)
			*size = sizeof(struct _wsse__Reference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Reference[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__Reference);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__Reference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Reference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Reference %p -> %p\n", q, p));
	*(struct _wsse__Reference*)p = *(struct _wsse__Reference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__BinarySecurityToken);
	if (soap_out__wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__BinarySecurityToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__BinarySecurityToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__BinarySecurityToken);
		if (size)
			*size = sizeof(struct _wsse__BinarySecurityToken);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__BinarySecurityToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__BinarySecurityToken);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__BinarySecurityToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__BinarySecurityToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__BinarySecurityToken %p -> %p\n", q, p));
	*(struct _wsse__BinarySecurityToken*)p = *(struct _wsse__BinarySecurityToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Password);
	if (soap_out__wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Password(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Password, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Password);
		if (size)
			*size = sizeof(struct _wsse__Password);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Password[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__Password);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__Password*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Password(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Password %p -> %p\n", q, p));
	*(struct _wsse__Password*)p = *(struct _wsse__Password*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_string(soap, &a->Nonce);
	soap_serialize_string(soap, &a->wsu__Created);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Nonce", &a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, 0, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__UsernameToken);
	if (soap_out__wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__UsernameToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__UsernameToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__UsernameToken);
		if (size)
			*size = sizeof(struct _wsse__UsernameToken);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__UsernameToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsse__UsernameToken);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsse__UsernameToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__UsernameToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__UsernameToken %p -> %p\n", q, p));
	*(struct _wsse__UsernameToken*)p = *(struct _wsse__UsernameToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Created);
	soap_serialize_string(soap, &a->Expires);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, &a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Expires", &a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, 0, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsu__Timestamp);
	if (soap_out__wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsu__Timestamp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsu__Timestamp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsu__Timestamp);
		if (size)
			*size = sizeof(struct _wsu__Timestamp);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct _wsu__Timestamp[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct _wsu__Timestamp);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct _wsu__Timestamp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsu__Timestamp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsu__Timestamp %p -> %p\n", q, p));
	*(struct _wsu__Timestamp*)p = *(struct _wsu__Timestamp*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_SpecialCollectionType(struct soap *soap, int choice, const union _ns2__union_SpecialCollectionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_SpecialCollectionType_Organization:
		soap_serialize_PointerTons2__OrganizationType(soap, &a->Organization);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_SpecialCollectionType(struct soap *soap, int choice, const union _ns2__union_SpecialCollectionType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_SpecialCollectionType_Organization:
		return soap_out_PointerTons2__OrganizationType(soap, "ns2:Organization", -1, &a->Organization, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_SpecialCollectionType * SOAP_FMAC4 soap_in__ns2__union_SpecialCollectionType(struct soap *soap, int *choice, union _ns2__union_SpecialCollectionType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Organization = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__OrganizationType(soap, "ns2:Organization", &a->Organization, "ns2:OrganizationType"))
	{	*choice = SOAP_UNION__ns2__union_SpecialCollectionType_Organization;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_SpecialCollectionUserPropertiesType(struct soap *soap, int choice, const union _ns2__union_SpecialCollectionUserPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_SpecialCollectionUserPropertiesType_Organization:
		soap_serialize_PointerTons2__OrganizationType(soap, &a->Organization);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_SpecialCollectionUserPropertiesType(struct soap *soap, int choice, const union _ns2__union_SpecialCollectionUserPropertiesType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_SpecialCollectionUserPropertiesType_Organization:
		return soap_out_PointerTons2__OrganizationType(soap, "ns2:Organization", -1, &a->Organization, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_SpecialCollectionUserPropertiesType * SOAP_FMAC4 soap_in__ns2__union_SpecialCollectionUserPropertiesType(struct soap *soap, int *choice, union _ns2__union_SpecialCollectionUserPropertiesType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Organization = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__OrganizationType(soap, "ns2:Organization", &a->Organization, "ns2:OrganizationType"))
	{	*choice = SOAP_UNION__ns2__union_SpecialCollectionUserPropertiesType_Organization;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_SpecialPlaceType(struct soap *soap, int choice, const union _ns2__union_SpecialPlaceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_SpecialPlaceType_DetailedPlaceInfo:
		soap_serialize_PointerTons2__DetailedPlaceInfoType(soap, &a->DetailedPlaceInfo);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_SpecialPlaceType(struct soap *soap, int choice, const union _ns2__union_SpecialPlaceType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_SpecialPlaceType_DetailedPlaceInfo:
		return soap_out_PointerTons2__DetailedPlaceInfoType(soap, "ns2:DetailedPlaceInfo", -1, &a->DetailedPlaceInfo, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_SpecialPlaceType * SOAP_FMAC4 soap_in__ns2__union_SpecialPlaceType(struct soap *soap, int *choice, union _ns2__union_SpecialPlaceType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->DetailedPlaceInfo = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__DetailedPlaceInfoType(soap, "ns2:DetailedPlaceInfo", &a->DetailedPlaceInfo, "ns2:DetailedPlaceInfoType"))
	{	*choice = SOAP_UNION__ns2__union_SpecialPlaceType_DetailedPlaceInfo;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_SpecialPlaceUserPropertiesType(struct soap *soap, int choice, const union _ns2__union_SpecialPlaceUserPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_SpecialPlaceUserPropertiesType_DetailedPlaceInfo:
		soap_serialize_PointerTons2__DetailedPlaceInfoType(soap, &a->DetailedPlaceInfo);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_SpecialPlaceUserPropertiesType(struct soap *soap, int choice, const union _ns2__union_SpecialPlaceUserPropertiesType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_SpecialPlaceUserPropertiesType_DetailedPlaceInfo:
		return soap_out_PointerTons2__DetailedPlaceInfoType(soap, "ns2:DetailedPlaceInfo", -1, &a->DetailedPlaceInfo, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_SpecialPlaceUserPropertiesType * SOAP_FMAC4 soap_in__ns2__union_SpecialPlaceUserPropertiesType(struct soap *soap, int *choice, union _ns2__union_SpecialPlaceUserPropertiesType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->DetailedPlaceInfo = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__DetailedPlaceInfoType(soap, "ns2:DetailedPlaceInfo", &a->DetailedPlaceInfo, "ns2:DetailedPlaceInfoType"))
	{	*choice = SOAP_UNION__ns2__union_SpecialPlaceUserPropertiesType_DetailedPlaceInfo;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_SpecialReportType(struct soap *soap, int choice, const union _ns2__union_SpecialReportType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_SpecialReportType_People:
		soap_serialize_PointerTons2__PeopleType(soap, &a->People);
		break;
	case SOAP_UNION__ns2__union_SpecialReportType_CIDNE_USCOREPerson:
		soap_serialize_PointerTons2__CIDNE_USCOREPersonType(soap, &a->CIDNE_USCOREPerson);
		break;
	case SOAP_UNION__ns2__union_SpecialReportType_HTSAreaAssessment:
		soap_serialize_PointerTons2__HTSAreaAssessmentType(soap, &a->HTSAreaAssessment);
		break;
	case SOAP_UNION__ns2__union_SpecialReportType_CIDNE_USCORECMODailyReport:
		soap_serialize_PointerTons2__CIDNE_USCORECMODailyReportType(soap, &a->CIDNE_USCORECMODailyReport);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_SpecialReportType(struct soap *soap, int choice, const union _ns2__union_SpecialReportType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_SpecialReportType_People:
		return soap_out_PointerTons2__PeopleType(soap, "ns2:People", -1, &a->People, "");
	case SOAP_UNION__ns2__union_SpecialReportType_CIDNE_USCOREPerson:
		return soap_out_PointerTons2__CIDNE_USCOREPersonType(soap, "ns2:CIDNE_Person", -1, &a->CIDNE_USCOREPerson, "");
	case SOAP_UNION__ns2__union_SpecialReportType_HTSAreaAssessment:
		return soap_out_PointerTons2__HTSAreaAssessmentType(soap, "ns2:HTSAreaAssessment", -1, &a->HTSAreaAssessment, "");
	case SOAP_UNION__ns2__union_SpecialReportType_CIDNE_USCORECMODailyReport:
		return soap_out_PointerTons2__CIDNE_USCORECMODailyReportType(soap, "ns2:CIDNE_CMODailyReport", -1, &a->CIDNE_USCORECMODailyReport, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_SpecialReportType * SOAP_FMAC4 soap_in__ns2__union_SpecialReportType(struct soap *soap, int *choice, union _ns2__union_SpecialReportType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->People = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__PeopleType(soap, "ns2:People", &a->People, "ns2:PeopleType"))
	{	*choice = SOAP_UNION__ns2__union_SpecialReportType_People;
		return a;
	}
	a->CIDNE_USCOREPerson = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CIDNE_USCOREPersonType(soap, "ns2:CIDNE_Person", &a->CIDNE_USCOREPerson, "ns2:CIDNE_PersonType"))
	{	*choice = SOAP_UNION__ns2__union_SpecialReportType_CIDNE_USCOREPerson;
		return a;
	}
	a->HTSAreaAssessment = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__HTSAreaAssessmentType(soap, "ns2:HTSAreaAssessment", &a->HTSAreaAssessment, "ns2:HTSAreaAssessmentType"))
	{	*choice = SOAP_UNION__ns2__union_SpecialReportType_HTSAreaAssessment;
		return a;
	}
	a->CIDNE_USCORECMODailyReport = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CIDNE_USCORECMODailyReportType(soap, "ns2:CIDNE_CMODailyReport", &a->CIDNE_USCORECMODailyReport, "ns2:CIDNE_CMODailyReportType"))
	{	*choice = SOAP_UNION__ns2__union_SpecialReportType_CIDNE_USCORECMODailyReport;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_SpecialReportUserPropertiesType(struct soap *soap, int choice, const union _ns2__union_SpecialReportUserPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_SpecialReportUserPropertiesType_People:
		soap_serialize_PointerTons2__PeopleType(soap, &a->People);
		break;
	case SOAP_UNION__ns2__union_SpecialReportUserPropertiesType_CIDNE_USCOREPerson:
		soap_serialize_PointerTons2__CIDNE_USCOREPersonType(soap, &a->CIDNE_USCOREPerson);
		break;
	case SOAP_UNION__ns2__union_SpecialReportUserPropertiesType_HTSAreaAssessment:
		soap_serialize_PointerTons2__HTSAreaAssessmentType(soap, &a->HTSAreaAssessment);
		break;
	case SOAP_UNION__ns2__union_SpecialReportUserPropertiesType_CIDNE_USCORECMODailyReport:
		soap_serialize_PointerTons2__CIDNE_USCORECMODailyReportType(soap, &a->CIDNE_USCORECMODailyReport);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_SpecialReportUserPropertiesType(struct soap *soap, int choice, const union _ns2__union_SpecialReportUserPropertiesType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_SpecialReportUserPropertiesType_People:
		return soap_out_PointerTons2__PeopleType(soap, "ns2:People", -1, &a->People, "");
	case SOAP_UNION__ns2__union_SpecialReportUserPropertiesType_CIDNE_USCOREPerson:
		return soap_out_PointerTons2__CIDNE_USCOREPersonType(soap, "ns2:CIDNE_Person", -1, &a->CIDNE_USCOREPerson, "");
	case SOAP_UNION__ns2__union_SpecialReportUserPropertiesType_HTSAreaAssessment:
		return soap_out_PointerTons2__HTSAreaAssessmentType(soap, "ns2:HTSAreaAssessment", -1, &a->HTSAreaAssessment, "");
	case SOAP_UNION__ns2__union_SpecialReportUserPropertiesType_CIDNE_USCORECMODailyReport:
		return soap_out_PointerTons2__CIDNE_USCORECMODailyReportType(soap, "ns2:CIDNE_CMODailyReport", -1, &a->CIDNE_USCORECMODailyReport, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_SpecialReportUserPropertiesType * SOAP_FMAC4 soap_in__ns2__union_SpecialReportUserPropertiesType(struct soap *soap, int *choice, union _ns2__union_SpecialReportUserPropertiesType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->People = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__PeopleType(soap, "ns2:People", &a->People, "ns2:PeopleType"))
	{	*choice = SOAP_UNION__ns2__union_SpecialReportUserPropertiesType_People;
		return a;
	}
	a->CIDNE_USCOREPerson = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CIDNE_USCOREPersonType(soap, "ns2:CIDNE_Person", &a->CIDNE_USCOREPerson, "ns2:CIDNE_PersonType"))
	{	*choice = SOAP_UNION__ns2__union_SpecialReportUserPropertiesType_CIDNE_USCOREPerson;
		return a;
	}
	a->HTSAreaAssessment = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__HTSAreaAssessmentType(soap, "ns2:HTSAreaAssessment", &a->HTSAreaAssessment, "ns2:HTSAreaAssessmentType"))
	{	*choice = SOAP_UNION__ns2__union_SpecialReportUserPropertiesType_HTSAreaAssessment;
		return a;
	}
	a->CIDNE_USCORECMODailyReport = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CIDNE_USCORECMODailyReportType(soap, "ns2:CIDNE_CMODailyReport", &a->CIDNE_USCORECMODailyReport, "ns2:CIDNE_CMODailyReportType"))
	{	*choice = SOAP_UNION__ns2__union_SpecialReportUserPropertiesType_CIDNE_USCORECMODailyReport;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_UpdateType(struct soap *soap, int choice, const union _ns2__union_UpdateType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_UpdateType_AnnotationUserProperties:
		soap_serialize_PointerTons2__AnnotationUserPropertiesType(soap, &a->AnnotationUserProperties);
		break;
	case SOAP_UNION__ns2__union_UpdateType_MediaUserProperties:
		soap_serialize_PointerTons2__MediaUserPropertiesType(soap, &a->MediaUserProperties);
		break;
	case SOAP_UNION__ns2__union_UpdateType_ImageUserProperties:
		soap_serialize_PointerTons2__ImageUserPropertiesType(soap, &a->ImageUserProperties);
		break;
	case SOAP_UNION__ns2__union_UpdateType_EventUserProperties:
		soap_serialize_PointerTons2__EventUserPropertiesType(soap, &a->EventUserProperties);
		break;
	case SOAP_UNION__ns2__union_UpdateType_PlaceUserProperties:
		soap_serialize_PointerTons2__PlaceUserPropertiesType(soap, &a->PlaceUserProperties);
		break;
	case SOAP_UNION__ns2__union_UpdateType_ReportUserProperties:
		soap_serialize_PointerTons2__ReportUserPropertiesType(soap, &a->ReportUserProperties);
		break;
	case SOAP_UNION__ns2__union_UpdateType_CollectionUserProperties:
		soap_serialize_PointerTons2__CollectionUserPropertiesType(soap, &a->CollectionUserProperties);
		break;
	case SOAP_UNION__ns2__union_UpdateType_ForumTopicUserProperties:
		soap_serialize_PointerTons2__ForumTopicUserPropertiesType(soap, &a->ForumTopicUserProperties);
		break;
	case SOAP_UNION__ns2__union_UpdateType_ForumPostUserProperties:
		soap_serialize_PointerTons2__ForumPostUserPropertiesType(soap, &a->ForumPostUserProperties);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_UpdateType(struct soap *soap, int choice, const union _ns2__union_UpdateType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_UpdateType_AnnotationUserProperties:
		return soap_out_PointerTons2__AnnotationUserPropertiesType(soap, "ns2:AnnotationUserProperties", -1, &a->AnnotationUserProperties, "");
	case SOAP_UNION__ns2__union_UpdateType_MediaUserProperties:
		return soap_out_PointerTons2__MediaUserPropertiesType(soap, "ns2:MediaUserProperties", -1, &a->MediaUserProperties, "");
	case SOAP_UNION__ns2__union_UpdateType_ImageUserProperties:
		return soap_out_PointerTons2__ImageUserPropertiesType(soap, "ns2:ImageUserProperties", -1, &a->ImageUserProperties, "");
	case SOAP_UNION__ns2__union_UpdateType_EventUserProperties:
		return soap_out_PointerTons2__EventUserPropertiesType(soap, "ns2:EventUserProperties", -1, &a->EventUserProperties, "");
	case SOAP_UNION__ns2__union_UpdateType_PlaceUserProperties:
		return soap_out_PointerTons2__PlaceUserPropertiesType(soap, "ns2:PlaceUserProperties", -1, &a->PlaceUserProperties, "");
	case SOAP_UNION__ns2__union_UpdateType_ReportUserProperties:
		return soap_out_PointerTons2__ReportUserPropertiesType(soap, "ns2:ReportUserProperties", -1, &a->ReportUserProperties, "");
	case SOAP_UNION__ns2__union_UpdateType_CollectionUserProperties:
		return soap_out_PointerTons2__CollectionUserPropertiesType(soap, "ns2:CollectionUserProperties", -1, &a->CollectionUserProperties, "");
	case SOAP_UNION__ns2__union_UpdateType_ForumTopicUserProperties:
		return soap_out_PointerTons2__ForumTopicUserPropertiesType(soap, "ns2:ForumTopicUserProperties", -1, &a->ForumTopicUserProperties, "");
	case SOAP_UNION__ns2__union_UpdateType_ForumPostUserProperties:
		return soap_out_PointerTons2__ForumPostUserPropertiesType(soap, "ns2:ForumPostUserProperties", -1, &a->ForumPostUserProperties, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_UpdateType * SOAP_FMAC4 soap_in__ns2__union_UpdateType(struct soap *soap, int *choice, union _ns2__union_UpdateType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->AnnotationUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__AnnotationUserPropertiesType(soap, "ns2:AnnotationUserProperties", &a->AnnotationUserProperties, "ns2:AnnotationUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_UpdateType_AnnotationUserProperties;
		return a;
	}
	a->MediaUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__MediaUserPropertiesType(soap, "ns2:MediaUserProperties", &a->MediaUserProperties, "ns2:MediaUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_UpdateType_MediaUserProperties;
		return a;
	}
	a->ImageUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ImageUserPropertiesType(soap, "ns2:ImageUserProperties", &a->ImageUserProperties, "ns2:ImageUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_UpdateType_ImageUserProperties;
		return a;
	}
	a->EventUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__EventUserPropertiesType(soap, "ns2:EventUserProperties", &a->EventUserProperties, "ns2:EventUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_UpdateType_EventUserProperties;
		return a;
	}
	a->PlaceUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__PlaceUserPropertiesType(soap, "ns2:PlaceUserProperties", &a->PlaceUserProperties, "ns2:PlaceUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_UpdateType_PlaceUserProperties;
		return a;
	}
	a->ReportUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ReportUserPropertiesType(soap, "ns2:ReportUserProperties", &a->ReportUserProperties, "ns2:ReportUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_UpdateType_ReportUserProperties;
		return a;
	}
	a->CollectionUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CollectionUserPropertiesType(soap, "ns2:CollectionUserProperties", &a->CollectionUserProperties, "ns2:CollectionUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_UpdateType_CollectionUserProperties;
		return a;
	}
	a->ForumTopicUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ForumTopicUserPropertiesType(soap, "ns2:ForumTopicUserProperties", &a->ForumTopicUserProperties, "ns2:ForumTopicUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_UpdateType_ForumTopicUserProperties;
		return a;
	}
	a->ForumPostUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ForumPostUserPropertiesType(soap, "ns2:ForumPostUserProperties", &a->ForumPostUserProperties, "ns2:ForumPostUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_UpdateType_ForumPostUserProperties;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_CreateType(struct soap *soap, int choice, const union _ns2__union_CreateType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_CreateType_AnnotationUserProperties:
		soap_serialize_PointerTons2__AnnotationUserPropertiesType(soap, &a->AnnotationUserProperties);
		break;
	case SOAP_UNION__ns2__union_CreateType_MediaUserProperties:
		soap_serialize_PointerTons2__MediaUserPropertiesType(soap, &a->MediaUserProperties);
		break;
	case SOAP_UNION__ns2__union_CreateType_ImageUserProperties:
		soap_serialize_PointerTons2__ImageUserPropertiesType(soap, &a->ImageUserProperties);
		break;
	case SOAP_UNION__ns2__union_CreateType_EventUserProperties:
		soap_serialize_PointerTons2__EventUserPropertiesType(soap, &a->EventUserProperties);
		break;
	case SOAP_UNION__ns2__union_CreateType_PlaceUserProperties:
		soap_serialize_PointerTons2__PlaceUserPropertiesType(soap, &a->PlaceUserProperties);
		break;
	case SOAP_UNION__ns2__union_CreateType_ReportUserProperties:
		soap_serialize_PointerTons2__ReportUserPropertiesType(soap, &a->ReportUserProperties);
		break;
	case SOAP_UNION__ns2__union_CreateType_CollectionUserProperties:
		soap_serialize_PointerTons2__CollectionUserPropertiesType(soap, &a->CollectionUserProperties);
		break;
	case SOAP_UNION__ns2__union_CreateType_ForumTopicUserProperties:
		soap_serialize_PointerTons2__ForumTopicUserPropertiesType(soap, &a->ForumTopicUserProperties);
		break;
	case SOAP_UNION__ns2__union_CreateType_ForumPostUserProperties:
		soap_serialize_PointerTons2__ForumPostUserPropertiesType(soap, &a->ForumPostUserProperties);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_CreateType(struct soap *soap, int choice, const union _ns2__union_CreateType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_CreateType_AnnotationUserProperties:
		return soap_out_PointerTons2__AnnotationUserPropertiesType(soap, "ns2:AnnotationUserProperties", -1, &a->AnnotationUserProperties, "");
	case SOAP_UNION__ns2__union_CreateType_MediaUserProperties:
		return soap_out_PointerTons2__MediaUserPropertiesType(soap, "ns2:MediaUserProperties", -1, &a->MediaUserProperties, "");
	case SOAP_UNION__ns2__union_CreateType_ImageUserProperties:
		return soap_out_PointerTons2__ImageUserPropertiesType(soap, "ns2:ImageUserProperties", -1, &a->ImageUserProperties, "");
	case SOAP_UNION__ns2__union_CreateType_EventUserProperties:
		return soap_out_PointerTons2__EventUserPropertiesType(soap, "ns2:EventUserProperties", -1, &a->EventUserProperties, "");
	case SOAP_UNION__ns2__union_CreateType_PlaceUserProperties:
		return soap_out_PointerTons2__PlaceUserPropertiesType(soap, "ns2:PlaceUserProperties", -1, &a->PlaceUserProperties, "");
	case SOAP_UNION__ns2__union_CreateType_ReportUserProperties:
		return soap_out_PointerTons2__ReportUserPropertiesType(soap, "ns2:ReportUserProperties", -1, &a->ReportUserProperties, "");
	case SOAP_UNION__ns2__union_CreateType_CollectionUserProperties:
		return soap_out_PointerTons2__CollectionUserPropertiesType(soap, "ns2:CollectionUserProperties", -1, &a->CollectionUserProperties, "");
	case SOAP_UNION__ns2__union_CreateType_ForumTopicUserProperties:
		return soap_out_PointerTons2__ForumTopicUserPropertiesType(soap, "ns2:ForumTopicUserProperties", -1, &a->ForumTopicUserProperties, "");
	case SOAP_UNION__ns2__union_CreateType_ForumPostUserProperties:
		return soap_out_PointerTons2__ForumPostUserPropertiesType(soap, "ns2:ForumPostUserProperties", -1, &a->ForumPostUserProperties, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_CreateType * SOAP_FMAC4 soap_in__ns2__union_CreateType(struct soap *soap, int *choice, union _ns2__union_CreateType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->AnnotationUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__AnnotationUserPropertiesType(soap, "ns2:AnnotationUserProperties", &a->AnnotationUserProperties, "ns2:AnnotationUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_CreateType_AnnotationUserProperties;
		return a;
	}
	a->MediaUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__MediaUserPropertiesType(soap, "ns2:MediaUserProperties", &a->MediaUserProperties, "ns2:MediaUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_CreateType_MediaUserProperties;
		return a;
	}
	a->ImageUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ImageUserPropertiesType(soap, "ns2:ImageUserProperties", &a->ImageUserProperties, "ns2:ImageUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_CreateType_ImageUserProperties;
		return a;
	}
	a->EventUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__EventUserPropertiesType(soap, "ns2:EventUserProperties", &a->EventUserProperties, "ns2:EventUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_CreateType_EventUserProperties;
		return a;
	}
	a->PlaceUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__PlaceUserPropertiesType(soap, "ns2:PlaceUserProperties", &a->PlaceUserProperties, "ns2:PlaceUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_CreateType_PlaceUserProperties;
		return a;
	}
	a->ReportUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ReportUserPropertiesType(soap, "ns2:ReportUserProperties", &a->ReportUserProperties, "ns2:ReportUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_CreateType_ReportUserProperties;
		return a;
	}
	a->CollectionUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CollectionUserPropertiesType(soap, "ns2:CollectionUserProperties", &a->CollectionUserProperties, "ns2:CollectionUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_CreateType_CollectionUserProperties;
		return a;
	}
	a->ForumTopicUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ForumTopicUserPropertiesType(soap, "ns2:ForumTopicUserProperties", &a->ForumTopicUserProperties, "ns2:ForumTopicUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_CreateType_ForumTopicUserProperties;
		return a;
	}
	a->ForumPostUserProperties = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ForumPostUserPropertiesType(soap, "ns2:ForumPostUserProperties", &a->ForumPostUserProperties, "ns2:ForumPostUserPropertiesType"))
	{	*choice = SOAP_UNION__ns2__union_CreateType_ForumPostUserProperties;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_LocationListType(struct soap *soap, int choice, const union _ns2__union_LocationListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_LocationListType_ns3__Point:
		soap_serialize_PointerTons3__PointType(soap, &a->ns3__Point);
		break;
	case SOAP_UNION__ns2__union_LocationListType_ns3__LineString:
		soap_serialize_PointerTons3__LineStringType(soap, &a->ns3__LineString);
		break;
	case SOAP_UNION__ns2__union_LocationListType_ns3__LinearRing:
		soap_serialize_PointerTons3__LinearRingType(soap, &a->ns3__LinearRing);
		break;
	case SOAP_UNION__ns2__union_LocationListType_ns3__Polygon:
		soap_serialize_PointerTons3__PolygonType(soap, &a->ns3__Polygon);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_LocationListType(struct soap *soap, int choice, const union _ns2__union_LocationListType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_LocationListType_ns3__Point:
		return soap_out_PointerTons3__PointType(soap, "ns3:Point", -1, &a->ns3__Point, "");
	case SOAP_UNION__ns2__union_LocationListType_ns3__LineString:
		return soap_out_PointerTons3__LineStringType(soap, "ns3:LineString", -1, &a->ns3__LineString, "");
	case SOAP_UNION__ns2__union_LocationListType_ns3__LinearRing:
		return soap_out_PointerTons3__LinearRingType(soap, "ns3:LinearRing", -1, &a->ns3__LinearRing, "");
	case SOAP_UNION__ns2__union_LocationListType_ns3__Polygon:
		return soap_out_PointerTons3__PolygonType(soap, "ns3:Polygon", -1, &a->ns3__Polygon, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_LocationListType * SOAP_FMAC4 soap_in__ns2__union_LocationListType(struct soap *soap, int *choice, union _ns2__union_LocationListType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->ns3__Point = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons3__PointType(soap, "ns3:Point", &a->ns3__Point, "ns3:PointType"))
	{	*choice = SOAP_UNION__ns2__union_LocationListType_ns3__Point;
		return a;
	}
	a->ns3__LineString = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons3__LineStringType(soap, "ns3:LineString", &a->ns3__LineString, "ns3:LineStringType"))
	{	*choice = SOAP_UNION__ns2__union_LocationListType_ns3__LineString;
		return a;
	}
	a->ns3__LinearRing = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons3__LinearRingType(soap, "ns3:LinearRing", &a->ns3__LinearRing, "ns3:LinearRingType"))
	{	*choice = SOAP_UNION__ns2__union_LocationListType_ns3__LinearRing;
		return a;
	}
	a->ns3__Polygon = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons3__PolygonType(soap, "ns3:Polygon", &a->ns3__Polygon, "ns3:PolygonType"))
	{	*choice = SOAP_UNION__ns2__union_LocationListType_ns3__Polygon;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_AbstractContentReferenceHolderType(struct soap *soap, int choice, const union _ns2__union_AbstractContentReferenceHolderType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_AbstractContentReferenceHolderType_ContentIdentifierReference:
		soap_serialize_PointerTons2__ContentIdentifierReferenceType(soap, &a->ContentIdentifierReference);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_AbstractContentReferenceHolderType(struct soap *soap, int choice, const union _ns2__union_AbstractContentReferenceHolderType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_AbstractContentReferenceHolderType_ContentIdentifierReference:
		return soap_out_PointerTons2__ContentIdentifierReferenceType(soap, "ns2:ContentIdentifierReference", -1, &a->ContentIdentifierReference, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_AbstractContentReferenceHolderType * SOAP_FMAC4 soap_in__ns2__union_AbstractContentReferenceHolderType(struct soap *soap, int *choice, union _ns2__union_AbstractContentReferenceHolderType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->ContentIdentifierReference = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ContentIdentifierReferenceType(soap, "ns2:ContentIdentifierReference", &a->ContentIdentifierReference, "ns2:ContentIdentifierReferenceType"))
	{	*choice = SOAP_UNION__ns2__union_AbstractContentReferenceHolderType_ContentIdentifierReference;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_AbstractContentReferenceListType(struct soap *soap, int choice, const union _ns2__union_AbstractContentReferenceListType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_AbstractContentReferenceListType_ContentIdentifierReference:
		soap_serialize_PointerTons2__ContentIdentifierReferenceType(soap, &a->ContentIdentifierReference);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_AbstractContentReferenceListType(struct soap *soap, int choice, const union _ns2__union_AbstractContentReferenceListType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_AbstractContentReferenceListType_ContentIdentifierReference:
		return soap_out_PointerTons2__ContentIdentifierReferenceType(soap, "ns2:ContentIdentifierReference", -1, &a->ContentIdentifierReference, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_AbstractContentReferenceListType * SOAP_FMAC4 soap_in__ns2__union_AbstractContentReferenceListType(struct soap *soap, int *choice, union _ns2__union_AbstractContentReferenceListType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->ContentIdentifierReference = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ContentIdentifierReferenceType(soap, "ns2:ContentIdentifierReference", &a->ContentIdentifierReference, "ns2:ContentIdentifierReferenceType"))
	{	*choice = SOAP_UNION__ns2__union_AbstractContentReferenceListType_ContentIdentifierReference;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__union_GetResponseType(struct soap *soap, int choice, const union _ns2__union_GetResponseType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns2__union_GetResponseType_Annotation:
		soap_serialize_PointerTons2__AnnotationType(soap, &a->Annotation);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_Media:
		soap_serialize_PointerTons2__MediaType(soap, &a->Media);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_Image:
		soap_serialize_PointerTons2__ImageType(soap, &a->Image);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_Event:
		soap_serialize_PointerTons2__EventType(soap, &a->Event);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_Place:
		soap_serialize_PointerTons2__PlaceType(soap, &a->Place);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_SpecialPlace:
		soap_serialize_PointerTons2__SpecialPlaceType(soap, &a->SpecialPlace);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_Report:
		soap_serialize_PointerTons2__ReportType(soap, &a->Report);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_SpecialReport:
		soap_serialize_PointerTons2__SpecialReportType(soap, &a->SpecialReport);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_Collection:
		soap_serialize_PointerTons2__CollectionType(soap, &a->Collection);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_SpecialCollection:
		soap_serialize_PointerTons2__SpecialCollectionType(soap, &a->SpecialCollection);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_ForumTopic:
		soap_serialize_PointerTons2__ForumTopicType(soap, &a->ForumTopic);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_ForumPost:
		soap_serialize_PointerTons2__ForumPostType(soap, &a->ForumPost);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_Deleted:
		soap_serialize_PointerTons2__DeletedType(soap, &a->Deleted);
		break;
	case SOAP_UNION__ns2__union_GetResponseType_ContentIdentifierReference:
		soap_serialize_PointerTons2__ContentIdentifierReferenceType(soap, &a->ContentIdentifierReference);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__union_GetResponseType(struct soap *soap, int choice, const union _ns2__union_GetResponseType *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns2__union_GetResponseType_Annotation:
		return soap_out_PointerTons2__AnnotationType(soap, "ns2:Annotation", -1, &a->Annotation, "");
	case SOAP_UNION__ns2__union_GetResponseType_Media:
		return soap_out_PointerTons2__MediaType(soap, "ns2:Media", -1, &a->Media, "");
	case SOAP_UNION__ns2__union_GetResponseType_Image:
		return soap_out_PointerTons2__ImageType(soap, "ns2:Image", -1, &a->Image, "");
	case SOAP_UNION__ns2__union_GetResponseType_Event:
		return soap_out_PointerTons2__EventType(soap, "ns2:Event", -1, &a->Event, "");
	case SOAP_UNION__ns2__union_GetResponseType_Place:
		return soap_out_PointerTons2__PlaceType(soap, "ns2:Place", -1, &a->Place, "");
	case SOAP_UNION__ns2__union_GetResponseType_SpecialPlace:
		return soap_out_PointerTons2__SpecialPlaceType(soap, "ns2:SpecialPlace", -1, &a->SpecialPlace, "");
	case SOAP_UNION__ns2__union_GetResponseType_Report:
		return soap_out_PointerTons2__ReportType(soap, "ns2:Report", -1, &a->Report, "");
	case SOAP_UNION__ns2__union_GetResponseType_SpecialReport:
		return soap_out_PointerTons2__SpecialReportType(soap, "ns2:SpecialReport", -1, &a->SpecialReport, "");
	case SOAP_UNION__ns2__union_GetResponseType_Collection:
		return soap_out_PointerTons2__CollectionType(soap, "ns2:Collection", -1, &a->Collection, "");
	case SOAP_UNION__ns2__union_GetResponseType_SpecialCollection:
		return soap_out_PointerTons2__SpecialCollectionType(soap, "ns2:SpecialCollection", -1, &a->SpecialCollection, "");
	case SOAP_UNION__ns2__union_GetResponseType_ForumTopic:
		return soap_out_PointerTons2__ForumTopicType(soap, "ns2:ForumTopic", -1, &a->ForumTopic, "");
	case SOAP_UNION__ns2__union_GetResponseType_ForumPost:
		return soap_out_PointerTons2__ForumPostType(soap, "ns2:ForumPost", -1, &a->ForumPost, "");
	case SOAP_UNION__ns2__union_GetResponseType_Deleted:
		return soap_out_PointerTons2__DeletedType(soap, "ns2:Deleted", -1, &a->Deleted, "");
	case SOAP_UNION__ns2__union_GetResponseType_ContentIdentifierReference:
		return soap_out_PointerTons2__ContentIdentifierReferenceType(soap, "ns2:ContentIdentifierReference", -1, &a->ContentIdentifierReference, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns2__union_GetResponseType * SOAP_FMAC4 soap_in__ns2__union_GetResponseType(struct soap *soap, int *choice, union _ns2__union_GetResponseType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Annotation = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__AnnotationType(soap, "ns2:Annotation", &a->Annotation, "ns2:AnnotationType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_Annotation;
		return a;
	}
	a->Media = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__MediaType(soap, "ns2:Media", &a->Media, "ns2:MediaType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_Media;
		return a;
	}
	a->Image = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ImageType(soap, "ns2:Image", &a->Image, "ns2:ImageType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_Image;
		return a;
	}
	a->Event = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__EventType(soap, "ns2:Event", &a->Event, "ns2:EventType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_Event;
		return a;
	}
	a->Place = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__PlaceType(soap, "ns2:Place", &a->Place, "ns2:PlaceType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_Place;
		return a;
	}
	a->SpecialPlace = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__SpecialPlaceType(soap, "ns2:SpecialPlace", &a->SpecialPlace, "ns2:SpecialPlaceType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_SpecialPlace;
		return a;
	}
	a->Report = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ReportType(soap, "ns2:Report", &a->Report, "ns2:ReportType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_Report;
		return a;
	}
	a->SpecialReport = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__SpecialReportType(soap, "ns2:SpecialReport", &a->SpecialReport, "ns2:SpecialReportType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_SpecialReport;
		return a;
	}
	a->Collection = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__CollectionType(soap, "ns2:Collection", &a->Collection, "ns2:CollectionType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_Collection;
		return a;
	}
	a->SpecialCollection = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__SpecialCollectionType(soap, "ns2:SpecialCollection", &a->SpecialCollection, "ns2:SpecialCollectionType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_SpecialCollection;
		return a;
	}
	a->ForumTopic = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ForumTopicType(soap, "ns2:ForumTopic", &a->ForumTopic, "ns2:ForumTopicType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_ForumTopic;
		return a;
	}
	a->ForumPost = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ForumPostType(soap, "ns2:ForumPost", &a->ForumPost, "ns2:ForumPostType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_ForumPost;
		return a;
	}
	a->Deleted = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__DeletedType(soap, "ns2:Deleted", &a->Deleted, "ns2:DeletedType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_Deleted;
		return a;
	}
	a->ContentIdentifierReference = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons2__ContentIdentifierReferenceType(soap, "ns2:ContentIdentifierReference", &a->ContentIdentifierReference, "ns2:ContentIdentifierReferenceType"))
	{	*choice = SOAP_UNION__ns2__union_GetResponseType_ContentIdentifierReference;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContentServiceCapabilitiesType(struct soap *soap, ns2__ContentServiceCapabilitiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContentServiceCapabilitiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContentServiceCapabilitiesType(struct soap *soap, const char *tag, int id, ns2__ContentServiceCapabilitiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContentServiceCapabilitiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ContentServiceCapabilitiesType ** SOAP_FMAC4 soap_in_PointerTons2__ContentServiceCapabilitiesType(struct soap *soap, const char *tag, ns2__ContentServiceCapabilitiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ContentServiceCapabilitiesType **)soap_malloc(soap, sizeof(ns2__ContentServiceCapabilitiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ContentServiceCapabilitiesType *)soap_instantiate_ns2__ContentServiceCapabilitiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ContentServiceCapabilitiesType ** p = (ns2__ContentServiceCapabilitiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContentServiceCapabilitiesType, sizeof(ns2__ContentServiceCapabilitiesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContentServiceCapabilitiesType(struct soap *soap, ns2__ContentServiceCapabilitiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContentServiceCapabilitiesType);
	if (soap_out_PointerTons2__ContentServiceCapabilitiesType(soap, tag?tag:"ns2:ContentServiceCapabilitiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ContentServiceCapabilitiesType ** SOAP_FMAC4 soap_get_PointerTons2__ContentServiceCapabilitiesType(struct soap *soap, ns2__ContentServiceCapabilitiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContentServiceCapabilitiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__GetCapabilitiesType(struct soap *soap, ns3__GetCapabilitiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__GetCapabilitiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__GetCapabilitiesType(struct soap *soap, const char *tag, int id, ns3__GetCapabilitiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__GetCapabilitiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__GetCapabilitiesType ** SOAP_FMAC4 soap_in_PointerTons3__GetCapabilitiesType(struct soap *soap, const char *tag, ns3__GetCapabilitiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__GetCapabilitiesType **)soap_malloc(soap, sizeof(ns3__GetCapabilitiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__GetCapabilitiesType *)soap_instantiate_ns3__GetCapabilitiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__GetCapabilitiesType ** p = (ns3__GetCapabilitiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__GetCapabilitiesType, sizeof(ns3__GetCapabilitiesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__GetCapabilitiesType(struct soap *soap, ns3__GetCapabilitiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__GetCapabilitiesType);
	if (soap_out_PointerTons3__GetCapabilitiesType(soap, tag?tag:"ns3:GetCapabilitiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__GetCapabilitiesType ** SOAP_FMAC4 soap_get_PointerTons3__GetCapabilitiesType(struct soap *soap, ns3__GetCapabilitiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__GetCapabilitiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UpdateType(struct soap *soap, ns2__UpdateType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UpdateType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UpdateType(struct soap *soap, const char *tag, int id, ns2__UpdateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UpdateType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__UpdateType ** SOAP_FMAC4 soap_in_PointerTons2__UpdateType(struct soap *soap, const char *tag, ns2__UpdateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__UpdateType **)soap_malloc(soap, sizeof(ns2__UpdateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__UpdateType *)soap_instantiate_ns2__UpdateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__UpdateType ** p = (ns2__UpdateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UpdateType, sizeof(ns2__UpdateType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UpdateType(struct soap *soap, ns2__UpdateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__UpdateType);
	if (soap_out_PointerTons2__UpdateType(soap, tag?tag:"ns2:UpdateType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__UpdateType ** SOAP_FMAC4 soap_get_PointerTons2__UpdateType(struct soap *soap, ns2__UpdateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UpdateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DeleteType(struct soap *soap, ns2__DeleteType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DeleteType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DeleteType(struct soap *soap, const char *tag, int id, ns2__DeleteType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DeleteType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DeleteType ** SOAP_FMAC4 soap_in_PointerTons2__DeleteType(struct soap *soap, const char *tag, ns2__DeleteType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DeleteType **)soap_malloc(soap, sizeof(ns2__DeleteType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DeleteType *)soap_instantiate_ns2__DeleteType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DeleteType ** p = (ns2__DeleteType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DeleteType, sizeof(ns2__DeleteType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DeleteType(struct soap *soap, ns2__DeleteType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DeleteType);
	if (soap_out_PointerTons2__DeleteType(soap, tag?tag:"ns2:DeleteType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DeleteType ** SOAP_FMAC4 soap_get_PointerTons2__DeleteType(struct soap *soap, ns2__DeleteType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DeleteType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__GetResponseType(struct soap *soap, ns2__GetResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__GetResponseType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__GetResponseType(struct soap *soap, const char *tag, int id, ns2__GetResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__GetResponseType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__GetResponseType ** SOAP_FMAC4 soap_in_PointerTons2__GetResponseType(struct soap *soap, const char *tag, ns2__GetResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__GetResponseType **)soap_malloc(soap, sizeof(ns2__GetResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__GetResponseType *)soap_instantiate_ns2__GetResponseType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__GetResponseType ** p = (ns2__GetResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__GetResponseType, sizeof(ns2__GetResponseType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__GetResponseType(struct soap *soap, ns2__GetResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__GetResponseType);
	if (soap_out_PointerTons2__GetResponseType(soap, tag?tag:"ns2:GetResponseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__GetResponseType ** SOAP_FMAC4 soap_get_PointerTons2__GetResponseType(struct soap *soap, ns2__GetResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__GetResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__GetType(struct soap *soap, ns2__GetType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__GetType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__GetType(struct soap *soap, const char *tag, int id, ns2__GetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__GetType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__GetType ** SOAP_FMAC4 soap_in_PointerTons2__GetType(struct soap *soap, const char *tag, ns2__GetType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__GetType **)soap_malloc(soap, sizeof(ns2__GetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__GetType *)soap_instantiate_ns2__GetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__GetType ** p = (ns2__GetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__GetType, sizeof(ns2__GetType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__GetType(struct soap *soap, ns2__GetType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__GetType);
	if (soap_out_PointerTons2__GetType(soap, tag?tag:"ns2:GetType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__GetType ** SOAP_FMAC4 soap_get_PointerTons2__GetType(struct soap *soap, ns2__GetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__GetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CreateResponseType(struct soap *soap, ns2__CreateResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CreateResponseType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CreateResponseType(struct soap *soap, const char *tag, int id, ns2__CreateResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CreateResponseType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CreateResponseType ** SOAP_FMAC4 soap_in_PointerTons2__CreateResponseType(struct soap *soap, const char *tag, ns2__CreateResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CreateResponseType **)soap_malloc(soap, sizeof(ns2__CreateResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CreateResponseType *)soap_instantiate_ns2__CreateResponseType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CreateResponseType ** p = (ns2__CreateResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CreateResponseType, sizeof(ns2__CreateResponseType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CreateResponseType(struct soap *soap, ns2__CreateResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CreateResponseType);
	if (soap_out_PointerTons2__CreateResponseType(soap, tag?tag:"ns2:CreateResponseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CreateResponseType ** SOAP_FMAC4 soap_get_PointerTons2__CreateResponseType(struct soap *soap, ns2__CreateResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CreateResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CreateType(struct soap *soap, ns2__CreateType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CreateType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CreateType(struct soap *soap, const char *tag, int id, ns2__CreateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CreateType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CreateType ** SOAP_FMAC4 soap_in_PointerTons2__CreateType(struct soap *soap, const char *tag, ns2__CreateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CreateType **)soap_malloc(soap, sizeof(ns2__CreateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CreateType *)soap_instantiate_ns2__CreateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CreateType ** p = (ns2__CreateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CreateType, sizeof(ns2__CreateType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CreateType(struct soap *soap, ns2__CreateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CreateType);
	if (soap_out_PointerTons2__CreateType(soap, tag?tag:"ns2:CreateType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CreateType ** SOAP_FMAC4 soap_get_PointerTons2__CreateType(struct soap *soap, ns2__CreateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CreateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OrganizationType(struct soap *soap, ns2__OrganizationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OrganizationType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OrganizationType(struct soap *soap, const char *tag, int id, ns2__OrganizationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OrganizationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OrganizationType ** SOAP_FMAC4 soap_in_PointerTons2__OrganizationType(struct soap *soap, const char *tag, ns2__OrganizationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OrganizationType **)soap_malloc(soap, sizeof(ns2__OrganizationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OrganizationType *)soap_instantiate_ns2__OrganizationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OrganizationType ** p = (ns2__OrganizationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OrganizationType, sizeof(ns2__OrganizationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OrganizationType(struct soap *soap, ns2__OrganizationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OrganizationType);
	if (soap_out_PointerTons2__OrganizationType(soap, tag?tag:"ns2:OrganizationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OrganizationType ** SOAP_FMAC4 soap_get_PointerTons2__OrganizationType(struct soap *soap, ns2__OrganizationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OrganizationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DetailedPlaceInfoType(struct soap *soap, ns2__DetailedPlaceInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DetailedPlaceInfoType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DetailedPlaceInfoType(struct soap *soap, const char *tag, int id, ns2__DetailedPlaceInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DetailedPlaceInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DetailedPlaceInfoType ** SOAP_FMAC4 soap_in_PointerTons2__DetailedPlaceInfoType(struct soap *soap, const char *tag, ns2__DetailedPlaceInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DetailedPlaceInfoType **)soap_malloc(soap, sizeof(ns2__DetailedPlaceInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DetailedPlaceInfoType *)soap_instantiate_ns2__DetailedPlaceInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DetailedPlaceInfoType ** p = (ns2__DetailedPlaceInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DetailedPlaceInfoType, sizeof(ns2__DetailedPlaceInfoType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DetailedPlaceInfoType(struct soap *soap, ns2__DetailedPlaceInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DetailedPlaceInfoType);
	if (soap_out_PointerTons2__DetailedPlaceInfoType(soap, tag?tag:"ns2:DetailedPlaceInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DetailedPlaceInfoType ** SOAP_FMAC4 soap_get_PointerTons2__DetailedPlaceInfoType(struct soap *soap, ns2__DetailedPlaceInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DetailedPlaceInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CIDNE_USCORECMODailyReportType(struct soap *soap, ns2__CIDNE_USCORECMODailyReportType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CIDNE_USCORECMODailyReportType(struct soap *soap, const char *tag, int id, ns2__CIDNE_USCORECMODailyReportType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CIDNE_USCORECMODailyReportType ** SOAP_FMAC4 soap_in_PointerTons2__CIDNE_USCORECMODailyReportType(struct soap *soap, const char *tag, ns2__CIDNE_USCORECMODailyReportType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CIDNE_USCORECMODailyReportType **)soap_malloc(soap, sizeof(ns2__CIDNE_USCORECMODailyReportType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CIDNE_USCORECMODailyReportType *)soap_instantiate_ns2__CIDNE_USCORECMODailyReportType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CIDNE_USCORECMODailyReportType ** p = (ns2__CIDNE_USCORECMODailyReportType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CIDNE_USCORECMODailyReportType, sizeof(ns2__CIDNE_USCORECMODailyReportType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CIDNE_USCORECMODailyReportType(struct soap *soap, ns2__CIDNE_USCORECMODailyReportType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CIDNE_USCORECMODailyReportType);
	if (soap_out_PointerTons2__CIDNE_USCORECMODailyReportType(soap, tag?tag:"ns2:CIDNE_CMODailyReportType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CIDNE_USCORECMODailyReportType ** SOAP_FMAC4 soap_get_PointerTons2__CIDNE_USCORECMODailyReportType(struct soap *soap, ns2__CIDNE_USCORECMODailyReportType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CIDNE_USCORECMODailyReportType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HTSAreaAssessmentType(struct soap *soap, ns2__HTSAreaAssessmentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HTSAreaAssessmentType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HTSAreaAssessmentType(struct soap *soap, const char *tag, int id, ns2__HTSAreaAssessmentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HTSAreaAssessmentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HTSAreaAssessmentType ** SOAP_FMAC4 soap_in_PointerTons2__HTSAreaAssessmentType(struct soap *soap, const char *tag, ns2__HTSAreaAssessmentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HTSAreaAssessmentType **)soap_malloc(soap, sizeof(ns2__HTSAreaAssessmentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HTSAreaAssessmentType *)soap_instantiate_ns2__HTSAreaAssessmentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__HTSAreaAssessmentType ** p = (ns2__HTSAreaAssessmentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HTSAreaAssessmentType, sizeof(ns2__HTSAreaAssessmentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HTSAreaAssessmentType(struct soap *soap, ns2__HTSAreaAssessmentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__HTSAreaAssessmentType);
	if (soap_out_PointerTons2__HTSAreaAssessmentType(soap, tag?tag:"ns2:HTSAreaAssessmentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HTSAreaAssessmentType ** SOAP_FMAC4 soap_get_PointerTons2__HTSAreaAssessmentType(struct soap *soap, ns2__HTSAreaAssessmentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HTSAreaAssessmentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CIDNE_USCOREPersonType(struct soap *soap, ns2__CIDNE_USCOREPersonType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CIDNE_USCOREPersonType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CIDNE_USCOREPersonType(struct soap *soap, const char *tag, int id, ns2__CIDNE_USCOREPersonType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CIDNE_USCOREPersonType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CIDNE_USCOREPersonType ** SOAP_FMAC4 soap_in_PointerTons2__CIDNE_USCOREPersonType(struct soap *soap, const char *tag, ns2__CIDNE_USCOREPersonType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CIDNE_USCOREPersonType **)soap_malloc(soap, sizeof(ns2__CIDNE_USCOREPersonType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CIDNE_USCOREPersonType *)soap_instantiate_ns2__CIDNE_USCOREPersonType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CIDNE_USCOREPersonType ** p = (ns2__CIDNE_USCOREPersonType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CIDNE_USCOREPersonType, sizeof(ns2__CIDNE_USCOREPersonType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CIDNE_USCOREPersonType(struct soap *soap, ns2__CIDNE_USCOREPersonType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CIDNE_USCOREPersonType);
	if (soap_out_PointerTons2__CIDNE_USCOREPersonType(soap, tag?tag:"ns2:CIDNE_PersonType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CIDNE_USCOREPersonType ** SOAP_FMAC4 soap_get_PointerTons2__CIDNE_USCOREPersonType(struct soap *soap, ns2__CIDNE_USCOREPersonType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CIDNE_USCOREPersonType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PeopleType(struct soap *soap, ns2__PeopleType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PeopleType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PeopleType(struct soap *soap, const char *tag, int id, ns2__PeopleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PeopleType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PeopleType ** SOAP_FMAC4 soap_in_PointerTons2__PeopleType(struct soap *soap, const char *tag, ns2__PeopleType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PeopleType **)soap_malloc(soap, sizeof(ns2__PeopleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PeopleType *)soap_instantiate_ns2__PeopleType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__PeopleType ** p = (ns2__PeopleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PeopleType, sizeof(ns2__PeopleType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PeopleType(struct soap *soap, ns2__PeopleType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PeopleType);
	if (soap_out_PointerTons2__PeopleType(soap, tag?tag:"ns2:PeopleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PeopleType ** SOAP_FMAC4 soap_get_PointerTons2__PeopleType(struct soap *soap, ns2__PeopleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PeopleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CategoryListType(struct soap *soap, ns2__CategoryListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CategoryListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CategoryListType(struct soap *soap, const char *tag, int id, ns2__CategoryListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CategoryListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CategoryListType ** SOAP_FMAC4 soap_in_PointerTons2__CategoryListType(struct soap *soap, const char *tag, ns2__CategoryListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CategoryListType **)soap_malloc(soap, sizeof(ns2__CategoryListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CategoryListType *)soap_instantiate_ns2__CategoryListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CategoryListType ** p = (ns2__CategoryListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CategoryListType, sizeof(ns2__CategoryListType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CategoryListType(struct soap *soap, ns2__CategoryListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CategoryListType);
	if (soap_out_PointerTons2__CategoryListType(soap, tag?tag:"ns2:CategoryListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CategoryListType ** SOAP_FMAC4 soap_get_PointerTons2__CategoryListType(struct soap *soap, ns2__CategoryListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CategoryListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MediaFileUrlType(struct soap *soap, ns2__MediaFileUrlType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MediaFileUrlType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MediaFileUrlType(struct soap *soap, const char *tag, int id, ns2__MediaFileUrlType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MediaFileUrlType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MediaFileUrlType ** SOAP_FMAC4 soap_in_PointerTons2__MediaFileUrlType(struct soap *soap, const char *tag, ns2__MediaFileUrlType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MediaFileUrlType **)soap_malloc(soap, sizeof(ns2__MediaFileUrlType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MediaFileUrlType *)soap_instantiate_ns2__MediaFileUrlType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MediaFileUrlType ** p = (ns2__MediaFileUrlType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MediaFileUrlType, sizeof(ns2__MediaFileUrlType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MediaFileUrlType(struct soap *soap, ns2__MediaFileUrlType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MediaFileUrlType);
	if (soap_out_PointerTons2__MediaFileUrlType(soap, tag?tag:"ns2:MediaFileUrlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MediaFileUrlType ** SOAP_FMAC4 soap_get_PointerTons2__MediaFileUrlType(struct soap *soap, ns2__MediaFileUrlType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MediaFileUrlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__TimePeriodType(struct soap *soap, ns3__TimePeriodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__TimePeriodType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__TimePeriodType(struct soap *soap, const char *tag, int id, ns3__TimePeriodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__TimePeriodType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__TimePeriodType ** SOAP_FMAC4 soap_in_PointerTons3__TimePeriodType(struct soap *soap, const char *tag, ns3__TimePeriodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__TimePeriodType **)soap_malloc(soap, sizeof(ns3__TimePeriodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__TimePeriodType *)soap_instantiate_ns3__TimePeriodType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__TimePeriodType ** p = (ns3__TimePeriodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__TimePeriodType, sizeof(ns3__TimePeriodType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__TimePeriodType(struct soap *soap, ns3__TimePeriodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__TimePeriodType);
	if (soap_out_PointerTons3__TimePeriodType(soap, tag?tag:"ns3:TimePeriodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__TimePeriodType ** SOAP_FMAC4 soap_get_PointerTons3__TimePeriodType(struct soap *soap, ns3__TimePeriodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__TimePeriodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LocationListType(struct soap *soap, ns2__LocationListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LocationListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LocationListType(struct soap *soap, const char *tag, int id, ns2__LocationListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LocationListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__LocationListType ** SOAP_FMAC4 soap_in_PointerTons2__LocationListType(struct soap *soap, const char *tag, ns2__LocationListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LocationListType **)soap_malloc(soap, sizeof(ns2__LocationListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LocationListType *)soap_instantiate_ns2__LocationListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__LocationListType ** p = (ns2__LocationListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LocationListType, sizeof(ns2__LocationListType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LocationListType(struct soap *soap, ns2__LocationListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__LocationListType);
	if (soap_out_PointerTons2__LocationListType(soap, tag?tag:"ns2:LocationListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__LocationListType ** SOAP_FMAC4 soap_get_PointerTons2__LocationListType(struct soap *soap, ns2__LocationListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LocationListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__NonEmptyStringType(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__NonEmptyStringType))
		soap_serialize_ns3__NonEmptyStringType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__NonEmptyStringType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__NonEmptyStringType);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__NonEmptyStringType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTons3__NonEmptyStringType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__NonEmptyStringType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__NonEmptyStringType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__NonEmptyStringType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__NonEmptyStringType);
	if (soap_out_PointerTons3__NonEmptyStringType(soap, tag?tag:"ns3:NonEmptyStringType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTons3__NonEmptyStringType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__NonEmptyStringType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AbstractContentReferenceHolderType(struct soap *soap, ns2__AbstractContentReferenceHolderType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AbstractContentReferenceHolderType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AbstractContentReferenceHolderType(struct soap *soap, const char *tag, int id, ns2__AbstractContentReferenceHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AbstractContentReferenceHolderType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AbstractContentReferenceHolderType ** SOAP_FMAC4 soap_in_PointerTons2__AbstractContentReferenceHolderType(struct soap *soap, const char *tag, ns2__AbstractContentReferenceHolderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AbstractContentReferenceHolderType **)soap_malloc(soap, sizeof(ns2__AbstractContentReferenceHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AbstractContentReferenceHolderType *)soap_instantiate_ns2__AbstractContentReferenceHolderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AbstractContentReferenceHolderType ** p = (ns2__AbstractContentReferenceHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AbstractContentReferenceHolderType, sizeof(ns2__AbstractContentReferenceHolderType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AbstractContentReferenceHolderType(struct soap *soap, ns2__AbstractContentReferenceHolderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AbstractContentReferenceHolderType);
	if (soap_out_PointerTons2__AbstractContentReferenceHolderType(soap, tag?tag:"ns2:AbstractContentReferenceHolderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AbstractContentReferenceHolderType ** SOAP_FMAC4 soap_get_PointerTons2__AbstractContentReferenceHolderType(struct soap *soap, ns2__AbstractContentReferenceHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AbstractContentReferenceHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AbstractContentReferenceListType(struct soap *soap, ns2__AbstractContentReferenceListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AbstractContentReferenceListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AbstractContentReferenceListType(struct soap *soap, const char *tag, int id, ns2__AbstractContentReferenceListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AbstractContentReferenceListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AbstractContentReferenceListType ** SOAP_FMAC4 soap_in_PointerTons2__AbstractContentReferenceListType(struct soap *soap, const char *tag, ns2__AbstractContentReferenceListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AbstractContentReferenceListType **)soap_malloc(soap, sizeof(ns2__AbstractContentReferenceListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AbstractContentReferenceListType *)soap_instantiate_ns2__AbstractContentReferenceListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AbstractContentReferenceListType ** p = (ns2__AbstractContentReferenceListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AbstractContentReferenceListType, sizeof(ns2__AbstractContentReferenceListType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AbstractContentReferenceListType(struct soap *soap, ns2__AbstractContentReferenceListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AbstractContentReferenceListType);
	if (soap_out_PointerTons2__AbstractContentReferenceListType(soap, tag?tag:"ns2:AbstractContentReferenceListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AbstractContentReferenceListType ** SOAP_FMAC4 soap_get_PointerTons2__AbstractContentReferenceListType(struct soap *soap, ns2__AbstractContentReferenceListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AbstractContentReferenceListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__MediaFileFormType(struct soap *soap, enum ns3__MediaFileFormType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns3__MediaFileFormType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__MediaFileFormType(struct soap *soap, const char *tag, int id, enum ns3__MediaFileFormType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__MediaFileFormType);
	if (id < 0)
		return soap->error;
	return soap_out_ns3__MediaFileFormType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns3__MediaFileFormType ** SOAP_FMAC4 soap_in_PointerTons3__MediaFileFormType(struct soap *soap, const char *tag, enum ns3__MediaFileFormType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns3__MediaFileFormType **)soap_malloc(soap, sizeof(enum ns3__MediaFileFormType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns3__MediaFileFormType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns3__MediaFileFormType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__MediaFileFormType, sizeof(enum ns3__MediaFileFormType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__MediaFileFormType(struct soap *soap, enum ns3__MediaFileFormType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__MediaFileFormType);
	if (soap_out_PointerTons3__MediaFileFormType(soap, tag?tag:"ns3:MediaFileFormType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns3__MediaFileFormType ** SOAP_FMAC4 soap_get_PointerTons3__MediaFileFormType(struct soap *soap, enum ns3__MediaFileFormType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__MediaFileFormType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__QName(struct soap *soap, xsd__QName *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__QName))
		soap_serialize_xsd__QName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__QName(struct soap *soap, const char *tag, int id, xsd__QName *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__QName);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 xsd__QName ** SOAP_FMAC4 soap_in_PointerToxsd__QName(struct soap *soap, const char *tag, xsd__QName **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__QName **)soap_malloc(soap, sizeof(xsd__QName *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (xsd__QName **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__QName, sizeof(xsd__QName), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__QName(struct soap *soap, xsd__QName *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__QName);
	if (soap_out_PointerToxsd__QName(soap, tag?tag:"xsd:QName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__QName ** SOAP_FMAC4 soap_get_PointerToxsd__QName(struct soap *soap, xsd__QName **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SecurityInfoListType(struct soap *soap, ns2__SecurityInfoListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SecurityInfoListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SecurityInfoListType(struct soap *soap, const char *tag, int id, ns2__SecurityInfoListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SecurityInfoListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SecurityInfoListType ** SOAP_FMAC4 soap_in_PointerTons2__SecurityInfoListType(struct soap *soap, const char *tag, ns2__SecurityInfoListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SecurityInfoListType **)soap_malloc(soap, sizeof(ns2__SecurityInfoListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SecurityInfoListType *)soap_instantiate_ns2__SecurityInfoListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SecurityInfoListType ** p = (ns2__SecurityInfoListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SecurityInfoListType, sizeof(ns2__SecurityInfoListType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SecurityInfoListType(struct soap *soap, ns2__SecurityInfoListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SecurityInfoListType);
	if (soap_out_PointerTons2__SecurityInfoListType(soap, tag?tag:"ns2:SecurityInfoListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SecurityInfoListType ** SOAP_FMAC4 soap_get_PointerTons2__SecurityInfoListType(struct soap *soap, ns2__SecurityInfoListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SecurityInfoListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContentAssociationModelListType(struct soap *soap, ns2__ContentAssociationModelListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContentAssociationModelListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContentAssociationModelListType(struct soap *soap, const char *tag, int id, ns2__ContentAssociationModelListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContentAssociationModelListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ContentAssociationModelListType ** SOAP_FMAC4 soap_in_PointerTons2__ContentAssociationModelListType(struct soap *soap, const char *tag, ns2__ContentAssociationModelListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ContentAssociationModelListType **)soap_malloc(soap, sizeof(ns2__ContentAssociationModelListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ContentAssociationModelListType *)soap_instantiate_ns2__ContentAssociationModelListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ContentAssociationModelListType ** p = (ns2__ContentAssociationModelListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContentAssociationModelListType, sizeof(ns2__ContentAssociationModelListType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContentAssociationModelListType(struct soap *soap, ns2__ContentAssociationModelListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContentAssociationModelListType);
	if (soap_out_PointerTons2__ContentAssociationModelListType(soap, tag?tag:"ns2:ContentAssociationModelListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ContentAssociationModelListType ** SOAP_FMAC4 soap_get_PointerTons2__ContentAssociationModelListType(struct soap *soap, ns2__ContentAssociationModelListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContentAssociationModelListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ForumPostUserPropertiesType(struct soap *soap, ns2__ForumPostUserPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ForumPostUserPropertiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ForumPostUserPropertiesType(struct soap *soap, const char *tag, int id, ns2__ForumPostUserPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ForumPostUserPropertiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ForumPostUserPropertiesType ** SOAP_FMAC4 soap_in_PointerTons2__ForumPostUserPropertiesType(struct soap *soap, const char *tag, ns2__ForumPostUserPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ForumPostUserPropertiesType **)soap_malloc(soap, sizeof(ns2__ForumPostUserPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ForumPostUserPropertiesType *)soap_instantiate_ns2__ForumPostUserPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ForumPostUserPropertiesType ** p = (ns2__ForumPostUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ForumPostUserPropertiesType, sizeof(ns2__ForumPostUserPropertiesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ForumPostUserPropertiesType(struct soap *soap, ns2__ForumPostUserPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ForumPostUserPropertiesType);
	if (soap_out_PointerTons2__ForumPostUserPropertiesType(soap, tag?tag:"ns2:ForumPostUserPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ForumPostUserPropertiesType ** SOAP_FMAC4 soap_get_PointerTons2__ForumPostUserPropertiesType(struct soap *soap, ns2__ForumPostUserPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ForumPostUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ForumTopicUserPropertiesType(struct soap *soap, ns2__ForumTopicUserPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ForumTopicUserPropertiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ForumTopicUserPropertiesType(struct soap *soap, const char *tag, int id, ns2__ForumTopicUserPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ForumTopicUserPropertiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ForumTopicUserPropertiesType ** SOAP_FMAC4 soap_in_PointerTons2__ForumTopicUserPropertiesType(struct soap *soap, const char *tag, ns2__ForumTopicUserPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ForumTopicUserPropertiesType **)soap_malloc(soap, sizeof(ns2__ForumTopicUserPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ForumTopicUserPropertiesType *)soap_instantiate_ns2__ForumTopicUserPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ForumTopicUserPropertiesType ** p = (ns2__ForumTopicUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ForumTopicUserPropertiesType, sizeof(ns2__ForumTopicUserPropertiesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ForumTopicUserPropertiesType(struct soap *soap, ns2__ForumTopicUserPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ForumTopicUserPropertiesType);
	if (soap_out_PointerTons2__ForumTopicUserPropertiesType(soap, tag?tag:"ns2:ForumTopicUserPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ForumTopicUserPropertiesType ** SOAP_FMAC4 soap_get_PointerTons2__ForumTopicUserPropertiesType(struct soap *soap, ns2__ForumTopicUserPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ForumTopicUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CollectionUserPropertiesType(struct soap *soap, ns2__CollectionUserPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CollectionUserPropertiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CollectionUserPropertiesType(struct soap *soap, const char *tag, int id, ns2__CollectionUserPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CollectionUserPropertiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CollectionUserPropertiesType ** SOAP_FMAC4 soap_in_PointerTons2__CollectionUserPropertiesType(struct soap *soap, const char *tag, ns2__CollectionUserPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CollectionUserPropertiesType **)soap_malloc(soap, sizeof(ns2__CollectionUserPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CollectionUserPropertiesType *)soap_instantiate_ns2__CollectionUserPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CollectionUserPropertiesType ** p = (ns2__CollectionUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CollectionUserPropertiesType, sizeof(ns2__CollectionUserPropertiesType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__CollectionUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SpecialCollectionUserPropertiesType, sizeof(ns2__SpecialCollectionUserPropertiesType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CollectionUserPropertiesType(struct soap *soap, ns2__CollectionUserPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CollectionUserPropertiesType);
	if (soap_out_PointerTons2__CollectionUserPropertiesType(soap, tag?tag:"ns2:CollectionUserPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CollectionUserPropertiesType ** SOAP_FMAC4 soap_get_PointerTons2__CollectionUserPropertiesType(struct soap *soap, ns2__CollectionUserPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CollectionUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReportUserPropertiesType(struct soap *soap, ns2__ReportUserPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ReportUserPropertiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReportUserPropertiesType(struct soap *soap, const char *tag, int id, ns2__ReportUserPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReportUserPropertiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ReportUserPropertiesType ** SOAP_FMAC4 soap_in_PointerTons2__ReportUserPropertiesType(struct soap *soap, const char *tag, ns2__ReportUserPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ReportUserPropertiesType **)soap_malloc(soap, sizeof(ns2__ReportUserPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ReportUserPropertiesType *)soap_instantiate_ns2__ReportUserPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ReportUserPropertiesType ** p = (ns2__ReportUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReportUserPropertiesType, sizeof(ns2__ReportUserPropertiesType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__ReportUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SpecialReportUserPropertiesType, sizeof(ns2__SpecialReportUserPropertiesType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReportUserPropertiesType(struct soap *soap, ns2__ReportUserPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ReportUserPropertiesType);
	if (soap_out_PointerTons2__ReportUserPropertiesType(soap, tag?tag:"ns2:ReportUserPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ReportUserPropertiesType ** SOAP_FMAC4 soap_get_PointerTons2__ReportUserPropertiesType(struct soap *soap, ns2__ReportUserPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReportUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PlaceUserPropertiesType(struct soap *soap, ns2__PlaceUserPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PlaceUserPropertiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PlaceUserPropertiesType(struct soap *soap, const char *tag, int id, ns2__PlaceUserPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PlaceUserPropertiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PlaceUserPropertiesType ** SOAP_FMAC4 soap_in_PointerTons2__PlaceUserPropertiesType(struct soap *soap, const char *tag, ns2__PlaceUserPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PlaceUserPropertiesType **)soap_malloc(soap, sizeof(ns2__PlaceUserPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PlaceUserPropertiesType *)soap_instantiate_ns2__PlaceUserPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__PlaceUserPropertiesType ** p = (ns2__PlaceUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PlaceUserPropertiesType, sizeof(ns2__PlaceUserPropertiesType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__PlaceUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SpecialPlaceUserPropertiesType, sizeof(ns2__SpecialPlaceUserPropertiesType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PlaceUserPropertiesType(struct soap *soap, ns2__PlaceUserPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PlaceUserPropertiesType);
	if (soap_out_PointerTons2__PlaceUserPropertiesType(soap, tag?tag:"ns2:PlaceUserPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PlaceUserPropertiesType ** SOAP_FMAC4 soap_get_PointerTons2__PlaceUserPropertiesType(struct soap *soap, ns2__PlaceUserPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PlaceUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EventUserPropertiesType(struct soap *soap, ns2__EventUserPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EventUserPropertiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EventUserPropertiesType(struct soap *soap, const char *tag, int id, ns2__EventUserPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EventUserPropertiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__EventUserPropertiesType ** SOAP_FMAC4 soap_in_PointerTons2__EventUserPropertiesType(struct soap *soap, const char *tag, ns2__EventUserPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EventUserPropertiesType **)soap_malloc(soap, sizeof(ns2__EventUserPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EventUserPropertiesType *)soap_instantiate_ns2__EventUserPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__EventUserPropertiesType ** p = (ns2__EventUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EventUserPropertiesType, sizeof(ns2__EventUserPropertiesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EventUserPropertiesType(struct soap *soap, ns2__EventUserPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EventUserPropertiesType);
	if (soap_out_PointerTons2__EventUserPropertiesType(soap, tag?tag:"ns2:EventUserPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EventUserPropertiesType ** SOAP_FMAC4 soap_get_PointerTons2__EventUserPropertiesType(struct soap *soap, ns2__EventUserPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EventUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ImageUserPropertiesType(struct soap *soap, ns2__ImageUserPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ImageUserPropertiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ImageUserPropertiesType(struct soap *soap, const char *tag, int id, ns2__ImageUserPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ImageUserPropertiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ImageUserPropertiesType ** SOAP_FMAC4 soap_in_PointerTons2__ImageUserPropertiesType(struct soap *soap, const char *tag, ns2__ImageUserPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ImageUserPropertiesType **)soap_malloc(soap, sizeof(ns2__ImageUserPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ImageUserPropertiesType *)soap_instantiate_ns2__ImageUserPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ImageUserPropertiesType ** p = (ns2__ImageUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ImageUserPropertiesType, sizeof(ns2__ImageUserPropertiesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ImageUserPropertiesType(struct soap *soap, ns2__ImageUserPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ImageUserPropertiesType);
	if (soap_out_PointerTons2__ImageUserPropertiesType(soap, tag?tag:"ns2:ImageUserPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ImageUserPropertiesType ** SOAP_FMAC4 soap_get_PointerTons2__ImageUserPropertiesType(struct soap *soap, ns2__ImageUserPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ImageUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MediaUserPropertiesType(struct soap *soap, ns2__MediaUserPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MediaUserPropertiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MediaUserPropertiesType(struct soap *soap, const char *tag, int id, ns2__MediaUserPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MediaUserPropertiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MediaUserPropertiesType ** SOAP_FMAC4 soap_in_PointerTons2__MediaUserPropertiesType(struct soap *soap, const char *tag, ns2__MediaUserPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MediaUserPropertiesType **)soap_malloc(soap, sizeof(ns2__MediaUserPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MediaUserPropertiesType *)soap_instantiate_ns2__MediaUserPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MediaUserPropertiesType ** p = (ns2__MediaUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MediaUserPropertiesType, sizeof(ns2__MediaUserPropertiesType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__MediaUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ImageUserPropertiesType, sizeof(ns2__ImageUserPropertiesType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MediaUserPropertiesType(struct soap *soap, ns2__MediaUserPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MediaUserPropertiesType);
	if (soap_out_PointerTons2__MediaUserPropertiesType(soap, tag?tag:"ns2:MediaUserPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MediaUserPropertiesType ** SOAP_FMAC4 soap_get_PointerTons2__MediaUserPropertiesType(struct soap *soap, ns2__MediaUserPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MediaUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AnnotationUserPropertiesType(struct soap *soap, ns2__AnnotationUserPropertiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AnnotationUserPropertiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AnnotationUserPropertiesType(struct soap *soap, const char *tag, int id, ns2__AnnotationUserPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AnnotationUserPropertiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AnnotationUserPropertiesType ** SOAP_FMAC4 soap_in_PointerTons2__AnnotationUserPropertiesType(struct soap *soap, const char *tag, ns2__AnnotationUserPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AnnotationUserPropertiesType **)soap_malloc(soap, sizeof(ns2__AnnotationUserPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AnnotationUserPropertiesType *)soap_instantiate_ns2__AnnotationUserPropertiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AnnotationUserPropertiesType ** p = (ns2__AnnotationUserPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AnnotationUserPropertiesType, sizeof(ns2__AnnotationUserPropertiesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AnnotationUserPropertiesType(struct soap *soap, ns2__AnnotationUserPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AnnotationUserPropertiesType);
	if (soap_out_PointerTons2__AnnotationUserPropertiesType(soap, tag?tag:"ns2:AnnotationUserPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AnnotationUserPropertiesType ** SOAP_FMAC4 soap_get_PointerTons2__AnnotationUserPropertiesType(struct soap *soap, ns2__AnnotationUserPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AnnotationUserPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReinforcementStatusType(struct soap *soap, enum ns2__ReinforcementStatusType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__ReinforcementStatusType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReinforcementStatusType(struct soap *soap, const char *tag, int id, enum ns2__ReinforcementStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReinforcementStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ReinforcementStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__ReinforcementStatusType ** SOAP_FMAC4 soap_in_PointerTons2__ReinforcementStatusType(struct soap *soap, const char *tag, enum ns2__ReinforcementStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__ReinforcementStatusType **)soap_malloc(soap, sizeof(enum ns2__ReinforcementStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ReinforcementStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__ReinforcementStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReinforcementStatusType, sizeof(enum ns2__ReinforcementStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReinforcementStatusType(struct soap *soap, enum ns2__ReinforcementStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ReinforcementStatusType);
	if (soap_out_PointerTons2__ReinforcementStatusType(soap, tag?tag:"ns2:ReinforcementStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ReinforcementStatusType ** SOAP_FMAC4 soap_get_PointerTons2__ReinforcementStatusType(struct soap *soap, enum ns2__ReinforcementStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReinforcementStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TrainingStatusType(struct soap *soap, enum ns2__TrainingStatusType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__TrainingStatusType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TrainingStatusType(struct soap *soap, const char *tag, int id, enum ns2__TrainingStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TrainingStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__TrainingStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__TrainingStatusType ** SOAP_FMAC4 soap_in_PointerTons2__TrainingStatusType(struct soap *soap, const char *tag, enum ns2__TrainingStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__TrainingStatusType **)soap_malloc(soap, sizeof(enum ns2__TrainingStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__TrainingStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__TrainingStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TrainingStatusType, sizeof(enum ns2__TrainingStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TrainingStatusType(struct soap *soap, enum ns2__TrainingStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__TrainingStatusType);
	if (soap_out_PointerTons2__TrainingStatusType(soap, tag?tag:"ns2:TrainingStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__TrainingStatusType ** SOAP_FMAC4 soap_get_PointerTons2__TrainingStatusType(struct soap *soap, enum ns2__TrainingStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TrainingStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CBRNDressStatusType(struct soap *soap, enum ns2__CBRNDressStatusType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__CBRNDressStatusType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CBRNDressStatusType(struct soap *soap, const char *tag, int id, enum ns2__CBRNDressStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CBRNDressStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__CBRNDressStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__CBRNDressStatusType ** SOAP_FMAC4 soap_in_PointerTons2__CBRNDressStatusType(struct soap *soap, const char *tag, enum ns2__CBRNDressStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__CBRNDressStatusType **)soap_malloc(soap, sizeof(enum ns2__CBRNDressStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__CBRNDressStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__CBRNDressStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CBRNDressStatusType, sizeof(enum ns2__CBRNDressStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CBRNDressStatusType(struct soap *soap, enum ns2__CBRNDressStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CBRNDressStatusType);
	if (soap_out_PointerTons2__CBRNDressStatusType(soap, tag?tag:"ns2:CBRNDressStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CBRNDressStatusType ** SOAP_FMAC4 soap_get_PointerTons2__CBRNDressStatusType(struct soap *soap, enum ns2__CBRNDressStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CBRNDressStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReadinessType(struct soap *soap, enum ns2__ReadinessType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__ReadinessType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReadinessType(struct soap *soap, const char *tag, int id, enum ns2__ReadinessType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReadinessType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ReadinessType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__ReadinessType ** SOAP_FMAC4 soap_in_PointerTons2__ReadinessType(struct soap *soap, const char *tag, enum ns2__ReadinessType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__ReadinessType **)soap_malloc(soap, sizeof(enum ns2__ReadinessType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ReadinessType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__ReadinessType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReadinessType, sizeof(enum ns2__ReadinessType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReadinessType(struct soap *soap, enum ns2__ReadinessType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ReadinessType);
	if (soap_out_PointerTons2__ReadinessType(soap, tag?tag:"ns2:ReadinessType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ReadinessType ** SOAP_FMAC4 soap_get_PointerTons2__ReadinessType(struct soap *soap, enum ns2__ReadinessType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReadinessType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CommitmentStatusType(struct soap *soap, enum ns2__CommitmentStatusType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__CommitmentStatusType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CommitmentStatusType(struct soap *soap, const char *tag, int id, enum ns2__CommitmentStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CommitmentStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__CommitmentStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__CommitmentStatusType ** SOAP_FMAC4 soap_in_PointerTons2__CommitmentStatusType(struct soap *soap, const char *tag, enum ns2__CommitmentStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__CommitmentStatusType **)soap_malloc(soap, sizeof(enum ns2__CommitmentStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__CommitmentStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__CommitmentStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CommitmentStatusType, sizeof(enum ns2__CommitmentStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CommitmentStatusType(struct soap *soap, enum ns2__CommitmentStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CommitmentStatusType);
	if (soap_out_PointerTons2__CommitmentStatusType(soap, tag?tag:"ns2:CommitmentStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CommitmentStatusType ** SOAP_FMAC4 soap_get_PointerTons2__CommitmentStatusType(struct soap *soap, enum ns2__CommitmentStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CommitmentStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__OrganizationType_UsageStatus(struct soap *soap, enum _ns2__OrganizationType_UsageStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__ns2__OrganizationType_UsageStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__OrganizationType_UsageStatus(struct soap *soap, const char *tag, int id, enum _ns2__OrganizationType_UsageStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__OrganizationType_UsageStatus);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__OrganizationType_UsageStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns2__OrganizationType_UsageStatus ** SOAP_FMAC4 soap_in_PointerTo_ns2__OrganizationType_UsageStatus(struct soap *soap, const char *tag, enum _ns2__OrganizationType_UsageStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns2__OrganizationType_UsageStatus **)soap_malloc(soap, sizeof(enum _ns2__OrganizationType_UsageStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__OrganizationType_UsageStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns2__OrganizationType_UsageStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__OrganizationType_UsageStatus, sizeof(enum _ns2__OrganizationType_UsageStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__OrganizationType_UsageStatus(struct soap *soap, enum _ns2__OrganizationType_UsageStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__OrganizationType_UsageStatus);
	if (soap_out_PointerTo_ns2__OrganizationType_UsageStatus(soap, tag?tag:"ns2:OrganizationType-UsageStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__OrganizationType_UsageStatus ** SOAP_FMAC4 soap_get_PointerTo_ns2__OrganizationType_UsageStatus(struct soap *soap, enum _ns2__OrganizationType_UsageStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__OrganizationType_UsageStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AvailabilityType(struct soap *soap, enum ns2__AvailabilityType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__AvailabilityType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AvailabilityType(struct soap *soap, const char *tag, int id, enum ns2__AvailabilityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AvailabilityType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__AvailabilityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__AvailabilityType ** SOAP_FMAC4 soap_in_PointerTons2__AvailabilityType(struct soap *soap, const char *tag, enum ns2__AvailabilityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__AvailabilityType **)soap_malloc(soap, sizeof(enum ns2__AvailabilityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__AvailabilityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__AvailabilityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AvailabilityType, sizeof(enum ns2__AvailabilityType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AvailabilityType(struct soap *soap, enum ns2__AvailabilityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AvailabilityType);
	if (soap_out_PointerTons2__AvailabilityType(soap, tag?tag:"ns2:AvailabilityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__AvailabilityType ** SOAP_FMAC4 soap_get_PointerTons2__AvailabilityType(struct soap *soap, enum ns2__AvailabilityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AvailabilityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__GroupPeopleType(struct soap *soap, enum ns2__GroupPeopleType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__GroupPeopleType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__GroupPeopleType(struct soap *soap, const char *tag, int id, enum ns2__GroupPeopleType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__GroupPeopleType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__GroupPeopleType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__GroupPeopleType ** SOAP_FMAC4 soap_in_PointerTons2__GroupPeopleType(struct soap *soap, const char *tag, enum ns2__GroupPeopleType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__GroupPeopleType **)soap_malloc(soap, sizeof(enum ns2__GroupPeopleType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__GroupPeopleType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__GroupPeopleType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__GroupPeopleType, sizeof(enum ns2__GroupPeopleType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__GroupPeopleType(struct soap *soap, enum ns2__GroupPeopleType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__GroupPeopleType);
	if (soap_out_PointerTons2__GroupPeopleType(soap, tag?tag:"ns2:GroupPeopleType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__GroupPeopleType ** SOAP_FMAC4 soap_get_PointerTons2__GroupPeopleType(struct soap *soap, enum ns2__GroupPeopleType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__GroupPeopleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CommandAndControlType(struct soap *soap, enum ns2__CommandAndControlType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__CommandAndControlType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CommandAndControlType(struct soap *soap, const char *tag, int id, enum ns2__CommandAndControlType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CommandAndControlType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__CommandAndControlType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__CommandAndControlType ** SOAP_FMAC4 soap_in_PointerTons2__CommandAndControlType(struct soap *soap, const char *tag, enum ns2__CommandAndControlType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__CommandAndControlType **)soap_malloc(soap, sizeof(enum ns2__CommandAndControlType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__CommandAndControlType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__CommandAndControlType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CommandAndControlType, sizeof(enum ns2__CommandAndControlType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CommandAndControlType(struct soap *soap, enum ns2__CommandAndControlType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CommandAndControlType);
	if (soap_out_PointerTons2__CommandAndControlType(soap, tag?tag:"ns2:CommandAndControlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__CommandAndControlType ** SOAP_FMAC4 soap_get_PointerTons2__CommandAndControlType(struct soap *soap, enum ns2__CommandAndControlType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CommandAndControlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__YesNoType(struct soap *soap, enum ns2__YesNoType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__YesNoType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__YesNoType(struct soap *soap, const char *tag, int id, enum ns2__YesNoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__YesNoType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__YesNoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__YesNoType ** SOAP_FMAC4 soap_in_PointerTons2__YesNoType(struct soap *soap, const char *tag, enum ns2__YesNoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__YesNoType **)soap_malloc(soap, sizeof(enum ns2__YesNoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__YesNoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__YesNoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__YesNoType, sizeof(enum ns2__YesNoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__YesNoType(struct soap *soap, enum ns2__YesNoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__YesNoType);
	if (soap_out_PointerTons2__YesNoType(soap, tag?tag:"ns2:YesNoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__YesNoType ** SOAP_FMAC4 soap_get_PointerTons2__YesNoType(struct soap *soap, enum ns2__YesNoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__YesNoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SecurityStatusType(struct soap *soap, enum ns2__SecurityStatusType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__SecurityStatusType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SecurityStatusType(struct soap *soap, const char *tag, int id, enum ns2__SecurityStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SecurityStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__SecurityStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__SecurityStatusType ** SOAP_FMAC4 soap_in_PointerTons2__SecurityStatusType(struct soap *soap, const char *tag, enum ns2__SecurityStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__SecurityStatusType **)soap_malloc(soap, sizeof(enum ns2__SecurityStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__SecurityStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__SecurityStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SecurityStatusType, sizeof(enum ns2__SecurityStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SecurityStatusType(struct soap *soap, enum ns2__SecurityStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SecurityStatusType);
	if (soap_out_PointerTons2__SecurityStatusType(soap, tag?tag:"ns2:SecurityStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__SecurityStatusType ** SOAP_FMAC4 soap_get_PointerTons2__SecurityStatusType(struct soap *soap, enum ns2__SecurityStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SecurityStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EnemyActivityPresentType(struct soap *soap, enum ns2__EnemyActivityPresentType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__EnemyActivityPresentType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EnemyActivityPresentType(struct soap *soap, const char *tag, int id, enum ns2__EnemyActivityPresentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EnemyActivityPresentType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__EnemyActivityPresentType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__EnemyActivityPresentType ** SOAP_FMAC4 soap_in_PointerTons2__EnemyActivityPresentType(struct soap *soap, const char *tag, enum ns2__EnemyActivityPresentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__EnemyActivityPresentType **)soap_malloc(soap, sizeof(enum ns2__EnemyActivityPresentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__EnemyActivityPresentType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__EnemyActivityPresentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EnemyActivityPresentType, sizeof(enum ns2__EnemyActivityPresentType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EnemyActivityPresentType(struct soap *soap, enum ns2__EnemyActivityPresentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EnemyActivityPresentType);
	if (soap_out_PointerTons2__EnemyActivityPresentType(soap, tag?tag:"ns2:EnemyActivityPresentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__EnemyActivityPresentType ** SOAP_FMAC4 soap_get_PointerTons2__EnemyActivityPresentType(struct soap *soap, enum ns2__EnemyActivityPresentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EnemyActivityPresentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(struct soap *soap, enum _ns2__DetailedPlaceInfoType_UsageStatus *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__ns2__DetailedPlaceInfoType_UsageStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(struct soap *soap, const char *tag, int id, enum _ns2__DetailedPlaceInfoType_UsageStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__DetailedPlaceInfoType_UsageStatus);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__DetailedPlaceInfoType_UsageStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _ns2__DetailedPlaceInfoType_UsageStatus ** SOAP_FMAC4 soap_in_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(struct soap *soap, const char *tag, enum _ns2__DetailedPlaceInfoType_UsageStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _ns2__DetailedPlaceInfoType_UsageStatus **)soap_malloc(soap, sizeof(enum _ns2__DetailedPlaceInfoType_UsageStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__DetailedPlaceInfoType_UsageStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _ns2__DetailedPlaceInfoType_UsageStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__DetailedPlaceInfoType_UsageStatus, sizeof(enum _ns2__DetailedPlaceInfoType_UsageStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(struct soap *soap, enum _ns2__DetailedPlaceInfoType_UsageStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus);
	if (soap_out_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(soap, tag?tag:"ns2:DetailedPlaceInfoType-UsageStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _ns2__DetailedPlaceInfoType_UsageStatus ** SOAP_FMAC4 soap_get_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(struct soap *soap, enum _ns2__DetailedPlaceInfoType_UsageStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__DetailedPlaceInfoType_UsageStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ConstructionType(struct soap *soap, enum ns2__ConstructionType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__ConstructionType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ConstructionType(struct soap *soap, const char *tag, int id, enum ns2__ConstructionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ConstructionType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__ConstructionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__ConstructionType ** SOAP_FMAC4 soap_in_PointerTons2__ConstructionType(struct soap *soap, const char *tag, enum ns2__ConstructionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__ConstructionType **)soap_malloc(soap, sizeof(enum ns2__ConstructionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__ConstructionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__ConstructionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ConstructionType, sizeof(enum ns2__ConstructionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ConstructionType(struct soap *soap, enum ns2__ConstructionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ConstructionType);
	if (soap_out_PointerTons2__ConstructionType(soap, tag?tag:"ns2:ConstructionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ConstructionType ** SOAP_FMAC4 soap_get_PointerTons2__ConstructionType(struct soap *soap, enum ns2__ConstructionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ConstructionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OccupationStatusType(struct soap *soap, enum ns2__OccupationStatusType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__OccupationStatusType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OccupationStatusType(struct soap *soap, const char *tag, int id, enum ns2__OccupationStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OccupationStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__OccupationStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__OccupationStatusType ** SOAP_FMAC4 soap_in_PointerTons2__OccupationStatusType(struct soap *soap, const char *tag, enum ns2__OccupationStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__OccupationStatusType **)soap_malloc(soap, sizeof(enum ns2__OccupationStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__OccupationStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__OccupationStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OccupationStatusType, sizeof(enum ns2__OccupationStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OccupationStatusType(struct soap *soap, enum ns2__OccupationStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OccupationStatusType);
	if (soap_out_PointerTons2__OccupationStatusType(soap, tag?tag:"ns2:OccupationStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__OccupationStatusType ** SOAP_FMAC4 soap_get_PointerTons2__OccupationStatusType(struct soap *soap, enum ns2__OccupationStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OccupationStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OperationalStatus2Type(struct soap *soap, enum ns2__OperationalStatus2Type *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__OperationalStatus2Type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OperationalStatus2Type(struct soap *soap, const char *tag, int id, enum ns2__OperationalStatus2Type *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OperationalStatus2Type);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__OperationalStatus2Type(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__OperationalStatus2Type ** SOAP_FMAC4 soap_in_PointerTons2__OperationalStatus2Type(struct soap *soap, const char *tag, enum ns2__OperationalStatus2Type **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__OperationalStatus2Type **)soap_malloc(soap, sizeof(enum ns2__OperationalStatus2Type *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__OperationalStatus2Type(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__OperationalStatus2Type **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OperationalStatus2Type, sizeof(enum ns2__OperationalStatus2Type), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OperationalStatus2Type(struct soap *soap, enum ns2__OperationalStatus2Type *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OperationalStatus2Type);
	if (soap_out_PointerTons2__OperationalStatus2Type(soap, tag?tag:"ns2:OperationalStatus2Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__OperationalStatus2Type ** SOAP_FMAC4 soap_get_PointerTons2__OperationalStatus2Type(struct soap *soap, enum ns2__OperationalStatus2Type **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OperationalStatus2Type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OperationalStatusType(struct soap *soap, enum ns2__OperationalStatusType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__OperationalStatusType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OperationalStatusType(struct soap *soap, const char *tag, int id, enum ns2__OperationalStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OperationalStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__OperationalStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__OperationalStatusType ** SOAP_FMAC4 soap_in_PointerTons2__OperationalStatusType(struct soap *soap, const char *tag, enum ns2__OperationalStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__OperationalStatusType **)soap_malloc(soap, sizeof(enum ns2__OperationalStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__OperationalStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__OperationalStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OperationalStatusType, sizeof(enum ns2__OperationalStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OperationalStatusType(struct soap *soap, enum ns2__OperationalStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OperationalStatusType);
	if (soap_out_PointerTons2__OperationalStatusType(soap, tag?tag:"ns2:OperationalStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__OperationalStatusType ** SOAP_FMAC4 soap_get_PointerTons2__OperationalStatusType(struct soap *soap, enum ns2__OperationalStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OperationalStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UpcomingEventType(struct soap *soap, ns2__UpcomingEventType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UpcomingEventType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UpcomingEventType(struct soap *soap, const char *tag, int id, ns2__UpcomingEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UpcomingEventType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__UpcomingEventType ** SOAP_FMAC4 soap_in_PointerTons2__UpcomingEventType(struct soap *soap, const char *tag, ns2__UpcomingEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__UpcomingEventType **)soap_malloc(soap, sizeof(ns2__UpcomingEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__UpcomingEventType *)soap_instantiate_ns2__UpcomingEventType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__UpcomingEventType ** p = (ns2__UpcomingEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UpcomingEventType, sizeof(ns2__UpcomingEventType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UpcomingEventType(struct soap *soap, ns2__UpcomingEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__UpcomingEventType);
	if (soap_out_PointerTons2__UpcomingEventType(soap, tag?tag:"ns2:UpcomingEventType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__UpcomingEventType ** SOAP_FMAC4 soap_get_PointerTons2__UpcomingEventType(struct soap *soap, ns2__UpcomingEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UpcomingEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PEMSIIOutcomeType(struct soap *soap, ns2__PEMSIIOutcomeType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PEMSIIOutcomeType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PEMSIIOutcomeType(struct soap *soap, const char *tag, int id, ns2__PEMSIIOutcomeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PEMSIIOutcomeType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PEMSIIOutcomeType ** SOAP_FMAC4 soap_in_PointerTons2__PEMSIIOutcomeType(struct soap *soap, const char *tag, ns2__PEMSIIOutcomeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PEMSIIOutcomeType **)soap_malloc(soap, sizeof(ns2__PEMSIIOutcomeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PEMSIIOutcomeType *)soap_instantiate_ns2__PEMSIIOutcomeType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__PEMSIIOutcomeType ** p = (ns2__PEMSIIOutcomeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PEMSIIOutcomeType, sizeof(ns2__PEMSIIOutcomeType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PEMSIIOutcomeType(struct soap *soap, ns2__PEMSIIOutcomeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PEMSIIOutcomeType);
	if (soap_out_PointerTons2__PEMSIIOutcomeType(soap, tag?tag:"ns2:PEMSIIOutcomeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PEMSIIOutcomeType ** SOAP_FMAC4 soap_get_PointerTons2__PEMSIIOutcomeType(struct soap *soap, ns2__PEMSIIOutcomeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PEMSIIOutcomeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UpcomingEventsType(struct soap *soap, ns2__UpcomingEventsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UpcomingEventsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UpcomingEventsType(struct soap *soap, const char *tag, int id, ns2__UpcomingEventsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UpcomingEventsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__UpcomingEventsType ** SOAP_FMAC4 soap_in_PointerTons2__UpcomingEventsType(struct soap *soap, const char *tag, ns2__UpcomingEventsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__UpcomingEventsType **)soap_malloc(soap, sizeof(ns2__UpcomingEventsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__UpcomingEventsType *)soap_instantiate_ns2__UpcomingEventsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__UpcomingEventsType ** p = (ns2__UpcomingEventsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UpcomingEventsType, sizeof(ns2__UpcomingEventsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UpcomingEventsType(struct soap *soap, ns2__UpcomingEventsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__UpcomingEventsType);
	if (soap_out_PointerTons2__UpcomingEventsType(soap, tag?tag:"ns2:UpcomingEventsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__UpcomingEventsType ** SOAP_FMAC4 soap_get_PointerTons2__UpcomingEventsType(struct soap *soap, ns2__UpcomingEventsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UpcomingEventsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AssessmentsType(struct soap *soap, ns2__AssessmentsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AssessmentsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AssessmentsType(struct soap *soap, const char *tag, int id, ns2__AssessmentsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AssessmentsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AssessmentsType ** SOAP_FMAC4 soap_in_PointerTons2__AssessmentsType(struct soap *soap, const char *tag, ns2__AssessmentsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AssessmentsType **)soap_malloc(soap, sizeof(ns2__AssessmentsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AssessmentsType *)soap_instantiate_ns2__AssessmentsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AssessmentsType ** p = (ns2__AssessmentsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AssessmentsType, sizeof(ns2__AssessmentsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AssessmentsType(struct soap *soap, ns2__AssessmentsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AssessmentsType);
	if (soap_out_PointerTons2__AssessmentsType(soap, tag?tag:"ns2:AssessmentsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AssessmentsType ** SOAP_FMAC4 soap_get_PointerTons2__AssessmentsType(struct soap *soap, ns2__AssessmentsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AssessmentsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PEMSIIOutcomesType(struct soap *soap, ns2__PEMSIIOutcomesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PEMSIIOutcomesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PEMSIIOutcomesType(struct soap *soap, const char *tag, int id, ns2__PEMSIIOutcomesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PEMSIIOutcomesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PEMSIIOutcomesType ** SOAP_FMAC4 soap_in_PointerTons2__PEMSIIOutcomesType(struct soap *soap, const char *tag, ns2__PEMSIIOutcomesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PEMSIIOutcomesType **)soap_malloc(soap, sizeof(ns2__PEMSIIOutcomesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PEMSIIOutcomesType *)soap_instantiate_ns2__PEMSIIOutcomesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__PEMSIIOutcomesType ** p = (ns2__PEMSIIOutcomesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PEMSIIOutcomesType, sizeof(ns2__PEMSIIOutcomesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PEMSIIOutcomesType(struct soap *soap, ns2__PEMSIIOutcomesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PEMSIIOutcomesType);
	if (soap_out_PointerTons2__PEMSIIOutcomesType(soap, tag?tag:"ns2:PEMSIIOutcomesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PEMSIIOutcomesType ** SOAP_FMAC4 soap_get_PointerTons2__PEMSIIOutcomesType(struct soap *soap, ns2__PEMSIIOutcomesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PEMSIIOutcomesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OtherIDType(struct soap *soap, ns2__OtherIDType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OtherIDType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OtherIDType(struct soap *soap, const char *tag, int id, ns2__OtherIDType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OtherIDType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OtherIDType ** SOAP_FMAC4 soap_in_PointerTons2__OtherIDType(struct soap *soap, const char *tag, ns2__OtherIDType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OtherIDType **)soap_malloc(soap, sizeof(ns2__OtherIDType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OtherIDType *)soap_instantiate_ns2__OtherIDType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OtherIDType ** p = (ns2__OtherIDType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OtherIDType, sizeof(ns2__OtherIDType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OtherIDType(struct soap *soap, ns2__OtherIDType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OtherIDType);
	if (soap_out_PointerTons2__OtherIDType(soap, tag?tag:"ns2:OtherIDType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OtherIDType ** SOAP_FMAC4 soap_get_PointerTons2__OtherIDType(struct soap *soap, ns2__OtherIDType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OtherIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RemarkType(struct soap *soap, ns2__RemarkType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RemarkType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RemarkType(struct soap *soap, const char *tag, int id, ns2__RemarkType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RemarkType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RemarkType ** SOAP_FMAC4 soap_in_PointerTons2__RemarkType(struct soap *soap, const char *tag, ns2__RemarkType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RemarkType **)soap_malloc(soap, sizeof(ns2__RemarkType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RemarkType *)soap_instantiate_ns2__RemarkType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RemarkType ** p = (ns2__RemarkType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RemarkType, sizeof(ns2__RemarkType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RemarkType(struct soap *soap, ns2__RemarkType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RemarkType);
	if (soap_out_PointerTons2__RemarkType(soap, tag?tag:"ns2:RemarkType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RemarkType ** SOAP_FMAC4 soap_get_PointerTons2__RemarkType(struct soap *soap, ns2__RemarkType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RemarkType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LocationInfoType(struct soap *soap, ns2__LocationInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LocationInfoType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LocationInfoType(struct soap *soap, const char *tag, int id, ns2__LocationInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LocationInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__LocationInfoType ** SOAP_FMAC4 soap_in_PointerTons2__LocationInfoType(struct soap *soap, const char *tag, ns2__LocationInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LocationInfoType **)soap_malloc(soap, sizeof(ns2__LocationInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LocationInfoType *)soap_instantiate_ns2__LocationInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__LocationInfoType ** p = (ns2__LocationInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LocationInfoType, sizeof(ns2__LocationInfoType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LocationInfoType(struct soap *soap, ns2__LocationInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__LocationInfoType);
	if (soap_out_PointerTons2__LocationInfoType(soap, tag?tag:"ns2:LocationInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__LocationInfoType ** SOAP_FMAC4 soap_get_PointerTons2__LocationInfoType(struct soap *soap, ns2__LocationInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LocationInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FamilyMemberInfoType(struct soap *soap, ns2__FamilyMemberInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FamilyMemberInfoType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FamilyMemberInfoType(struct soap *soap, const char *tag, int id, ns2__FamilyMemberInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FamilyMemberInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FamilyMemberInfoType ** SOAP_FMAC4 soap_in_PointerTons2__FamilyMemberInfoType(struct soap *soap, const char *tag, ns2__FamilyMemberInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FamilyMemberInfoType **)soap_malloc(soap, sizeof(ns2__FamilyMemberInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FamilyMemberInfoType *)soap_instantiate_ns2__FamilyMemberInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__FamilyMemberInfoType ** p = (ns2__FamilyMemberInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FamilyMemberInfoType, sizeof(ns2__FamilyMemberInfoType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FamilyMemberInfoType(struct soap *soap, ns2__FamilyMemberInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FamilyMemberInfoType);
	if (soap_out_PointerTons2__FamilyMemberInfoType(soap, tag?tag:"ns2:FamilyMemberInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FamilyMemberInfoType ** SOAP_FMAC4 soap_get_PointerTons2__FamilyMemberInfoType(struct soap *soap, ns2__FamilyMemberInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FamilyMemberInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VehicleInfoType(struct soap *soap, ns2__VehicleInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VehicleInfoType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VehicleInfoType(struct soap *soap, const char *tag, int id, ns2__VehicleInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VehicleInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VehicleInfoType ** SOAP_FMAC4 soap_in_PointerTons2__VehicleInfoType(struct soap *soap, const char *tag, ns2__VehicleInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VehicleInfoType **)soap_malloc(soap, sizeof(ns2__VehicleInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VehicleInfoType *)soap_instantiate_ns2__VehicleInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__VehicleInfoType ** p = (ns2__VehicleInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VehicleInfoType, sizeof(ns2__VehicleInfoType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VehicleInfoType(struct soap *soap, ns2__VehicleInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__VehicleInfoType);
	if (soap_out_PointerTons2__VehicleInfoType(soap, tag?tag:"ns2:VehicleInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VehicleInfoType ** SOAP_FMAC4 soap_get_PointerTons2__VehicleInfoType(struct soap *soap, ns2__VehicleInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VehicleInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PEMSIIType(struct soap *soap, ns2__PEMSIIType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PEMSIIType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PEMSIIType(struct soap *soap, const char *tag, int id, ns2__PEMSIIType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PEMSIIType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PEMSIIType ** SOAP_FMAC4 soap_in_PointerTons2__PEMSIIType(struct soap *soap, const char *tag, ns2__PEMSIIType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PEMSIIType **)soap_malloc(soap, sizeof(ns2__PEMSIIType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PEMSIIType *)soap_instantiate_ns2__PEMSIIType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__PEMSIIType ** p = (ns2__PEMSIIType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PEMSIIType, sizeof(ns2__PEMSIIType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PEMSIIType(struct soap *soap, ns2__PEMSIIType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PEMSIIType);
	if (soap_out_PointerTons2__PEMSIIType(soap, tag?tag:"ns2:PEMSIIType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PEMSIIType ** SOAP_FMAC4 soap_get_PointerTons2__PEMSIIType(struct soap *soap, ns2__PEMSIIType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PEMSIIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DescriptionType(struct soap *soap, ns2__DescriptionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DescriptionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DescriptionType(struct soap *soap, const char *tag, int id, ns2__DescriptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DescriptionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DescriptionType ** SOAP_FMAC4 soap_in_PointerTons2__DescriptionType(struct soap *soap, const char *tag, ns2__DescriptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DescriptionType **)soap_malloc(soap, sizeof(ns2__DescriptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DescriptionType *)soap_instantiate_ns2__DescriptionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DescriptionType ** p = (ns2__DescriptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DescriptionType, sizeof(ns2__DescriptionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DescriptionType(struct soap *soap, ns2__DescriptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DescriptionType);
	if (soap_out_PointerTons2__DescriptionType(soap, tag?tag:"ns2:DescriptionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DescriptionType ** SOAP_FMAC4 soap_get_PointerTons2__DescriptionType(struct soap *soap, ns2__DescriptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TitleAliasIdInfoType(struct soap *soap, ns2__TitleAliasIdInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TitleAliasIdInfoType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TitleAliasIdInfoType(struct soap *soap, const char *tag, int id, ns2__TitleAliasIdInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TitleAliasIdInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__TitleAliasIdInfoType ** SOAP_FMAC4 soap_in_PointerTons2__TitleAliasIdInfoType(struct soap *soap, const char *tag, ns2__TitleAliasIdInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TitleAliasIdInfoType **)soap_malloc(soap, sizeof(ns2__TitleAliasIdInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TitleAliasIdInfoType *)soap_instantiate_ns2__TitleAliasIdInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__TitleAliasIdInfoType ** p = (ns2__TitleAliasIdInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TitleAliasIdInfoType, sizeof(ns2__TitleAliasIdInfoType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TitleAliasIdInfoType(struct soap *soap, ns2__TitleAliasIdInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__TitleAliasIdInfoType);
	if (soap_out_PointerTons2__TitleAliasIdInfoType(soap, tag?tag:"ns2:TitleAliasIdInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TitleAliasIdInfoType ** SOAP_FMAC4 soap_get_PointerTons2__TitleAliasIdInfoType(struct soap *soap, ns2__TitleAliasIdInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TitleAliasIdInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContactInfoType(struct soap *soap, ns2__ContactInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContactInfoType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContactInfoType(struct soap *soap, const char *tag, int id, ns2__ContactInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContactInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ContactInfoType ** SOAP_FMAC4 soap_in_PointerTons2__ContactInfoType(struct soap *soap, const char *tag, ns2__ContactInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ContactInfoType **)soap_malloc(soap, sizeof(ns2__ContactInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ContactInfoType *)soap_instantiate_ns2__ContactInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ContactInfoType ** p = (ns2__ContactInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContactInfoType, sizeof(ns2__ContactInfoType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContactInfoType(struct soap *soap, ns2__ContactInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContactInfoType);
	if (soap_out_PointerTons2__ContactInfoType(soap, tag?tag:"ns2:ContactInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ContactInfoType ** SOAP_FMAC4 soap_get_PointerTons2__ContactInfoType(struct soap *soap, ns2__ContactInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContactInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CIDNE_USCOREPersonalInfoType(struct soap *soap, ns2__CIDNE_USCOREPersonalInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CIDNE_USCOREPersonalInfoType(struct soap *soap, const char *tag, int id, ns2__CIDNE_USCOREPersonalInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CIDNE_USCOREPersonalInfoType ** SOAP_FMAC4 soap_in_PointerTons2__CIDNE_USCOREPersonalInfoType(struct soap *soap, const char *tag, ns2__CIDNE_USCOREPersonalInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CIDNE_USCOREPersonalInfoType **)soap_malloc(soap, sizeof(ns2__CIDNE_USCOREPersonalInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CIDNE_USCOREPersonalInfoType *)soap_instantiate_ns2__CIDNE_USCOREPersonalInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CIDNE_USCOREPersonalInfoType ** p = (ns2__CIDNE_USCOREPersonalInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CIDNE_USCOREPersonalInfoType, sizeof(ns2__CIDNE_USCOREPersonalInfoType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CIDNE_USCOREPersonalInfoType(struct soap *soap, ns2__CIDNE_USCOREPersonalInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CIDNE_USCOREPersonalInfoType);
	if (soap_out_PointerTons2__CIDNE_USCOREPersonalInfoType(soap, tag?tag:"ns2:CIDNE_PersonalInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CIDNE_USCOREPersonalInfoType ** SOAP_FMAC4 soap_get_PointerTons2__CIDNE_USCOREPersonalInfoType(struct soap *soap, ns2__CIDNE_USCOREPersonalInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CIDNE_USCOREPersonalInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NameInfoType(struct soap *soap, ns2__NameInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NameInfoType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NameInfoType(struct soap *soap, const char *tag, int id, ns2__NameInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NameInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NameInfoType ** SOAP_FMAC4 soap_in_PointerTons2__NameInfoType(struct soap *soap, const char *tag, ns2__NameInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NameInfoType **)soap_malloc(soap, sizeof(ns2__NameInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NameInfoType *)soap_instantiate_ns2__NameInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NameInfoType ** p = (ns2__NameInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NameInfoType, sizeof(ns2__NameInfoType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NameInfoType(struct soap *soap, ns2__NameInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NameInfoType);
	if (soap_out_PointerTons2__NameInfoType(soap, tag?tag:"ns2:NameInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NameInfoType ** SOAP_FMAC4 soap_get_PointerTons2__NameInfoType(struct soap *soap, ns2__NameInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NameInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PhysicalStatus2Type(struct soap *soap, enum ns2__PhysicalStatus2Type *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__PhysicalStatus2Type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PhysicalStatus2Type(struct soap *soap, const char *tag, int id, enum ns2__PhysicalStatus2Type *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PhysicalStatus2Type);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PhysicalStatus2Type(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__PhysicalStatus2Type ** SOAP_FMAC4 soap_in_PointerTons2__PhysicalStatus2Type(struct soap *soap, const char *tag, enum ns2__PhysicalStatus2Type **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__PhysicalStatus2Type **)soap_malloc(soap, sizeof(enum ns2__PhysicalStatus2Type *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PhysicalStatus2Type(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__PhysicalStatus2Type **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PhysicalStatus2Type, sizeof(enum ns2__PhysicalStatus2Type), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PhysicalStatus2Type(struct soap *soap, enum ns2__PhysicalStatus2Type *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PhysicalStatus2Type);
	if (soap_out_PointerTons2__PhysicalStatus2Type(soap, tag?tag:"ns2:PhysicalStatus2Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PhysicalStatus2Type ** SOAP_FMAC4 soap_get_PointerTons2__PhysicalStatus2Type(struct soap *soap, enum ns2__PhysicalStatus2Type **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PhysicalStatus2Type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PhysicalStatusType(struct soap *soap, enum ns2__PhysicalStatusType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__PhysicalStatusType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PhysicalStatusType(struct soap *soap, const char *tag, int id, enum ns2__PhysicalStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PhysicalStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PhysicalStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__PhysicalStatusType ** SOAP_FMAC4 soap_in_PointerTons2__PhysicalStatusType(struct soap *soap, const char *tag, enum ns2__PhysicalStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__PhysicalStatusType **)soap_malloc(soap, sizeof(enum ns2__PhysicalStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PhysicalStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__PhysicalStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PhysicalStatusType, sizeof(enum ns2__PhysicalStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PhysicalStatusType(struct soap *soap, enum ns2__PhysicalStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PhysicalStatusType);
	if (soap_out_PointerTons2__PhysicalStatusType(soap, tag?tag:"ns2:PhysicalStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PhysicalStatusType ** SOAP_FMAC4 soap_get_PointerTons2__PhysicalStatusType(struct soap *soap, enum ns2__PhysicalStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PhysicalStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DutyStatusType(struct soap *soap, enum ns2__DutyStatusType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__DutyStatusType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DutyStatusType(struct soap *soap, const char *tag, int id, enum ns2__DutyStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DutyStatusType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__DutyStatusType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__DutyStatusType ** SOAP_FMAC4 soap_in_PointerTons2__DutyStatusType(struct soap *soap, const char *tag, enum ns2__DutyStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__DutyStatusType **)soap_malloc(soap, sizeof(enum ns2__DutyStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__DutyStatusType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__DutyStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DutyStatusType, sizeof(enum ns2__DutyStatusType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DutyStatusType(struct soap *soap, enum ns2__DutyStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DutyStatusType);
	if (soap_out_PointerTons2__DutyStatusType(soap, tag?tag:"ns2:DutyStatusType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__DutyStatusType ** SOAP_FMAC4 soap_get_PointerTons2__DutyStatusType(struct soap *soap, enum ns2__DutyStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DutyStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__GenderType(struct soap *soap, enum ns2__GenderType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__GenderType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__GenderType(struct soap *soap, const char *tag, int id, enum ns2__GenderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__GenderType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__GenderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__GenderType ** SOAP_FMAC4 soap_in_PointerTons2__GenderType(struct soap *soap, const char *tag, enum ns2__GenderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__GenderType **)soap_malloc(soap, sizeof(enum ns2__GenderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__GenderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__GenderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__GenderType, sizeof(enum ns2__GenderType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__GenderType(struct soap *soap, enum ns2__GenderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__GenderType);
	if (soap_out_PointerTons2__GenderType(soap, tag?tag:"ns2:GenderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__GenderType ** SOAP_FMAC4 soap_get_PointerTons2__GenderType(struct soap *soap, enum ns2__GenderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__GenderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RankType(struct soap *soap, enum ns2__RankType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__RankType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RankType(struct soap *soap, const char *tag, int id, enum ns2__RankType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RankType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__RankType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__RankType ** SOAP_FMAC4 soap_in_PointerTons2__RankType(struct soap *soap, const char *tag, enum ns2__RankType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__RankType **)soap_malloc(soap, sizeof(enum ns2__RankType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__RankType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__RankType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RankType, sizeof(enum ns2__RankType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RankType(struct soap *soap, enum ns2__RankType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RankType);
	if (soap_out_PointerTons2__RankType(soap, tag?tag:"ns2:RankType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__RankType ** SOAP_FMAC4 soap_get_PointerTons2__RankType(struct soap *soap, enum ns2__RankType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RankType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PeopleType2Type(struct soap *soap, enum ns2__PeopleType2Type *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__PeopleType2Type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PeopleType2Type(struct soap *soap, const char *tag, int id, enum ns2__PeopleType2Type *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PeopleType2Type);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PeopleType2Type(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__PeopleType2Type ** SOAP_FMAC4 soap_in_PointerTons2__PeopleType2Type(struct soap *soap, const char *tag, enum ns2__PeopleType2Type **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__PeopleType2Type **)soap_malloc(soap, sizeof(enum ns2__PeopleType2Type *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PeopleType2Type(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__PeopleType2Type **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PeopleType2Type, sizeof(enum ns2__PeopleType2Type), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PeopleType2Type(struct soap *soap, enum ns2__PeopleType2Type *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PeopleType2Type);
	if (soap_out_PointerTons2__PeopleType2Type(soap, tag?tag:"ns2:PeopleType2Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PeopleType2Type ** SOAP_FMAC4 soap_get_PointerTons2__PeopleType2Type(struct soap *soap, enum ns2__PeopleType2Type **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PeopleType2Type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PeopleTypeType(struct soap *soap, enum ns2__PeopleTypeType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns2__PeopleTypeType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PeopleTypeType(struct soap *soap, const char *tag, int id, enum ns2__PeopleTypeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PeopleTypeType);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__PeopleTypeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns2__PeopleTypeType ** SOAP_FMAC4 soap_in_PointerTons2__PeopleTypeType(struct soap *soap, const char *tag, enum ns2__PeopleTypeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns2__PeopleTypeType **)soap_malloc(soap, sizeof(enum ns2__PeopleTypeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__PeopleTypeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns2__PeopleTypeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PeopleTypeType, sizeof(enum ns2__PeopleTypeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PeopleTypeType(struct soap *soap, enum ns2__PeopleTypeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PeopleTypeType);
	if (soap_out_PointerTons2__PeopleTypeType(soap, tag?tag:"ns2:PeopleTypeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__PeopleTypeType ** SOAP_FMAC4 soap_get_PointerTons2__PeopleTypeType(struct soap *soap, enum ns2__PeopleTypeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PeopleTypeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns2__union_LocationListType(struct soap *soap, __ns2__union_LocationListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns2__union_LocationListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns2__union_LocationListType(struct soap *soap, const char *tag, int id, __ns2__union_LocationListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns2__union_LocationListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns2__union_LocationListType ** SOAP_FMAC4 soap_in_PointerTo__ns2__union_LocationListType(struct soap *soap, const char *tag, __ns2__union_LocationListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns2__union_LocationListType **)soap_malloc(soap, sizeof(__ns2__union_LocationListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns2__union_LocationListType *)soap_instantiate___ns2__union_LocationListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns2__union_LocationListType ** p = (__ns2__union_LocationListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns2__union_LocationListType, sizeof(__ns2__union_LocationListType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns2__union_LocationListType(struct soap *soap, __ns2__union_LocationListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns2__union_LocationListType);
	if (soap_out_PointerTo__ns2__union_LocationListType(soap, tag?tag:"-ns2:union-LocationListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns2__union_LocationListType ** SOAP_FMAC4 soap_get_PointerTo__ns2__union_LocationListType(struct soap *soap, __ns2__union_LocationListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns2__union_LocationListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__PolygonType(struct soap *soap, ns3__PolygonType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__PolygonType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__PolygonType(struct soap *soap, const char *tag, int id, ns3__PolygonType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__PolygonType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__PolygonType ** SOAP_FMAC4 soap_in_PointerTons3__PolygonType(struct soap *soap, const char *tag, ns3__PolygonType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__PolygonType **)soap_malloc(soap, sizeof(ns3__PolygonType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__PolygonType *)soap_instantiate_ns3__PolygonType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__PolygonType ** p = (ns3__PolygonType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__PolygonType, sizeof(ns3__PolygonType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__PolygonType(struct soap *soap, ns3__PolygonType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__PolygonType);
	if (soap_out_PointerTons3__PolygonType(soap, tag?tag:"ns3:PolygonType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__PolygonType ** SOAP_FMAC4 soap_get_PointerTons3__PolygonType(struct soap *soap, ns3__PolygonType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__PolygonType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__LinearRingType(struct soap *soap, ns3__LinearRingType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__LinearRingType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__LinearRingType(struct soap *soap, const char *tag, int id, ns3__LinearRingType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__LinearRingType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__LinearRingType ** SOAP_FMAC4 soap_in_PointerTons3__LinearRingType(struct soap *soap, const char *tag, ns3__LinearRingType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__LinearRingType **)soap_malloc(soap, sizeof(ns3__LinearRingType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__LinearRingType *)soap_instantiate_ns3__LinearRingType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__LinearRingType ** p = (ns3__LinearRingType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__LinearRingType, sizeof(ns3__LinearRingType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__LinearRingType(struct soap *soap, ns3__LinearRingType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__LinearRingType);
	if (soap_out_PointerTons3__LinearRingType(soap, tag?tag:"ns3:LinearRingType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__LinearRingType ** SOAP_FMAC4 soap_get_PointerTons3__LinearRingType(struct soap *soap, ns3__LinearRingType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__LinearRingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__LineStringType(struct soap *soap, ns3__LineStringType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__LineStringType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__LineStringType(struct soap *soap, const char *tag, int id, ns3__LineStringType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__LineStringType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__LineStringType ** SOAP_FMAC4 soap_in_PointerTons3__LineStringType(struct soap *soap, const char *tag, ns3__LineStringType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__LineStringType **)soap_malloc(soap, sizeof(ns3__LineStringType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__LineStringType *)soap_instantiate_ns3__LineStringType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__LineStringType ** p = (ns3__LineStringType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__LineStringType, sizeof(ns3__LineStringType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__LineStringType(struct soap *soap, ns3__LineStringType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__LineStringType);
	if (soap_out_PointerTons3__LineStringType(soap, tag?tag:"ns3:LineStringType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__LineStringType ** SOAP_FMAC4 soap_get_PointerTons3__LineStringType(struct soap *soap, ns3__LineStringType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__LineStringType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__PointType(struct soap *soap, ns3__PointType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__PointType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__PointType(struct soap *soap, const char *tag, int id, ns3__PointType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__PointType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__PointType ** SOAP_FMAC4 soap_in_PointerTons3__PointType(struct soap *soap, const char *tag, ns3__PointType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__PointType **)soap_malloc(soap, sizeof(ns3__PointType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__PointType *)soap_instantiate_ns3__PointType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__PointType ** p = (ns3__PointType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__PointType, sizeof(ns3__PointType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__PointType(struct soap *soap, ns3__PointType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__PointType);
	if (soap_out_PointerTons3__PointType(soap, tag?tag:"ns3:PointType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__PointType ** SOAP_FMAC4 soap_get_PointerTons3__PointType(struct soap *soap, ns3__PointType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__PointType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ExternalIdType(struct soap *soap, ns2__ExternalIdType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ExternalIdType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ExternalIdType(struct soap *soap, const char *tag, int id, ns2__ExternalIdType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ExternalIdType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ExternalIdType ** SOAP_FMAC4 soap_in_PointerTons2__ExternalIdType(struct soap *soap, const char *tag, ns2__ExternalIdType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ExternalIdType **)soap_malloc(soap, sizeof(ns2__ExternalIdType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ExternalIdType *)soap_instantiate_ns2__ExternalIdType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ExternalIdType ** p = (ns2__ExternalIdType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ExternalIdType, sizeof(ns2__ExternalIdType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ExternalIdType(struct soap *soap, ns2__ExternalIdType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ExternalIdType);
	if (soap_out_PointerTons2__ExternalIdType(soap, tag?tag:"ns2:ExternalIdType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ExternalIdType ** SOAP_FMAC4 soap_get_PointerTons2__ExternalIdType(struct soap *soap, ns2__ExternalIdType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ExternalIdType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UnitType(struct soap *soap, ns2__UnitType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UnitType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UnitType(struct soap *soap, const char *tag, int id, ns2__UnitType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UnitType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__UnitType ** SOAP_FMAC4 soap_in_PointerTons2__UnitType(struct soap *soap, const char *tag, ns2__UnitType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__UnitType **)soap_malloc(soap, sizeof(ns2__UnitType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__UnitType *)soap_instantiate_ns2__UnitType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__UnitType ** p = (ns2__UnitType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UnitType, sizeof(ns2__UnitType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UnitType(struct soap *soap, ns2__UnitType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__UnitType);
	if (soap_out_PointerTons2__UnitType(soap, tag?tag:"ns2:UnitType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__UnitType ** SOAP_FMAC4 soap_get_PointerTons2__UnitType(struct soap *soap, ns2__UnitType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UnitType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContentVersionInfoListType(struct soap *soap, ns2__ContentVersionInfoListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContentVersionInfoListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContentVersionInfoListType(struct soap *soap, const char *tag, int id, ns2__ContentVersionInfoListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContentVersionInfoListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ContentVersionInfoListType ** SOAP_FMAC4 soap_in_PointerTons2__ContentVersionInfoListType(struct soap *soap, const char *tag, ns2__ContentVersionInfoListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ContentVersionInfoListType **)soap_malloc(soap, sizeof(ns2__ContentVersionInfoListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ContentVersionInfoListType *)soap_instantiate_ns2__ContentVersionInfoListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ContentVersionInfoListType ** p = (ns2__ContentVersionInfoListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContentVersionInfoListType, sizeof(ns2__ContentVersionInfoListType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContentVersionInfoListType(struct soap *soap, ns2__ContentVersionInfoListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContentVersionInfoListType);
	if (soap_out_PointerTons2__ContentVersionInfoListType(soap, tag?tag:"ns2:ContentVersionInfoListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ContentVersionInfoListType ** SOAP_FMAC4 soap_get_PointerTons2__ContentVersionInfoListType(struct soap *soap, ns2__ContentVersionInfoListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContentVersionInfoListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns2__union_AbstractContentReferenceListType(struct soap *soap, __ns2__union_AbstractContentReferenceListType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns2__union_AbstractContentReferenceListType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns2__union_AbstractContentReferenceListType(struct soap *soap, const char *tag, int id, __ns2__union_AbstractContentReferenceListType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns2__union_AbstractContentReferenceListType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns2__union_AbstractContentReferenceListType ** SOAP_FMAC4 soap_in_PointerTo__ns2__union_AbstractContentReferenceListType(struct soap *soap, const char *tag, __ns2__union_AbstractContentReferenceListType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns2__union_AbstractContentReferenceListType **)soap_malloc(soap, sizeof(__ns2__union_AbstractContentReferenceListType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns2__union_AbstractContentReferenceListType *)soap_instantiate___ns2__union_AbstractContentReferenceListType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns2__union_AbstractContentReferenceListType ** p = (__ns2__union_AbstractContentReferenceListType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns2__union_AbstractContentReferenceListType, sizeof(__ns2__union_AbstractContentReferenceListType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns2__union_AbstractContentReferenceListType(struct soap *soap, __ns2__union_AbstractContentReferenceListType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns2__union_AbstractContentReferenceListType);
	if (soap_out_PointerTo__ns2__union_AbstractContentReferenceListType(soap, tag?tag:"-ns2:union-AbstractContentReferenceListType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns2__union_AbstractContentReferenceListType ** SOAP_FMAC4 soap_get_PointerTo__ns2__union_AbstractContentReferenceListType(struct soap *soap, __ns2__union_AbstractContentReferenceListType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns2__union_AbstractContentReferenceListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContentVersionInfoType(struct soap *soap, ns2__ContentVersionInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContentVersionInfoType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContentVersionInfoType(struct soap *soap, const char *tag, int id, ns2__ContentVersionInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContentVersionInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ContentVersionInfoType ** SOAP_FMAC4 soap_in_PointerTons2__ContentVersionInfoType(struct soap *soap, const char *tag, ns2__ContentVersionInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ContentVersionInfoType **)soap_malloc(soap, sizeof(ns2__ContentVersionInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ContentVersionInfoType *)soap_instantiate_ns2__ContentVersionInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ContentVersionInfoType ** p = (ns2__ContentVersionInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContentVersionInfoType, sizeof(ns2__ContentVersionInfoType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContentVersionInfoType(struct soap *soap, ns2__ContentVersionInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContentVersionInfoType);
	if (soap_out_PointerTons2__ContentVersionInfoType(soap, tag?tag:"ns2:ContentVersionInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ContentVersionInfoType ** SOAP_FMAC4 soap_get_PointerTons2__ContentVersionInfoType(struct soap *soap, ns2__ContentVersionInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContentVersionInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UserInfoType(struct soap *soap, ns2__UserInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UserInfoType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UserInfoType(struct soap *soap, const char *tag, int id, ns2__UserInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UserInfoType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__UserInfoType ** SOAP_FMAC4 soap_in_PointerTons2__UserInfoType(struct soap *soap, const char *tag, ns2__UserInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__UserInfoType **)soap_malloc(soap, sizeof(ns2__UserInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__UserInfoType *)soap_instantiate_ns2__UserInfoType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__UserInfoType ** p = (ns2__UserInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UserInfoType, sizeof(ns2__UserInfoType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UserInfoType(struct soap *soap, ns2__UserInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__UserInfoType);
	if (soap_out_PointerTons2__UserInfoType(soap, tag?tag:"ns2:UserInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__UserInfoType ** SOAP_FMAC4 soap_get_PointerTons2__UserInfoType(struct soap *soap, ns2__UserInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UserInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContentAssociationModelType(struct soap *soap, ns2__ContentAssociationModelType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContentAssociationModelType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContentAssociationModelType(struct soap *soap, const char *tag, int id, ns2__ContentAssociationModelType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContentAssociationModelType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ContentAssociationModelType ** SOAP_FMAC4 soap_in_PointerTons2__ContentAssociationModelType(struct soap *soap, const char *tag, ns2__ContentAssociationModelType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ContentAssociationModelType **)soap_malloc(soap, sizeof(ns2__ContentAssociationModelType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ContentAssociationModelType *)soap_instantiate_ns2__ContentAssociationModelType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ContentAssociationModelType ** p = (ns2__ContentAssociationModelType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContentAssociationModelType, sizeof(ns2__ContentAssociationModelType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContentAssociationModelType(struct soap *soap, ns2__ContentAssociationModelType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContentAssociationModelType);
	if (soap_out_PointerTons2__ContentAssociationModelType(soap, tag?tag:"ns2:ContentAssociationModelType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ContentAssociationModelType ** SOAP_FMAC4 soap_get_PointerTons2__ContentAssociationModelType(struct soap *soap, ns2__ContentAssociationModelType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContentAssociationModelType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NMTOKEN(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__NMTOKEN))
		soap_serialize_xsd__NMTOKEN(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NMTOKEN(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__NMTOKEN);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NMTOKEN(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NMTOKEN(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NMTOKEN(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NMTOKEN, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NMTOKEN(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__NMTOKEN);
	if (soap_out_PointerToxsd__NMTOKEN(soap, tag?tag:"xsd:NMTOKEN", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NMTOKEN(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NMTOKEN(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContentAssociationModelMemberType(struct soap *soap, ns2__ContentAssociationModelMemberType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContentAssociationModelMemberType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContentAssociationModelMemberType(struct soap *soap, const char *tag, int id, ns2__ContentAssociationModelMemberType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContentAssociationModelMemberType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ContentAssociationModelMemberType ** SOAP_FMAC4 soap_in_PointerTons2__ContentAssociationModelMemberType(struct soap *soap, const char *tag, ns2__ContentAssociationModelMemberType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ContentAssociationModelMemberType **)soap_malloc(soap, sizeof(ns2__ContentAssociationModelMemberType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ContentAssociationModelMemberType *)soap_instantiate_ns2__ContentAssociationModelMemberType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ContentAssociationModelMemberType ** p = (ns2__ContentAssociationModelMemberType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContentAssociationModelMemberType, sizeof(ns2__ContentAssociationModelMemberType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContentAssociationModelMemberType(struct soap *soap, ns2__ContentAssociationModelMemberType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContentAssociationModelMemberType);
	if (soap_out_PointerTons2__ContentAssociationModelMemberType(soap, tag?tag:"ns2:ContentAssociationModelMemberType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ContentAssociationModelMemberType ** SOAP_FMAC4 soap_get_PointerTons2__ContentAssociationModelMemberType(struct soap *soap, ns2__ContentAssociationModelMemberType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContentAssociationModelMemberType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger))
		soap_serialize_xsd__nonNegativeInteger(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__nonNegativeInteger);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__nonNegativeInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__nonNegativeInteger);
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__ns2__union_GetResponseType(struct soap *soap, __ns2__union_GetResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___ns2__union_GetResponseType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__ns2__union_GetResponseType(struct soap *soap, const char *tag, int id, __ns2__union_GetResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___ns2__union_GetResponseType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __ns2__union_GetResponseType ** SOAP_FMAC4 soap_in_PointerTo__ns2__union_GetResponseType(struct soap *soap, const char *tag, __ns2__union_GetResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__ns2__union_GetResponseType **)soap_malloc(soap, sizeof(__ns2__union_GetResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__ns2__union_GetResponseType *)soap_instantiate___ns2__union_GetResponseType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__ns2__union_GetResponseType ** p = (__ns2__union_GetResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___ns2__union_GetResponseType, sizeof(__ns2__union_GetResponseType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__ns2__union_GetResponseType(struct soap *soap, __ns2__union_GetResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__ns2__union_GetResponseType);
	if (soap_out_PointerTo__ns2__union_GetResponseType(soap, tag?tag:"-ns2:union-GetResponseType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __ns2__union_GetResponseType ** SOAP_FMAC4 soap_get_PointerTo__ns2__union_GetResponseType(struct soap *soap, __ns2__union_GetResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__ns2__union_GetResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContentIdentifierReferenceType(struct soap *soap, ns2__ContentIdentifierReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContentIdentifierReferenceType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContentIdentifierReferenceType(struct soap *soap, const char *tag, int id, ns2__ContentIdentifierReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContentIdentifierReferenceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ContentIdentifierReferenceType ** SOAP_FMAC4 soap_in_PointerTons2__ContentIdentifierReferenceType(struct soap *soap, const char *tag, ns2__ContentIdentifierReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ContentIdentifierReferenceType **)soap_malloc(soap, sizeof(ns2__ContentIdentifierReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ContentIdentifierReferenceType *)soap_instantiate_ns2__ContentIdentifierReferenceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ContentIdentifierReferenceType ** p = (ns2__ContentIdentifierReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContentIdentifierReferenceType, sizeof(ns2__ContentIdentifierReferenceType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContentIdentifierReferenceType(struct soap *soap, ns2__ContentIdentifierReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContentIdentifierReferenceType);
	if (soap_out_PointerTons2__ContentIdentifierReferenceType(soap, tag?tag:"ns2:ContentIdentifierReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ContentIdentifierReferenceType ** SOAP_FMAC4 soap_get_PointerTons2__ContentIdentifierReferenceType(struct soap *soap, ns2__ContentIdentifierReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContentIdentifierReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DeletedType(struct soap *soap, ns2__DeletedType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DeletedType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DeletedType(struct soap *soap, const char *tag, int id, ns2__DeletedType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DeletedType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DeletedType ** SOAP_FMAC4 soap_in_PointerTons2__DeletedType(struct soap *soap, const char *tag, ns2__DeletedType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DeletedType **)soap_malloc(soap, sizeof(ns2__DeletedType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DeletedType *)soap_instantiate_ns2__DeletedType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DeletedType ** p = (ns2__DeletedType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DeletedType, sizeof(ns2__DeletedType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DeletedType(struct soap *soap, ns2__DeletedType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DeletedType);
	if (soap_out_PointerTons2__DeletedType(soap, tag?tag:"ns2:DeletedType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DeletedType ** SOAP_FMAC4 soap_get_PointerTons2__DeletedType(struct soap *soap, ns2__DeletedType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DeletedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ForumPostType(struct soap *soap, ns2__ForumPostType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ForumPostType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ForumPostType(struct soap *soap, const char *tag, int id, ns2__ForumPostType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ForumPostType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ForumPostType ** SOAP_FMAC4 soap_in_PointerTons2__ForumPostType(struct soap *soap, const char *tag, ns2__ForumPostType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ForumPostType **)soap_malloc(soap, sizeof(ns2__ForumPostType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ForumPostType *)soap_instantiate_ns2__ForumPostType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ForumPostType ** p = (ns2__ForumPostType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ForumPostType, sizeof(ns2__ForumPostType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ForumPostType(struct soap *soap, ns2__ForumPostType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ForumPostType);
	if (soap_out_PointerTons2__ForumPostType(soap, tag?tag:"ns2:ForumPostType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ForumPostType ** SOAP_FMAC4 soap_get_PointerTons2__ForumPostType(struct soap *soap, ns2__ForumPostType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ForumPostType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ForumTopicType(struct soap *soap, ns2__ForumTopicType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ForumTopicType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ForumTopicType(struct soap *soap, const char *tag, int id, ns2__ForumTopicType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ForumTopicType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ForumTopicType ** SOAP_FMAC4 soap_in_PointerTons2__ForumTopicType(struct soap *soap, const char *tag, ns2__ForumTopicType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ForumTopicType **)soap_malloc(soap, sizeof(ns2__ForumTopicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ForumTopicType *)soap_instantiate_ns2__ForumTopicType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ForumTopicType ** p = (ns2__ForumTopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ForumTopicType, sizeof(ns2__ForumTopicType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ForumTopicType(struct soap *soap, ns2__ForumTopicType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ForumTopicType);
	if (soap_out_PointerTons2__ForumTopicType(soap, tag?tag:"ns2:ForumTopicType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ForumTopicType ** SOAP_FMAC4 soap_get_PointerTons2__ForumTopicType(struct soap *soap, ns2__ForumTopicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ForumTopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SpecialCollectionType(struct soap *soap, ns2__SpecialCollectionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SpecialCollectionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SpecialCollectionType(struct soap *soap, const char *tag, int id, ns2__SpecialCollectionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SpecialCollectionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SpecialCollectionType ** SOAP_FMAC4 soap_in_PointerTons2__SpecialCollectionType(struct soap *soap, const char *tag, ns2__SpecialCollectionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SpecialCollectionType **)soap_malloc(soap, sizeof(ns2__SpecialCollectionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SpecialCollectionType *)soap_instantiate_ns2__SpecialCollectionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SpecialCollectionType ** p = (ns2__SpecialCollectionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SpecialCollectionType, sizeof(ns2__SpecialCollectionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SpecialCollectionType(struct soap *soap, ns2__SpecialCollectionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SpecialCollectionType);
	if (soap_out_PointerTons2__SpecialCollectionType(soap, tag?tag:"ns2:SpecialCollectionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SpecialCollectionType ** SOAP_FMAC4 soap_get_PointerTons2__SpecialCollectionType(struct soap *soap, ns2__SpecialCollectionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SpecialCollectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CollectionType(struct soap *soap, ns2__CollectionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CollectionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CollectionType(struct soap *soap, const char *tag, int id, ns2__CollectionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CollectionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CollectionType ** SOAP_FMAC4 soap_in_PointerTons2__CollectionType(struct soap *soap, const char *tag, ns2__CollectionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CollectionType **)soap_malloc(soap, sizeof(ns2__CollectionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CollectionType *)soap_instantiate_ns2__CollectionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CollectionType ** p = (ns2__CollectionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CollectionType, sizeof(ns2__CollectionType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__CollectionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SpecialCollectionType, sizeof(ns2__SpecialCollectionType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CollectionType(struct soap *soap, ns2__CollectionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CollectionType);
	if (soap_out_PointerTons2__CollectionType(soap, tag?tag:"ns2:CollectionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CollectionType ** SOAP_FMAC4 soap_get_PointerTons2__CollectionType(struct soap *soap, ns2__CollectionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CollectionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SpecialReportType(struct soap *soap, ns2__SpecialReportType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SpecialReportType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SpecialReportType(struct soap *soap, const char *tag, int id, ns2__SpecialReportType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SpecialReportType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SpecialReportType ** SOAP_FMAC4 soap_in_PointerTons2__SpecialReportType(struct soap *soap, const char *tag, ns2__SpecialReportType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SpecialReportType **)soap_malloc(soap, sizeof(ns2__SpecialReportType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SpecialReportType *)soap_instantiate_ns2__SpecialReportType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SpecialReportType ** p = (ns2__SpecialReportType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SpecialReportType, sizeof(ns2__SpecialReportType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SpecialReportType(struct soap *soap, ns2__SpecialReportType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SpecialReportType);
	if (soap_out_PointerTons2__SpecialReportType(soap, tag?tag:"ns2:SpecialReportType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SpecialReportType ** SOAP_FMAC4 soap_get_PointerTons2__SpecialReportType(struct soap *soap, ns2__SpecialReportType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SpecialReportType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReportType(struct soap *soap, ns2__ReportType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ReportType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReportType(struct soap *soap, const char *tag, int id, ns2__ReportType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReportType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ReportType ** SOAP_FMAC4 soap_in_PointerTons2__ReportType(struct soap *soap, const char *tag, ns2__ReportType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ReportType **)soap_malloc(soap, sizeof(ns2__ReportType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ReportType *)soap_instantiate_ns2__ReportType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ReportType ** p = (ns2__ReportType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReportType, sizeof(ns2__ReportType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__ReportType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SpecialReportType, sizeof(ns2__SpecialReportType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReportType(struct soap *soap, ns2__ReportType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ReportType);
	if (soap_out_PointerTons2__ReportType(soap, tag?tag:"ns2:ReportType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ReportType ** SOAP_FMAC4 soap_get_PointerTons2__ReportType(struct soap *soap, ns2__ReportType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReportType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SpecialPlaceType(struct soap *soap, ns2__SpecialPlaceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SpecialPlaceType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SpecialPlaceType(struct soap *soap, const char *tag, int id, ns2__SpecialPlaceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SpecialPlaceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SpecialPlaceType ** SOAP_FMAC4 soap_in_PointerTons2__SpecialPlaceType(struct soap *soap, const char *tag, ns2__SpecialPlaceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SpecialPlaceType **)soap_malloc(soap, sizeof(ns2__SpecialPlaceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SpecialPlaceType *)soap_instantiate_ns2__SpecialPlaceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SpecialPlaceType ** p = (ns2__SpecialPlaceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SpecialPlaceType, sizeof(ns2__SpecialPlaceType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SpecialPlaceType(struct soap *soap, ns2__SpecialPlaceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SpecialPlaceType);
	if (soap_out_PointerTons2__SpecialPlaceType(soap, tag?tag:"ns2:SpecialPlaceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SpecialPlaceType ** SOAP_FMAC4 soap_get_PointerTons2__SpecialPlaceType(struct soap *soap, ns2__SpecialPlaceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SpecialPlaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PlaceType(struct soap *soap, ns2__PlaceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PlaceType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PlaceType(struct soap *soap, const char *tag, int id, ns2__PlaceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PlaceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PlaceType ** SOAP_FMAC4 soap_in_PointerTons2__PlaceType(struct soap *soap, const char *tag, ns2__PlaceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PlaceType **)soap_malloc(soap, sizeof(ns2__PlaceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PlaceType *)soap_instantiate_ns2__PlaceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__PlaceType ** p = (ns2__PlaceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PlaceType, sizeof(ns2__PlaceType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__PlaceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SpecialPlaceType, sizeof(ns2__SpecialPlaceType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PlaceType(struct soap *soap, ns2__PlaceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PlaceType);
	if (soap_out_PointerTons2__PlaceType(soap, tag?tag:"ns2:PlaceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PlaceType ** SOAP_FMAC4 soap_get_PointerTons2__PlaceType(struct soap *soap, ns2__PlaceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PlaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EventType(struct soap *soap, ns2__EventType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EventType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EventType(struct soap *soap, const char *tag, int id, ns2__EventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EventType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__EventType ** SOAP_FMAC4 soap_in_PointerTons2__EventType(struct soap *soap, const char *tag, ns2__EventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EventType **)soap_malloc(soap, sizeof(ns2__EventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EventType *)soap_instantiate_ns2__EventType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__EventType ** p = (ns2__EventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EventType, sizeof(ns2__EventType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EventType(struct soap *soap, ns2__EventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EventType);
	if (soap_out_PointerTons2__EventType(soap, tag?tag:"ns2:EventType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EventType ** SOAP_FMAC4 soap_get_PointerTons2__EventType(struct soap *soap, ns2__EventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ImageType(struct soap *soap, ns2__ImageType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ImageType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ImageType(struct soap *soap, const char *tag, int id, ns2__ImageType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ImageType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ImageType ** SOAP_FMAC4 soap_in_PointerTons2__ImageType(struct soap *soap, const char *tag, ns2__ImageType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ImageType **)soap_malloc(soap, sizeof(ns2__ImageType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ImageType *)soap_instantiate_ns2__ImageType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ImageType ** p = (ns2__ImageType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ImageType, sizeof(ns2__ImageType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ImageType(struct soap *soap, ns2__ImageType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ImageType);
	if (soap_out_PointerTons2__ImageType(soap, tag?tag:"ns2:ImageType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ImageType ** SOAP_FMAC4 soap_get_PointerTons2__ImageType(struct soap *soap, ns2__ImageType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ImageType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MediaType(struct soap *soap, ns2__MediaType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MediaType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MediaType(struct soap *soap, const char *tag, int id, ns2__MediaType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MediaType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MediaType ** SOAP_FMAC4 soap_in_PointerTons2__MediaType(struct soap *soap, const char *tag, ns2__MediaType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MediaType **)soap_malloc(soap, sizeof(ns2__MediaType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MediaType *)soap_instantiate_ns2__MediaType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MediaType ** p = (ns2__MediaType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MediaType, sizeof(ns2__MediaType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__MediaType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ImageType, sizeof(ns2__ImageType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MediaType(struct soap *soap, ns2__MediaType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MediaType);
	if (soap_out_PointerTons2__MediaType(soap, tag?tag:"ns2:MediaType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MediaType ** SOAP_FMAC4 soap_get_PointerTons2__MediaType(struct soap *soap, ns2__MediaType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MediaType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AnnotationType(struct soap *soap, ns2__AnnotationType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AnnotationType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AnnotationType(struct soap *soap, const char *tag, int id, ns2__AnnotationType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AnnotationType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AnnotationType ** SOAP_FMAC4 soap_in_PointerTons2__AnnotationType(struct soap *soap, const char *tag, ns2__AnnotationType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AnnotationType **)soap_malloc(soap, sizeof(ns2__AnnotationType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AnnotationType *)soap_instantiate_ns2__AnnotationType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AnnotationType ** p = (ns2__AnnotationType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AnnotationType, sizeof(ns2__AnnotationType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AnnotationType(struct soap *soap, ns2__AnnotationType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AnnotationType);
	if (soap_out_PointerTons2__AnnotationType(soap, tag?tag:"ns2:AnnotationType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AnnotationType ** SOAP_FMAC4 soap_get_PointerTons2__AnnotationType(struct soap *soap, ns2__AnnotationType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AnnotationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__FaultTo);
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag?tag:"wsa5:FaultTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__ReplyTo);
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag?tag:"wsa5:ReplyTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__From);
	if (soap_out_PointerTo_wsa5__From(soap, tag?tag:"wsa5:From", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__RelatesTo);
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag?tag:"wsa5:RelatesTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__ProblemHeaderQName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__wsa5__ProblemHeaderQName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__wsa5__ProblemHeaderQName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__wsa5__ProblemHeaderQName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemHeaderQName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa5__ProblemHeaderQName);
	if (soap_out__wsa5__ProblemHeaderQName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__wsa5__ProblemHeaderQName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__ProblemHeaderQName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__MetadataType);
	if (soap_out_PointerTowsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__ReferenceParametersType);
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Security);
	if (soap_out_PointerTo_wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureType);
	if (soap_out_PointerTods__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__BinarySecurityToken);
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__UsernameToken);
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsu__Timestamp);
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509IssuerSerialType);
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RSAKeyValueType);
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DSAKeyValueType);
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformType);
	if (soap_out_PointerTods__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DigestMethodType);
	if (soap_out_PointerTods__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformsType);
	if (soap_out_PointerTods__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTods__ReferenceType, sizeof(struct ds__ReferenceType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTods__ReferenceType);
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__ReferenceType);
	if (soap_out_PointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureMethodType);
	if (soap_out_PointerTods__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__CanonicalizationMethodType);
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__SecurityTokenReference);
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509DataType);
	if (soap_out_PointerTods__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RetrievalMethodType);
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyValueType);
	if (soap_out_PointerTods__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces);
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyInfoType);
	if (soap_out_PointerTods__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignedInfoType);
	if (soap_out_PointerTods__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Embedded);
	if (soap_out_PointerTo_wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__KeyIdentifier);
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Reference);
	if (soap_out_PointerTo_wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Password);
	if (soap_out_PointerTo_wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__MediaFileUrlType(struct soap *soap, std::vector<ns2__MediaFileUrlType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__MediaFileUrlType(struct soap *soap, const std::vector<ns2__MediaFileUrlType * >*a)
{
	for (std::vector<ns2__MediaFileUrlType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__MediaFileUrlType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__MediaFileUrlType(struct soap *soap, const char *tag, int id, const std::vector<ns2__MediaFileUrlType * >*a, const char *type)
{
	for (std::vector<ns2__MediaFileUrlType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__MediaFileUrlType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__MediaFileUrlType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__MediaFileUrlType(struct soap *soap, const char *tag, std::vector<ns2__MediaFileUrlType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__MediaFileUrlType(soap, -1)))
		return NULL;
	ns2__MediaFileUrlType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__MediaFileUrlType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MediaFileUrlType, sizeof(ns2__MediaFileUrlType), 1))
				break;
			if (!soap_in_PointerTons2__MediaFileUrlType(soap, tag, NULL, "ns2:MediaFileUrlType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__MediaFileUrlType(soap, tag, &n, "ns2:MediaFileUrlType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__MediaFileUrlType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__MediaFileUrlType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__MediaFileUrlType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MediaFileUrlType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MediaFileUrlType * >);
		if (size)
			*size = sizeof(std::vector<ns2__MediaFileUrlType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__MediaFileUrlType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__MediaFileUrlType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__MediaFileUrlType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__MediaFileUrlType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__MediaFileUrlType * > %p -> %p\n", q, p));
	*(std::vector<ns2__MediaFileUrlType * >*)p = *(std::vector<ns2__MediaFileUrlType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns2__MinistryType(struct soap *soap, std::vector<enum ns2__MinistryType >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns2__MinistryType(struct soap *soap, const std::vector<enum ns2__MinistryType >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns2__MinistryType(struct soap *soap, const char *tag, int id, const std::vector<enum ns2__MinistryType >*a, const char *type)
{
	for (std::vector<enum ns2__MinistryType >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns2__MinistryType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns2__MinistryType >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns2__MinistryType(struct soap *soap, const char *tag, std::vector<enum ns2__MinistryType >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfns2__MinistryType(soap, -1)))
		return NULL;
	enum ns2__MinistryType n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_ns2__MinistryType(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__MinistryType, SOAP_TYPE_std__vectorTemplateOfns2__MinistryType, sizeof(enum ns2__MinistryType), 0))
				break;
			if (!soap_in_ns2__MinistryType(soap, tag, NULL, "ns2:MinistryType"))
				break;
		}
		else
		{
			if (!soap_in_ns2__MinistryType(soap, tag, &n, "ns2:MinistryType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns2__MinistryType > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns2__MinistryType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns2__MinistryType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns2__MinistryType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns2__MinistryType >);
		if (size)
			*size = sizeof(std::vector<enum ns2__MinistryType >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns2__MinistryType >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum ns2__MinistryType >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ns2__MinistryType >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns2__MinistryType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ns2__MinistryType > %p -> %p\n", q, p));
	*(std::vector<enum ns2__MinistryType >*)p = *(std::vector<enum ns2__MinistryType >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns2__KeywordType(struct soap *soap, std::vector<enum ns2__KeywordType >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns2__KeywordType(struct soap *soap, const std::vector<enum ns2__KeywordType >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns2__KeywordType(struct soap *soap, const char *tag, int id, const std::vector<enum ns2__KeywordType >*a, const char *type)
{
	for (std::vector<enum ns2__KeywordType >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns2__KeywordType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns2__KeywordType >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns2__KeywordType(struct soap *soap, const char *tag, std::vector<enum ns2__KeywordType >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfns2__KeywordType(soap, -1)))
		return NULL;
	enum ns2__KeywordType n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_ns2__KeywordType(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__KeywordType, SOAP_TYPE_std__vectorTemplateOfns2__KeywordType, sizeof(enum ns2__KeywordType), 0))
				break;
			if (!soap_in_ns2__KeywordType(soap, tag, NULL, "ns2:KeywordType"))
				break;
		}
		else
		{
			if (!soap_in_ns2__KeywordType(soap, tag, &n, "ns2:KeywordType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns2__KeywordType > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns2__KeywordType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns2__KeywordType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns2__KeywordType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns2__KeywordType >);
		if (size)
			*size = sizeof(std::vector<enum ns2__KeywordType >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns2__KeywordType >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum ns2__KeywordType >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ns2__KeywordType >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns2__KeywordType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ns2__KeywordType > %p -> %p\n", q, p));
	*(std::vector<enum ns2__KeywordType >*)p = *(std::vector<enum ns2__KeywordType >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns2__AnalyticalToolMethodType(struct soap *soap, std::vector<enum ns2__AnalyticalToolMethodType >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns2__AnalyticalToolMethodType(struct soap *soap, const std::vector<enum ns2__AnalyticalToolMethodType >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns2__AnalyticalToolMethodType(struct soap *soap, const char *tag, int id, const std::vector<enum ns2__AnalyticalToolMethodType >*a, const char *type)
{
	for (std::vector<enum ns2__AnalyticalToolMethodType >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns2__AnalyticalToolMethodType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns2__AnalyticalToolMethodType >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns2__AnalyticalToolMethodType(struct soap *soap, const char *tag, std::vector<enum ns2__AnalyticalToolMethodType >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfns2__AnalyticalToolMethodType(soap, -1)))
		return NULL;
	enum ns2__AnalyticalToolMethodType n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_ns2__AnalyticalToolMethodType(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__AnalyticalToolMethodType, SOAP_TYPE_std__vectorTemplateOfns2__AnalyticalToolMethodType, sizeof(enum ns2__AnalyticalToolMethodType), 0))
				break;
			if (!soap_in_ns2__AnalyticalToolMethodType(soap, tag, NULL, "ns2:AnalyticalToolMethodType"))
				break;
		}
		else
		{
			if (!soap_in_ns2__AnalyticalToolMethodType(soap, tag, &n, "ns2:AnalyticalToolMethodType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns2__AnalyticalToolMethodType > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns2__AnalyticalToolMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns2__AnalyticalToolMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns2__AnalyticalToolMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns2__AnalyticalToolMethodType >);
		if (size)
			*size = sizeof(std::vector<enum ns2__AnalyticalToolMethodType >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns2__AnalyticalToolMethodType >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum ns2__AnalyticalToolMethodType >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ns2__AnalyticalToolMethodType >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns2__AnalyticalToolMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ns2__AnalyticalToolMethodType > %p -> %p\n", q, p));
	*(std::vector<enum ns2__AnalyticalToolMethodType >*)p = *(std::vector<enum ns2__AnalyticalToolMethodType >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns2__DataCollectionMethodType(struct soap *soap, std::vector<enum ns2__DataCollectionMethodType >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns2__DataCollectionMethodType(struct soap *soap, const std::vector<enum ns2__DataCollectionMethodType >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns2__DataCollectionMethodType(struct soap *soap, const char *tag, int id, const std::vector<enum ns2__DataCollectionMethodType >*a, const char *type)
{
	for (std::vector<enum ns2__DataCollectionMethodType >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns2__DataCollectionMethodType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns2__DataCollectionMethodType >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns2__DataCollectionMethodType(struct soap *soap, const char *tag, std::vector<enum ns2__DataCollectionMethodType >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfns2__DataCollectionMethodType(soap, -1)))
		return NULL;
	enum ns2__DataCollectionMethodType n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_ns2__DataCollectionMethodType(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__DataCollectionMethodType, SOAP_TYPE_std__vectorTemplateOfns2__DataCollectionMethodType, sizeof(enum ns2__DataCollectionMethodType), 0))
				break;
			if (!soap_in_ns2__DataCollectionMethodType(soap, tag, NULL, "ns2:DataCollectionMethodType"))
				break;
		}
		else
		{
			if (!soap_in_ns2__DataCollectionMethodType(soap, tag, &n, "ns2:DataCollectionMethodType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns2__DataCollectionMethodType > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns2__DataCollectionMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns2__DataCollectionMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns2__DataCollectionMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns2__DataCollectionMethodType >);
		if (size)
			*size = sizeof(std::vector<enum ns2__DataCollectionMethodType >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns2__DataCollectionMethodType >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum ns2__DataCollectionMethodType >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ns2__DataCollectionMethodType >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns2__DataCollectionMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ns2__DataCollectionMethodType > %p -> %p\n", q, p));
	*(std::vector<enum ns2__DataCollectionMethodType >*)p = *(std::vector<enum ns2__DataCollectionMethodType >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__OtherIDType(struct soap *soap, std::vector<ns2__OtherIDType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__OtherIDType(struct soap *soap, const std::vector<ns2__OtherIDType * >*a)
{
	for (std::vector<ns2__OtherIDType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__OtherIDType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__OtherIDType(struct soap *soap, const char *tag, int id, const std::vector<ns2__OtherIDType * >*a, const char *type)
{
	for (std::vector<ns2__OtherIDType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__OtherIDType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__OtherIDType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__OtherIDType(struct soap *soap, const char *tag, std::vector<ns2__OtherIDType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__OtherIDType(soap, -1)))
		return NULL;
	ns2__OtherIDType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__OtherIDType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__OtherIDType, sizeof(ns2__OtherIDType), 1))
				break;
			if (!soap_in_PointerTons2__OtherIDType(soap, tag, NULL, "ns2:OtherIDType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__OtherIDType(soap, tag, &n, "ns2:OtherIDType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__OtherIDType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__OtherIDType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__OtherIDType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__OtherIDType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__OtherIDType * >);
		if (size)
			*size = sizeof(std::vector<ns2__OtherIDType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__OtherIDType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__OtherIDType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__OtherIDType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__OtherIDType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__OtherIDType * > %p -> %p\n", q, p));
	*(std::vector<ns2__OtherIDType * >*)p = *(std::vector<ns2__OtherIDType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__RemarkType(struct soap *soap, std::vector<ns2__RemarkType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__RemarkType(struct soap *soap, const std::vector<ns2__RemarkType * >*a)
{
	for (std::vector<ns2__RemarkType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__RemarkType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__RemarkType(struct soap *soap, const char *tag, int id, const std::vector<ns2__RemarkType * >*a, const char *type)
{
	for (std::vector<ns2__RemarkType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__RemarkType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__RemarkType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__RemarkType(struct soap *soap, const char *tag, std::vector<ns2__RemarkType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__RemarkType(soap, -1)))
		return NULL;
	ns2__RemarkType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__RemarkType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__RemarkType, sizeof(ns2__RemarkType), 1))
				break;
			if (!soap_in_PointerTons2__RemarkType(soap, tag, NULL, "ns2:RemarkType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__RemarkType(soap, tag, &n, "ns2:RemarkType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__RemarkType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__RemarkType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__RemarkType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__RemarkType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__RemarkType * >);
		if (size)
			*size = sizeof(std::vector<ns2__RemarkType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__RemarkType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__RemarkType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__RemarkType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__RemarkType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__RemarkType * > %p -> %p\n", q, p));
	*(std::vector<ns2__RemarkType * >*)p = *(std::vector<ns2__RemarkType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__LocationInfoType(struct soap *soap, std::vector<ns2__LocationInfoType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__LocationInfoType(struct soap *soap, const std::vector<ns2__LocationInfoType * >*a)
{
	for (std::vector<ns2__LocationInfoType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__LocationInfoType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__LocationInfoType(struct soap *soap, const char *tag, int id, const std::vector<ns2__LocationInfoType * >*a, const char *type)
{
	for (std::vector<ns2__LocationInfoType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__LocationInfoType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__LocationInfoType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__LocationInfoType(struct soap *soap, const char *tag, std::vector<ns2__LocationInfoType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__LocationInfoType(soap, -1)))
		return NULL;
	ns2__LocationInfoType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__LocationInfoType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__LocationInfoType, sizeof(ns2__LocationInfoType), 1))
				break;
			if (!soap_in_PointerTons2__LocationInfoType(soap, tag, NULL, "ns2:LocationInfoType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__LocationInfoType(soap, tag, &n, "ns2:LocationInfoType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__LocationInfoType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__LocationInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__LocationInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__LocationInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__LocationInfoType * >);
		if (size)
			*size = sizeof(std::vector<ns2__LocationInfoType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__LocationInfoType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__LocationInfoType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__LocationInfoType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__LocationInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__LocationInfoType * > %p -> %p\n", q, p));
	*(std::vector<ns2__LocationInfoType * >*)p = *(std::vector<ns2__LocationInfoType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(struct soap *soap, std::vector<ns2__FamilyMemberInfoType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(struct soap *soap, const std::vector<ns2__FamilyMemberInfoType * >*a)
{
	for (std::vector<ns2__FamilyMemberInfoType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__FamilyMemberInfoType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(struct soap *soap, const char *tag, int id, const std::vector<ns2__FamilyMemberInfoType * >*a, const char *type)
{
	for (std::vector<ns2__FamilyMemberInfoType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__FamilyMemberInfoType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__FamilyMemberInfoType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(struct soap *soap, const char *tag, std::vector<ns2__FamilyMemberInfoType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(soap, -1)))
		return NULL;
	ns2__FamilyMemberInfoType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__FamilyMemberInfoType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType, sizeof(ns2__FamilyMemberInfoType), 1))
				break;
			if (!soap_in_PointerTons2__FamilyMemberInfoType(soap, tag, NULL, "ns2:FamilyMemberInfoType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__FamilyMemberInfoType(soap, tag, &n, "ns2:FamilyMemberInfoType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__FamilyMemberInfoType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__FamilyMemberInfoType * >);
		if (size)
			*size = sizeof(std::vector<ns2__FamilyMemberInfoType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__FamilyMemberInfoType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__FamilyMemberInfoType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__FamilyMemberInfoType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__FamilyMemberInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__FamilyMemberInfoType * > %p -> %p\n", q, p));
	*(std::vector<ns2__FamilyMemberInfoType * >*)p = *(std::vector<ns2__FamilyMemberInfoType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__VehicleInfoType(struct soap *soap, std::vector<ns2__VehicleInfoType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__VehicleInfoType(struct soap *soap, const std::vector<ns2__VehicleInfoType * >*a)
{
	for (std::vector<ns2__VehicleInfoType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__VehicleInfoType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__VehicleInfoType(struct soap *soap, const char *tag, int id, const std::vector<ns2__VehicleInfoType * >*a, const char *type)
{
	for (std::vector<ns2__VehicleInfoType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__VehicleInfoType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__VehicleInfoType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__VehicleInfoType(struct soap *soap, const char *tag, std::vector<ns2__VehicleInfoType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__VehicleInfoType(soap, -1)))
		return NULL;
	ns2__VehicleInfoType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__VehicleInfoType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__VehicleInfoType, sizeof(ns2__VehicleInfoType), 1))
				break;
			if (!soap_in_PointerTons2__VehicleInfoType(soap, tag, NULL, "ns2:VehicleInfoType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__VehicleInfoType(soap, tag, &n, "ns2:VehicleInfoType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__VehicleInfoType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__VehicleInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__VehicleInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__VehicleInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__VehicleInfoType * >);
		if (size)
			*size = sizeof(std::vector<ns2__VehicleInfoType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__VehicleInfoType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__VehicleInfoType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__VehicleInfoType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__VehicleInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__VehicleInfoType * > %p -> %p\n", q, p));
	*(std::vector<ns2__VehicleInfoType * >*)p = *(std::vector<ns2__VehicleInfoType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns2__RoleType(struct soap *soap, std::vector<enum ns2__RoleType >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns2__RoleType(struct soap *soap, const std::vector<enum ns2__RoleType >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns2__RoleType(struct soap *soap, const char *tag, int id, const std::vector<enum ns2__RoleType >*a, const char *type)
{
	for (std::vector<enum ns2__RoleType >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns2__RoleType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns2__RoleType >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns2__RoleType(struct soap *soap, const char *tag, std::vector<enum ns2__RoleType >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfns2__RoleType(soap, -1)))
		return NULL;
	enum ns2__RoleType n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_ns2__RoleType(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__RoleType, SOAP_TYPE_std__vectorTemplateOfns2__RoleType, sizeof(enum ns2__RoleType), 0))
				break;
			if (!soap_in_ns2__RoleType(soap, tag, NULL, "ns2:RoleType"))
				break;
		}
		else
		{
			if (!soap_in_ns2__RoleType(soap, tag, &n, "ns2:RoleType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns2__RoleType > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns2__RoleType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns2__RoleType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns2__RoleType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns2__RoleType >);
		if (size)
			*size = sizeof(std::vector<enum ns2__RoleType >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns2__RoleType >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum ns2__RoleType >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ns2__RoleType >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns2__RoleType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ns2__RoleType > %p -> %p\n", q, p));
	*(std::vector<enum ns2__RoleType >*)p = *(std::vector<enum ns2__RoleType >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__DescriptionType(struct soap *soap, std::vector<ns2__DescriptionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__DescriptionType(struct soap *soap, const std::vector<ns2__DescriptionType * >*a)
{
	for (std::vector<ns2__DescriptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__DescriptionType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__DescriptionType(struct soap *soap, const char *tag, int id, const std::vector<ns2__DescriptionType * >*a, const char *type)
{
	for (std::vector<ns2__DescriptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__DescriptionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__DescriptionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__DescriptionType(struct soap *soap, const char *tag, std::vector<ns2__DescriptionType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__DescriptionType(soap, -1)))
		return NULL;
	ns2__DescriptionType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__DescriptionType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__DescriptionType, sizeof(ns2__DescriptionType), 1))
				break;
			if (!soap_in_PointerTons2__DescriptionType(soap, tag, NULL, "ns2:DescriptionType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__DescriptionType(soap, tag, &n, "ns2:DescriptionType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__DescriptionType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__DescriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__DescriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__DescriptionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__DescriptionType * >);
		if (size)
			*size = sizeof(std::vector<ns2__DescriptionType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__DescriptionType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__DescriptionType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__DescriptionType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__DescriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__DescriptionType * > %p -> %p\n", q, p));
	*(std::vector<ns2__DescriptionType * >*)p = *(std::vector<ns2__DescriptionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(struct soap *soap, std::vector<ns2__ContentVersionInfoType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(struct soap *soap, const std::vector<ns2__ContentVersionInfoType * >*a)
{
	for (std::vector<ns2__ContentVersionInfoType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ContentVersionInfoType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(struct soap *soap, const char *tag, int id, const std::vector<ns2__ContentVersionInfoType * >*a, const char *type)
{
	for (std::vector<ns2__ContentVersionInfoType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ContentVersionInfoType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ContentVersionInfoType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(struct soap *soap, const char *tag, std::vector<ns2__ContentVersionInfoType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(soap, -1)))
		return NULL;
	ns2__ContentVersionInfoType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ContentVersionInfoType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ContentVersionInfoType, sizeof(ns2__ContentVersionInfoType), 1))
				break;
			if (!soap_in_PointerTons2__ContentVersionInfoType(soap, tag, NULL, "ns2:ContentVersionInfoType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__ContentVersionInfoType(soap, tag, &n, "ns2:ContentVersionInfoType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ContentVersionInfoType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ContentVersionInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ContentVersionInfoType * >);
		if (size)
			*size = sizeof(std::vector<ns2__ContentVersionInfoType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ContentVersionInfoType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__ContentVersionInfoType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__ContentVersionInfoType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ContentVersionInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ContentVersionInfoType * > %p -> %p\n", q, p));
	*(std::vector<ns2__ContentVersionInfoType * >*)p = *(std::vector<ns2__ContentVersionInfoType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(struct soap *soap, std::vector<ns2__ContentAssociationModelType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(struct soap *soap, const std::vector<ns2__ContentAssociationModelType * >*a)
{
	for (std::vector<ns2__ContentAssociationModelType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__ContentAssociationModelType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(struct soap *soap, const char *tag, int id, const std::vector<ns2__ContentAssociationModelType * >*a, const char *type)
{
	for (std::vector<ns2__ContentAssociationModelType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__ContentAssociationModelType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__ContentAssociationModelType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(struct soap *soap, const char *tag, std::vector<ns2__ContentAssociationModelType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(soap, -1)))
		return NULL;
	ns2__ContentAssociationModelType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__ContentAssociationModelType, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ContentAssociationModelType, sizeof(ns2__ContentAssociationModelType), 1))
				break;
			if (!soap_in_PointerTons2__ContentAssociationModelType(soap, tag, NULL, "ns2:ContentAssociationModelType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__ContentAssociationModelType(soap, tag, &n, "ns2:ContentAssociationModelType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__ContentAssociationModelType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__ContentAssociationModelType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ContentAssociationModelType * >);
		if (size)
			*size = sizeof(std::vector<ns2__ContentAssociationModelType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__ContentAssociationModelType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__ContentAssociationModelType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__ContentAssociationModelType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__ContentAssociationModelType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__ContentAssociationModelType * > %p -> %p\n", q, p));
	*(std::vector<ns2__ContentAssociationModelType * >*)p = *(std::vector<ns2__ContentAssociationModelType * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
