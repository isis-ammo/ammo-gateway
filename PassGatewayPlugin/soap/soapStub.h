/* soapStub.h
   Generated by gSOAP 2.7.17 from ../pass.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_pass	"http://peoc3t.us.army.mil/PASS"
#define SOAP_NAMESPACE_OF_xlink	"http://www.w3.org/1999/xlink"
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE__xlink__show
#define SOAP_TYPE__xlink__show (35)
/* xlink:show */
enum _xlink__show {_xlink__show__new_ = 0, _xlink__show__replace = 1, _xlink__show__embed = 2, _xlink__show__other = 3, _xlink__show__none = 4};
#endif

#ifndef SOAP_TYPE__xlink__actuate
#define SOAP_TYPE__xlink__actuate (36)
/* xlink:actuate */
enum _xlink__actuate {_xlink__actuate__onLoad = 0, _xlink__actuate__onRequest = 1, _xlink__actuate__other = 2, _xlink__actuate__none = 3};
#endif

#ifndef SOAP_TYPE__pass__status_command
#define SOAP_TYPE__pass__status_command (37)
/* pass:status-command */
enum _pass__status_command {_pass__status_command__create_USCOREtopic = 0, _pass__status_command__sync = 1, _pass__status_command__publish = 2, _pass__status_command__subscribe = 3, _pass__status_command__unsubscribe = 4, _pass__status_command__retract_USCOREtopic = 5, _pass__status_command__retract_USCOREitem = 6, _pass__status_command__unknown = 7};
#endif

#ifndef SOAP_TYPE__pass__status_status_USCOREcode
#define SOAP_TYPE__pass__status_status_USCOREcode (39)
/* pass:status-status_code */
enum _pass__status_status_USCOREcode {_pass__status_status_USCOREcode__1000 = 1000, _pass__status_status_USCOREcode__1100 = 1100, _pass__status_status_USCOREcode__1101 = 1101, _pass__status_status_USCOREcode__1102 = 1102, _pass__status_status_USCOREcode__1103 = 1103, _pass__status_status_USCOREcode__1104 = 1104, _pass__status_status_USCOREcode__1105 = 1105, _pass__status_status_USCOREcode__1106 = 1106, _pass__status_status_USCOREcode__1107 = 1107, _pass__status_status_USCOREcode__1108 = 1108, _pass__status_status_USCOREcode__1109 = 1109, _pass__status_status_USCOREcode__1110 = 1110, _pass__status_status_USCOREcode__1111 = 1111, _pass__status_status_USCOREcode__1200 = 1200, _pass__status_status_USCOREcode__1201 = 1201, _pass__status_status_USCOREcode__1202 = 1202};
#endif

#ifndef SOAP_TYPE__pass__item_USCOREdata_item_USCOREdata_USCOREclassification
#define SOAP_TYPE__pass__item_USCOREdata_item_USCOREdata_USCOREclassification (46)
/* pass:item_data-item_data_classification */
enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification {_pass__item_USCOREdata_item_USCOREdata_USCOREclassification__SECRET = 0, _pass__item_USCOREdata_item_USCOREdata_USCOREclassification__CONFIDENTIAL = 1, _pass__item_USCOREdata_item_USCOREdata_USCOREclassification__UNCLASSIFIED = 2};
#endif

#ifndef SOAP_TYPE__pass__create_USCOREtopic_publish_USCOREmode
#define SOAP_TYPE__pass__create_USCOREtopic_publish_USCOREmode (66)
/* pass:create_topic-publish_mode */
enum _pass__create_USCOREtopic_publish_USCOREmode {_pass__create_USCOREtopic_publish_USCOREmode__locked = 0, _pass__create_USCOREtopic_publish_USCOREmode__open = 1};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (9)
typedef struct soap_dom_element xsd__anyType;
#endif
#ifndef SOAP_TYPE_xsd__anyAttribute
#define SOAP_TYPE_xsd__anyAttribute (11)
typedef struct soap_dom_attribute xsd__anyAttribute;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif





#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_pass__status
#define SOAP_TYPE_pass__status (18)
/* pass:status */
class SOAP_CMAC pass__status
{
public:
	enum _pass__status_command command;	/* required attribute */
	std::string topic;	/* required attribute */
	std::string *item_USCOREid;	/* optional attribute */
	std::string *subscription_USCOREid;	/* optional attribute */
	std::string *status_USCOREphrase;	/* optional attribute */
	enum _pass__status_status_USCOREcode status_USCOREcode;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_pass__status */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         pass__status(): item_USCOREid(NULL), subscription_USCOREid(NULL), status_USCOREphrase(NULL), soap(NULL) { pass__status::soap_default(NULL); }
	virtual ~pass__status() { }
};
#endif

#ifndef SOAP_TYPE_pass__pass_USCOREfault
#define SOAP_TYPE_pass__pass_USCOREfault (19)
/* pass:pass_fault */
class SOAP_CMAC pass__pass_USCOREfault
{
public:
	pass__status *status;	/* required element of type pass:status */
	std::string *error_USCOREdetails;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_pass__pass_USCOREfault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         pass__pass_USCOREfault(): status(NULL), error_USCOREdetails(NULL), soap(NULL) { pass__pass_USCOREfault::soap_default(NULL); }
	virtual ~pass__pass_USCOREfault() { }
};
#endif

#ifndef SOAP_TYPE_pass__item
#define SOAP_TYPE_pass__item (20)
/* pass:item */
class SOAP_CMAC pass__item
{
public:
	class _pass__AOI_USCORErectangle *AOI_USCORErectangle;	/* optional element of type pass:AOI_rectangle */
	std::string *description;	/* optional element of type xsd:string */
	class pass__item_USCOREdata *item_USCOREdata;	/* required element of type pass:item_data */
	time_t item_USCOREdtg;	/* required attribute */
	std::string item_USCORETTL_USCOREsecs;	/* optional attribute */
	std::string item_USCOREid;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_pass__item */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         pass__item(): AOI_USCORErectangle(NULL), description(NULL), item_USCOREdata(NULL), soap(NULL) { pass__item::soap_default(NULL); }
	virtual ~pass__item() { }
};
#endif

#ifndef SOAP_TYPE_pass__item_USCOREdata
#define SOAP_TYPE_pass__item_USCOREdata (21)
/* pass:item_data */
class SOAP_CMAC pass__item_USCOREdata
{
public:
	class _pass__References *References;	/* optional element of type pass:References */
	struct soap_dom_element __any;	/* external */
	enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification item_USCOREdata_USCOREclassification;	/* required attribute */
	std::string *control_USCOREmark;	/* optional attribute */
	std::string *release_USCOREmark;	/* optional attribute */
	std::string *declass_USCOREexemption_USCOREcode;	/* optional attribute */
	time_t *declass_USCOREdateTime;	/* optional attribute */
	std::string *item_USCOREdata_USCOREcategory;	/* optional attribute */
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_pass__item_USCOREdata */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         pass__item_USCOREdata(): References(NULL), control_USCOREmark(NULL), release_USCOREmark(NULL), declass_USCOREexemption_USCOREcode(NULL), declass_USCOREdateTime(NULL), item_USCOREdata_USCOREcategory(NULL), soap(NULL) { pass__item_USCOREdata::soap_default(NULL); }
	virtual ~pass__item_USCOREdata() { }
};
#endif

#ifndef SOAP_TYPE__pass__AOI_USCORErectangle
#define SOAP_TYPE__pass__AOI_USCORErectangle (22)
/* pass:AOI_rectangle */
class SOAP_CMAC _pass__AOI_USCORErectangle
{
public:
	std::string aoi_USCOREn_USCORElat;	/* required attribute */
	std::string aoi_USCOREw_USCORElong;	/* required attribute */
	std::string aoi_USCOREs_USCORElat;	/* required attribute */
	std::string aoi_USCOREe_USCORElong;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE__pass__AOI_USCORErectangle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _pass__AOI_USCORErectangle(): soap(NULL) { _pass__AOI_USCORErectangle::soap_default(NULL); }
	virtual ~_pass__AOI_USCORErectangle() { }
};
#endif

#ifndef SOAP_TYPE__pass__References_ReferenceObj
#define SOAP_TYPE__pass__References_ReferenceObj (48)
/* pass:References-ReferenceObj */
class SOAP_CMAC _pass__References_ReferenceObj
{
public:
	std::string *xlink__type;	/* optional attribute */
	std::string *xlink__href;	/* optional attribute */
	std::string *xlink__role;	/* optional attribute */
	std::string *xlink__arcrole;	/* optional attribute */
	std::string *xlink__title;	/* optional attribute */
	enum _xlink__show *xlink__show;	/* optional attribute */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute */
	struct soap_dom_element __mixed;	/* external */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE__pass__References_ReferenceObj */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _pass__References_ReferenceObj(): xlink__type(NULL), xlink__href(NULL), xlink__role(NULL), xlink__arcrole(NULL), xlink__title(NULL), xlink__show(NULL), xlink__actuate(NULL) { _pass__References_ReferenceObj::soap_default(NULL); }
	virtual ~_pass__References_ReferenceObj() { }
};
#endif

#ifndef SOAP_TYPE__pass__References
#define SOAP_TYPE__pass__References (23)
/* pass:References */
class SOAP_CMAC _pass__References
{
public:
	int __sizeReferenceObj;	/* sequence of elements <ReferenceObj> */
	_pass__References_ReferenceObj *ReferenceObj;	/* required element of type pass:References-ReferenceObj */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE__pass__References */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _pass__References(): ReferenceObj(NULL), soap(NULL) { _pass__References::soap_default(NULL); }
	virtual ~_pass__References() { }
};
#endif

#ifndef SOAP_TYPE__pass__publish
#define SOAP_TYPE__pass__publish (24)
/* pass:publish */
class SOAP_CMAC _pass__publish
{
public:
	std::vector<pass__item * >item;	/* required element of type pass:item */
	std::string topic;	/* required attribute */
	std::string *subscription_USCOREid;	/* optional attribute */
	std::string publisher_USCOREid;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE__pass__publish */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _pass__publish(): subscription_USCOREid(NULL), soap(NULL) { _pass__publish::soap_default(NULL); }
	virtual ~_pass__publish() { }
};
#endif

#ifndef SOAP_TYPE__pass__retract_USCOREitem
#define SOAP_TYPE__pass__retract_USCOREitem (25)
/* pass:retract_item */
class SOAP_CMAC _pass__retract_USCOREitem
{
public:
	std::string publisher_USCOREid;	/* required attribute */
	std::string item_USCOREid;	/* required attribute */
	std::string topic;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE__pass__retract_USCOREitem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _pass__retract_USCOREitem(): soap(NULL) { _pass__retract_USCOREitem::soap_default(NULL); }
	virtual ~_pass__retract_USCOREitem() { }
};
#endif

#ifndef SOAP_TYPE__pass__retract_USCOREtopic
#define SOAP_TYPE__pass__retract_USCOREtopic (26)
/* pass:retract_topic */
class SOAP_CMAC _pass__retract_USCOREtopic
{
public:
	std::string owner_USCOREid;	/* required attribute */
	std::string topic;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE__pass__retract_USCOREtopic */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _pass__retract_USCOREtopic(): soap(NULL) { _pass__retract_USCOREtopic::soap_default(NULL); }
	virtual ~_pass__retract_USCOREtopic() { }
};
#endif

#ifndef SOAP_TYPE__pass__unsubscribe
#define SOAP_TYPE__pass__unsubscribe (27)
/* pass:unsubscribe */
class SOAP_CMAC _pass__unsubscribe
{
public:
	std::string subscriber_USCOREid;	/* required attribute */
	std::string *subscription_USCOREid;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE__pass__unsubscribe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _pass__unsubscribe(): subscription_USCOREid(NULL), soap(NULL) { _pass__unsubscribe::soap_default(NULL); }
	virtual ~_pass__unsubscribe() { }
};
#endif

#ifndef SOAP_TYPE__pass__subscribe
#define SOAP_TYPE__pass__subscribe (28)
/* pass:subscribe */
class SOAP_CMAC _pass__subscribe
{
public:
	std::string return_USCOREaddress;	/* required element of type xsd:anyURI */
	_pass__AOI_USCORErectangle *AOI_USCORErectangle;	/* optional element of type pass:AOI_rectangle */
	std::vector<std::string >item_USCOREid;	/* optional element of type xsd:string */
	std::string *duration_USCOREsecs;	/* optional attribute */
	std::string *subscription_USCOREid;	/* optional attribute */
	std::string topic;	/* required attribute */
	std::string subscriber_USCOREid;	/* required attribute */
	bool compression;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE__pass__subscribe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _pass__subscribe(): AOI_USCORErectangle(NULL), duration_USCOREsecs(NULL), subscription_USCOREid(NULL), soap(NULL) { _pass__subscribe::soap_default(NULL); }
	virtual ~_pass__subscribe() { }
};
#endif

#ifndef SOAP_TYPE__pass__sync
#define SOAP_TYPE__pass__sync (29)
/* pass:sync */
class SOAP_CMAC _pass__sync
{
public:
	_pass__AOI_USCORErectangle *AOI_USCORErectangle;	/* optional element of type pass:AOI_rectangle */
	std::vector<std::string >item_USCOREid;	/* optional element of type xsd:string */
	time_t *since_USCOREdtg;	/* optional attribute */
	std::string topic;	/* required attribute */
	std::string requester_USCOREid;	/* required attribute */
	bool compression;	/* optional attribute */
	std::string *xpath_USCOREfilter;	/* optional attribute */
	bool item_USCOREid_USCOREonly;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE__pass__sync */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _pass__sync(): AOI_USCORErectangle(NULL), since_USCOREdtg(NULL), xpath_USCOREfilter(NULL), soap(NULL) { _pass__sync::soap_default(NULL); }
	virtual ~_pass__sync() { }
};
#endif

#ifndef SOAP_TYPE__pass__union_sync_USCOREresponse
#define SOAP_TYPE__pass__union_sync_USCOREresponse (65)
/* xsd:choice */
union _pass__union_sync_USCOREresponse
{
#define SOAP_UNION__pass__union_sync_USCOREresponse_publish	(1)
	_pass__publish *publish;
#define SOAP_UNION__pass__union_sync_USCOREresponse_create_USCOREtopic	(2)
	std::vector<class _pass__create_USCOREtopic * >*create_USCOREtopic;
#define SOAP_UNION__pass__union_sync_USCOREresponse_subscribe	(3)
	std::vector<_pass__subscribe * >*subscribe;
};
#endif

#ifndef SOAP_TYPE__pass__sync_USCOREresponse
#define SOAP_TYPE__pass__sync_USCOREresponse (30)
/* pass:sync_response */
class SOAP_CMAC _pass__sync_USCOREresponse
{
public:
	pass__status *status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type pass:status */
	int __union_sync_USCOREresponse;	/* union discriminant (of union defined below) */
	union _pass__union_sync_USCOREresponse union_sync_USCOREresponse;	/* required element of type xsd:choice */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE__pass__sync_USCOREresponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _pass__sync_USCOREresponse(): status(NULL), soap(NULL) { _pass__sync_USCOREresponse::soap_default(NULL); }
	virtual ~_pass__sync_USCOREresponse() { }
};
#endif

#ifndef SOAP_TYPE__pass__create_USCOREtopic
#define SOAP_TYPE__pass__create_USCOREtopic (31)
/* pass:create_topic */
class SOAP_CMAC _pass__create_USCOREtopic
{
public:
	std::string *description;	/* optional element of type xsd:string */
	enum _pass__create_USCOREtopic_publish_USCOREmode publish_USCOREmode;	/* optional attribute */
	bool retractable;	/* optional attribute */
	std::string topic;	/* required attribute */
	std::string owner_USCOREid;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE__pass__create_USCOREtopic */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _pass__create_USCOREtopic(): description(NULL), soap(NULL) { _pass__create_USCOREtopic::soap_default(NULL); }
	virtual ~_pass__create_USCOREtopic() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (67)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	struct soap_dom_attribute __anyAttribute;	/* external */	/* optional attribute of type xsd:anyAttribute */
	pass__pass_USCOREfault *pass__pass_USCOREfault_;	/* optional element of type pass:pass_fault */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE___ns1__subscribe
#define SOAP_TYPE___ns1__subscribe (72)
/* Operation wrapper: */
struct __ns1__subscribe
{
public:
	_pass__subscribe *pass__subscribe;	/* optional element of type pass:subscribe */
};
#endif

#ifndef SOAP_TYPE___ns1__retract_USCOREitem
#define SOAP_TYPE___ns1__retract_USCOREitem (75)
/* Operation wrapper: */
struct __ns1__retract_USCOREitem
{
public:
	_pass__retract_USCOREitem *pass__retract_USCOREitem;	/* optional element of type pass:retract_item */
};
#endif

#ifndef SOAP_TYPE___ns1__retract_USCOREtopic
#define SOAP_TYPE___ns1__retract_USCOREtopic (78)
/* Operation wrapper: */
struct __ns1__retract_USCOREtopic
{
public:
	_pass__retract_USCOREtopic *pass__retract_USCOREtopic;	/* optional element of type pass:retract_topic */
};
#endif

#ifndef SOAP_TYPE___ns1__unsubscribe
#define SOAP_TYPE___ns1__unsubscribe (81)
/* Operation wrapper: */
struct __ns1__unsubscribe
{
public:
	_pass__unsubscribe *pass__unsubscribe;	/* optional element of type pass:unsubscribe */
};
#endif

#ifndef SOAP_TYPE___ns1__publish
#define SOAP_TYPE___ns1__publish (83)
/* Operation wrapper: */
struct __ns1__publish
{
public:
	_pass__publish *pass__publish;	/* optional element of type pass:publish */
};
#endif

#ifndef SOAP_TYPE___ns1__create_USCOREtopic
#define SOAP_TYPE___ns1__create_USCOREtopic (85)
/* Operation wrapper: */
struct __ns1__create_USCOREtopic
{
public:
	_pass__create_USCOREtopic *pass__create_USCOREtopic;	/* optional element of type pass:create_topic */
};
#endif

#ifndef SOAP_TYPE___ns1__sync
#define SOAP_TYPE___ns1__sync (89)
/* Operation wrapper: */
struct __ns1__sync
{
public:
	_pass__sync *pass__sync;	/* optional element of type pass:sync */
};
#endif

#ifndef SOAP_TYPE___ns2__publish
#define SOAP_TYPE___ns2__publish (91)
/* Operation wrapper: */
struct __ns2__publish
{
public:
	_pass__publish *pass__publish;	/* optional element of type pass:publish */
};
#endif

#ifndef SOAP_TYPE___ns2__retract_USCOREitem
#define SOAP_TYPE___ns2__retract_USCOREitem (93)
/* Operation wrapper: */
struct __ns2__retract_USCOREitem
{
public:
	_pass__retract_USCOREitem *pass__retract_USCOREitem;	/* optional element of type pass:retract_item */
};
#endif

#ifndef SOAP_TYPE___ns2__retract_USCOREtopic
#define SOAP_TYPE___ns2__retract_USCOREtopic (95)
/* Operation wrapper: */
struct __ns2__retract_USCOREtopic
{
public:
	_pass__retract_USCOREtopic *pass__retract_USCOREtopic;	/* optional element of type pass:retract_topic */
};
#endif

#ifndef SOAP_TYPE___ns2__unsubscribe
#define SOAP_TYPE___ns2__unsubscribe (97)
/* Operation wrapper: */
struct __ns2__unsubscribe
{
public:
	_pass__unsubscribe *pass__unsubscribe;	/* optional element of type pass:unsubscribe */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (98)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (99)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (101)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (102)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (14)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (15)
typedef std::string xsd__decimal;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (16)
typedef std::string xsd__integer;
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (17)
typedef std::string xsd__nonNegativeInteger;
#endif

#ifndef SOAP_TYPE_pass__latitude
#define SOAP_TYPE_pass__latitude (32)
typedef std::string pass__latitude;
#endif

#ifndef SOAP_TYPE_pass__longitude
#define SOAP_TYPE_pass__longitude (33)
typedef std::string pass__longitude;
#endif

#ifndef SOAP_TYPE_pass__item_USCORETTL
#define SOAP_TYPE_pass__item_USCORETTL (34)
typedef std::string pass__item_USCORETTL;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
