<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>The wsse plugin</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="wsse">The wsse plugin </a></h1><h2><a class="anchor" id="wsse_5">
Security Header</a></h2>
<p>The material in this section relates to the WS-Security specification section 5.</p>
<p>To use the wsse plugin:</p>
<ol type="1">
<li>Run wsdl2h -t typemap.dat on a WSDL of a service that requires WS-Security headers. The typemap.dat file is used to recognize and translate Security header blocks.</li>
<li>Run soapcpp2 on the header file produced by wsdl2h.</li>
<li>(Re-)compile stdsoap2.c/pp, dom.c/pp, smdevp.c, wsseapi.c and the generated source files with the -DWITH_DOM and -DWITH_OPENSSL compile flags set. The smdevp.c and wssapi.c files are located in the 'plugin' directory.</li>
<li>Use the wsse plugin API functions described below to add and verify Security headers.</li>
</ol>
<p>An example wsse client/server application can be found in samples/wsse.</p>
<p>The Security header block was generated from the WS-Security schema with the wsdl2h tool and WS/WS-typemap.dat:</p>
<div class="fragment"><pre class="fragment">    &gt; wsdl2h -cegxy -o wsse.h -t WS/WS-typemap.dat WS/wsse.xsd
</pre></div><p>The same process was used to generate the header file ds.h from the XML digital signatures core schema.</p>
<p>The import/wsse.h file has the following definition for the Security header block:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>_wsse__Security
{       <span class="keyword">struct </span>_wsu__Timestamp*                 wsu__Timestamp;
        <span class="keyword">struct </span>_wsse__UsernameToken*            UsernameToken;
        <span class="keyword">struct </span>_wsse__BinarySecurityToken*      BinarySecurityToken;
        <span class="keyword">struct </span>ds__SignatureType*               ds__Signature;
        @<span class="keywordtype">char</span>*                                  SOAP_ENV__actor;
        @<span class="keywordtype">char</span>*                                  SOAP_ENV__role;
} _wsse__Security;
</pre></div><p>To add an empty Security header block to the SOAP header, use:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_Security(soap);
</pre></div><p>To delete a Security header, use:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_delete_Security(soap);
</pre></div><p>Adding an empty Security header block is not very useful. In the following, we present the higher-level functions of the wsse plugin to populate and verify Security header content.</p>
<p>Note: The soap context includes an actor value soap.actor that is populated and rendered as the SOAP-ENV:actor (SOAP 1.1) or SOAP-ENV:role (SOAP 1.2) attribute in XML within the generic SOAP Header. The attribute is optional, but should be used to target a recipient such as an intermediate node to process the SOAP header. In contrast, actor or role attributes within Security header blocks target specific recipients to process the Security header block. The gSOAP implementation does not automate this feature and application should set and check the actor/role attribute when necessary. In addition, the current implementation supports the inclusion of a single Security header block in the SOAP header.</p>
<p>To populate the SOAP-ENV:actor or SOAP-ENV:role attribute within the Security header, use:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_Security_actor(soap, <span class="stringliteral">&quot;recipient&quot;</span>);
</pre></div><p>To obtain the actor or role value (e.g. after receiving a message), use:</p>
<div class="fragment"><pre class="fragment">    _wsse__Security *security = soap_wsse_Security(soap);
    <span class="keywordflow">if</span> (security)
    { ... = security-&gt;SOAP_ENV__actor; <span class="comment">// SOAP 1.1</span>
      ... = security-&gt;SOAP_ENV__role;  <span class="comment">// SOAP 1.2</span>
</pre></div><p>The SOAP-ENV:mustUnderstand attribute is automatically added and checked by the gSOAP engine. A gSOAP application compiled without Security support will reject Security headers.</p>
<p>Security header blocks are attached to the soap context, which means that the information will be automatically kept to support multiple invocations.</p>
<h2><a class="anchor" id="wsse_6">
Security Tokens</a></h2>
<p>The material in this section relates to the WS-Security specification section 6.</p>
<h3><a class="anchor" id="wsse_6_2">
User Name Token</a></h3>
<p>To add a user name token to the Security header block, use:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_UsernameTokenText(soap, <span class="stringliteral">&quot;Id&quot;</span>, <span class="stringliteral">&quot;username&quot;</span>, NULL);
</pre></div><p>The Id value is optional. When non-NULL the user name token is included in the digital signature to protect its integrity. It is common for the wsse plugin functions to accept such Ids, which are serialized as wsu:Id identifiers for cross-referencing XML elements. The signature engine of the wsse plugin is designed to automatically sign all wsu:Id attributed elements to simplify the code you need to write to implement the signing process.</p>
<p>To add a user name token with clear text password, use:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_UsernameTokenText(soap, <span class="stringliteral">&quot;Id&quot;</span>, <span class="stringliteral">&quot;username&quot;</span>, <span class="stringliteral">&quot;password&quot;</span>);
</pre></div><p>It is strongly recommended to use soap_wsse_add_UsernameTokenText only in combination with HTTPS encrypted transmission or not at all. A better alternative is to use password digests. With password digest authentication, the digest value of a password (with message creation time and a random nonce) is compared on both sides, thus eliminating the need to exchange a password over the wire.</p>
<p>To add a user name token with password digest, use:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_UsernameTokenDigest(soap, <span class="stringliteral">&quot;Id&quot;</span>, <span class="stringliteral">&quot;username&quot;</span>, <span class="stringliteral">&quot;password&quot;</span>);
</pre></div><p>Although the password string is passed to this function, it is not rendered in XML or stored in a message log. It has been argued that this approach adopted by the WS-Security protocol is still vulnerable since the application retrieves the password in text form requiring a database to store passwords in clear text. However, a digest algorithm can be used to hash the passwords and store their digests instead, which eliminates the need to store clear-text passwords. Note that this is a common approach adopted by Unix for decades.</p>
<p>By setting the Id value to a unique string, the user name token is also digitally signed by the signature engine further preventing tampering with its value.</p>
<p>You must use soap_wsse_add_UsernameTokenDigest for each message exchange to refresh the password digest even when the user name and password are not changed. Otherwise, the receiver might flag the message as a replay attack.</p>
<p>Clear-text passwords and password digests are verified with soap_wsse_verify_Password. To verify a password at the receiving side to authorize a request (e.g. within a Web service operation), use:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> ns__myMethod(<span class="keyword">struct</span> soap *soap, ...)
    { <span class="keyword">const</span> <span class="keywordtype">char</span> *username = soap_wsse_get_Username(soap);
      <span class="keyword">const</span> <span class="keywordtype">char</span> *password;
      <span class="keywordflow">if</span> (!username)
        <span class="keywordflow">return</span> soap-&gt;error; <span class="comment">// no username: return FailedAuthentication</span>
      password = ...; <span class="comment">// lookup password of username</span>
      <span class="keywordflow">if</span> (soap_wsse_verify_Password(soap, password))
        <span class="keywordflow">return</span> soap-&gt;error; <span class="comment">// password verification failed: return FailedAuthentication</span>
      ... <span class="comment">// process request</span>
      <span class="keywordflow">return</span> SOAP_OK;
    }
</pre></div><p>Note that the soap_wsse_get_Username functions sets the wsse:FailedAuthentication fault. It is common for the wsse plugin functions to return SOAP_OK or a wsse fault that should be passed to the sender by returning soap-&gt;error from service operations. The fault is displayed with the soap_print_fault function.</p>
<p>Password digest authentication prevents message replay attacks. The wsse plugin keeps a database of password digests to thwart replay attacks. This is the only part in the plugin code that requires mutex provided by threads.h. Of course, this only works correctly if the server is persistent, such as a stand-alone service. Note that CGI-based services do not keep state. Machine clocks must be synchronized and clock skew should not exceed SOAP_WSSE_CLKSKEW at the server side.</p>
<h3><a class="anchor" id="wsse_6_3">
Binary Security Tokens</a></h3>
<p>X509 certificates are commonly included in Security header blocks as binary security tokens. A certificate is used to verify the digital signature of a digitally signed message using the public key embedded within the certificate. The certificate itself is signed by a certificate authority (CA) that vouches for the authenticity of the certificate, i.e. to prove the identify of the message originator. This verification process is important, because digital signatures are useless without verification: an attacker could simply replace the message, sign it, and replace the certificate.</p>
<p>Certificates are automatically verified by the wsse plugin signature engine when received and accessed, which means that the certificates of the CAs must be made accessible to the wsse plugin as follows:</p>
<div class="fragment"><pre class="fragment">    soap-&gt;cafile = <span class="stringliteral">&quot;cacerts.pem&quot;</span>;  <span class="comment">// use this</span>
    soap-&gt;capath = <span class="stringliteral">&quot;dir/to/certs&quot;</span>; <span class="comment">// and/or point to CA certs</span>
    soap-&gt;crlfile = <span class="stringliteral">&quot;revoked.pem&quot;</span>; <span class="comment">// use CRL (optional)</span>
</pre></div><p>The soap_wsse_verify_X509 function checks the validity of a certificate. The check is automatically performed. The check is also performed when retrieving the certificate from a Security header block, either automatically by the wsse plugin's signature verification engine or manually as follows:</p>
<div class="fragment"><pre class="fragment">    X509 *cert = soap_wsse_get_BinarySecurityTokenX509(soap, <span class="stringliteral">&quot;Id&quot;</span>);
</pre></div><p>where Id is the identification string of the binary security token or NULL.</p>
<p>The verification is an expensive process that will be optimized in future releases by caching the certificate chain.</p>
<p>To attach a binary security token stored in a PEM file to a Security header block for transmission, use:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_BinarySecurityTokenPEM(soap, NULL, <span class="stringliteral">&quot;mycert.pem&quot;</span>)
</pre></div><p>A binary security token can be automatically signed by setting its Id attribute:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_BinarySecurityTokenPEM(soap, <span class="stringliteral">&quot;X509Token&quot;</span>, <span class="stringliteral">&quot;mycert.pem&quot;</span>)
</pre></div><p>Repeatedly loading a certificate from a PEM file is inefficient. To reuse a certificate loaded from a PEM file for multiple invocations, use:</p>
<div class="fragment"><pre class="fragment">    FILE *fd = fopen(<span class="stringliteral">&quot;mycert.pem&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
    X509 *cert = PEM_read_X509(fd, NULL, NULL, NULL);
    fclose(fd);
    <span class="keywordflow">if</span> (soap_wsse_add_BinarySecurityTokenX509(soap, <span class="stringliteral">&quot;X509Token&quot;</span>, cert))
      ... <span class="comment">// an error occurred</span>
</pre></div><p>Other types of binary security tokens can be added to the Security header block using:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_BinarySecurityToken(soap, <span class="stringliteral">&quot;Id&quot;</span>, <span class="stringliteral">&quot;valueType&quot;</span>, data, datalen);
</pre></div><h2><a class="anchor" id="wsse_6_4">
XML Tokens</a></h2>
<p>The use and processing rules for XML tokens such as SAML assertions is specific to an application. The wsse plugin does not automate the use of XML tokens. The developer is encouraged to generate code for the SAML schema with wsdl2h and add the necessary assertions to the Security header block:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>_wsse__Security
{       <span class="keyword">struct </span>_wsu__Timestamp*                 wsu__Timestamp;
        <span class="keyword">struct </span>_wsse__UsernameToken*            UsernameToken;
        <span class="keyword">struct </span>_wsse__BinarySecurityToken*      BinarySecurityToken;
        <span class="keyword">struct </span>_saml__Assertion*                saml__Assertion; <span class="comment">// added</span>
        <span class="keyword">struct </span>ds__SignatureType*               ds__Signature;
        @<span class="keywordtype">char</span>*                                  SOAP_ENV__actor;
        @<span class="keywordtype">char</span>*                                  SOAP_ENV__role;
} _wsse__Security;
</pre></div><p>Alternatively, a DOM can be used to store and retrieve XML tokens:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#import &quot;dom.h&quot;</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>_wsse__Security
{       <span class="keyword">struct </span>_wsu__Timestamp*                 wsu__Timestamp;
        <span class="keyword">struct </span>_wsse__UsernameToken*            UsernameToken;
        <span class="keyword">struct </span>_wsse__BinarySecurityToken*      BinarySecurityToken;
        <span class="keyword">struct </span>ds__SignatureType*               ds__Signature;
        <span class="keywordtype">int</span>                                     __size;
        xsd__anyType*                           any;
        @<span class="keywordtype">char</span>*                                  SOAP_ENV__actor;
        @<span class="keywordtype">char</span>*                                  SOAP_ENV__role;
} _wsse__Security;
</pre></div><h2><a class="anchor" id="wsse_7">
Token References</a></h2>
<p>The material in this section relates to the WS-Security specification section 7.</p>
<p>To use a certificate for signature verification, add a direct security token reference URI for the token to the KeyInfo, for example:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_KeyInfo_SecurityTokenReferenceURI(soap, <span class="stringliteral">&quot;URI&quot;</span>, <span class="stringliteral">&quot;valueType&quot;</span>);
</pre></div><p>and:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_KeyInfo_SecurityTokenReferenceX509(soap, <span class="stringliteral">&quot;URI&quot;</span>);
</pre></div><p>For X509 certificates we use this to add a binary security token with the certificate and a reference to the local token:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> (soap_wsse_add_BinarySecurityTokenX509(soap, <span class="stringliteral">&quot;X509Token&quot;</span>, cert)
     || soap_wsse_add_KeyInfo_SecurityTokenReferenceX509(soap, <span class="stringliteral">&quot;#X509Token&quot;</span>))
      ... <span class="comment">// an error occurred</span>
</pre></div><p>This follows the recommended practice to place Security token references in the KeyInfo element of a Signature. The KeyInfo is used to verify the validity of a signature value.</p>
<p>Key identifiers can be used as well:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_KeyInfo_SecurityTokenReferenceKeyIdentifier(soap, <span class="stringliteral">&quot;Id&quot;</span>, <span class="stringliteral">&quot;valueType&quot;</span>, data, datalen);
</pre></div><p>Embedded references are added with:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_KeyInfo_SecurityTokenReferenceEmbedded(soap, <span class="stringliteral">&quot;Id&quot;</span>, <span class="stringliteral">&quot;valueType&quot;</span>);
</pre></div><p>Full support for embedded references requires coding to add tokens and assertions, as well as to consume embedded references at the receiving side. There is no automated mechanism to take the embedded references and process them accordingly.</p>
<p>The use of key names is not recommended, but in case they are required they can be added with:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_KeyInfo_KeyName(soap, <span class="stringliteral">&quot;name&quot;</span>);
</pre></div><h2><a class="anchor" id="wsse_8">
Signatures</a></h2>
<p>The material in this section relates to the WS-Security specification section 8.</p>
<p>The wsse plugin must be registered to sign and verify messages:</p>
<div class="fragment"><pre class="fragment">    soap_register_plugin(soap, soap_wsse);
</pre></div><p>XML signatures are usually computed over normalized XML (to ensure the XML processors of intermediate nodes can accurately reproduce the XML). To this end, the exclusive canonical XML standard (exc-c14n) is required, which is set using the SOAP_XML_CANONICAL flag:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>soap *soap = soap_new1(SOAP_XML_CANONICAL);
    soap_register_plugin(soap, soap_wsse);
</pre></div><p>If you prefer XML indentation, use:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>soap *soap = soap_new1(SOAP_XML_CANONICAL | SOAP_XML_INDENT);
    soap_register_plugin(soap, soap_wsse);
</pre></div><p>Currently compression is not supported for outbound message signing and compression is disabled when signed messages are send. However, this may change in future releases.</p>
<p>Next, we decide which signature algorithm is appropriate to use:</p>
<ul>
<li>HMAC-SHA1 uses a secret key (also known as a shared key in symmetric cryptography) to sign the SHA1 digest of the SignedInfo element.</li>
<li>DSA-SHA1 uses a DSA private key to sign the SHA1 digest of the SignedInfo element.</li>
<li>RSA-SHA1 uses a RSA private key to sign the SHA1 digest of the SignedInfo element.</li>
</ul>
<p>HMAC-SHA1 is the simplest method, but relies on the fact that you have to make absolutely sure the key is kept secret on both the sending and receiving side. As long as the secret key is confidential, messages are securely signed. However, this is virtually impossible when exchanging messages with untrusted disparate parties. The advantage of HMAC-SHA1 is the speed by which messages are signed and verified.</p>
<p>DSA-SHA1 and RSA-SHA1 rely on public key cryptography. In simplified terms, a message is signed using the (confidential!) private key. The public key is used to verify the signature. Since only the originating party could have used its private key to sign the message, the integrity of the message is guaranteed. Of course, we must trust the public key came from the originator (it is often included as an X509 certificate in the message). To this end, a trusted certificate authority should have signed the public key, thereby creating a X509 certificate that contains the public key and the identity of the message originator.</p>
<p>An optional callback function can be passed to the plugin that is responsible for providing a certificate to the wsse engine to verify a signed message. For example, when a security token is absent from an DSA-SHA1 or RSA-SHA1 signed message then the only mechanism to automatically verify the signature is to let the callback produce a certificate:</p>
<div class="fragment"><pre class="fragment">    soap_register_plugin_arg(soap, soap_wsse, security_token_handler);

    <span class="keyword">const</span> <span class="keywordtype">void</span> *security_token_handler(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">int</span> alg, <span class="keywordtype">int</span> *keylen)
    { <span class="comment">// Get the user name from UsernameToken in message</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *uid = soap_wsse_get_Username(soap);
      <span class="keywordflow">switch</span> (alg)
      { <span class="keywordflow">case</span> SOAP_SMD_VRFY_DSA_SHA1:
        <span class="keywordflow">case</span> SOAP_SMD_VRFY_RSA_SHA1:
          <span class="keywordflow">if</span> (uid)
          { <span class="comment">// Lookup uid to retrieve the X509 certificate to verify the signature</span>
            <span class="keyword">const</span> X509 *cert = ...; 
            <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">void</span>*)cert;
          }
          <span class="keywordflow">return</span> NULL; <span class="comment">// no certificate: fail</span>
        <span class="keywordflow">case</span> SOAP_SMD_HMAC_SHA1:
          <span class="keywordflow">if</span> (uid)
          { <span class="comment">// Lookup uid to retrieve the HMAC key to verify the signature</span>
            <span class="keyword">const</span> <span class="keywordtype">void</span> *key = ...; 
            *keylen = ...;
            <span class="keywordflow">return</span> key;
          }
          <span class="keywordflow">return</span> NULL; <span class="comment">// no certificate: fail</span>
        <span class="keywordflow">default</span>:
          <span class="keywordflow">return</span> NULL; <span class="comment">// fail</span>
      }
    }
</pre></div><h3><a class="anchor" id="wsse_8_2a">
Signing Messages</a></h3>
<p>After the plugin is registered and a signature algorithm selected, the soap_wsse_sign function or the soap_wsse_sign_body function is used to initiate the signature engine to automatically sign outbound messages.</p>
<p>The code to sign the SOAP Body of a message using HMAC-SHA1 is:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">static</span> <span class="keywordtype">char</span> hmac_key[16] =
    { 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
      0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00 };
    <span class="keyword">struct </span>soap *soap = soap_new1(SOAP_XML_CANONICAL | SOAP_XML_INDENT);
    soap_register_plugin(soap, soap_wsse);
    <span class="keywordflow">if</span> (soap_wsse_sign_body(soap, SOAP_SMD_HMAC_SHA1, hmac_key, <span class="keyword">sizeof</span>(hmac_key))
      ... <span class="comment">// an error occurred</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (soap_call_ns__myMethod(soap, ...))
      ... <span class="comment">// a transmission error occurred</span>
</pre></div><p>The hmac_key is some secret key you generated for the sending side and receiving side (don't use the one shown here).</p>
<p>As always, use soap_print_fault to display the error message.</p>
<p>To sign the body of an outbound SOAP message using RSA-SHA1 (DSA-SHA1 is similar), we include the X509 certificate with the public key as a BinarySecurityToken in the header and a KeyInfo reference to the token to let receivers use the public key in the certificate to verify the authenticity of the message:</p>
<div class="fragment"><pre class="fragment">    FILE *fd;
    EVP_PKEY *rsa_private_key;
    X509 *cert;
    <span class="keyword">struct </span>soap *soap = soap_new1(SOAP_XML_CANONICAL | SOAP_XML_INDENT);
    soap_register_plugin(soap, soap_wsse);
    fd = fopen(<span class="stringliteral">&quot;privkey.pem&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
    rsa_private_key = PEM_read_PrivateKey(fd, NULL, NULL, <span class="stringliteral">&quot;password&quot;</span>);
    fclose(fd);
    fd = fopen(<span class="stringliteral">&quot;cert.pem&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
    X509 *cert = PEM_read_X509(fd, NULL, NULL, NULL);
    fclose(fd);
    <span class="keywordflow">if</span> (soap_wsse_add_BinarySecurityTokenX509(soap, <span class="stringliteral">&quot;X509Token&quot;</span>, cert)
     || soap_wsse_add_KeyInfo_SecurityTokenReferenceX509(soap, <span class="stringliteral">&quot;#X509Token&quot;</span>)
     || soap_wsse_sign_body(soap, SOAP_SMD_SIGN_RSA_SHA1, rsa_private_key, 0))
      ... <span class="comment">// an error occurred</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (soap_call_ns__myMethod(soap, ...))
      ... <span class="comment">// a transmission error occurred</span>
</pre></div><p>The private key and its certificate are often placed in the same file, see e.g. server.pem in the package.</p>
<p>To summarize the signing process:</p>
<ol type="1">
<li>Register the wsse plugin.</li>
<li>Obtain an HMAC secret key or a DSA or RSA private key.</li>
<li>For DSA or RSA, obtain the X509 certificate with the public key signed by a certificate authority.</li>
<li>Add the X509 certificate as a BinarySecurityToken to the header.</li>
<li>Add a KeyInfo BinarySecurityTokenReference.</li>
<li>Invoke soap_wsse_sign or soap_wsse_sign_body to sign the message.</li>
<li>Always check the function return values for errors. You don't want to produce and accept messages with an invalid Security headers.</li>
</ol>
<h3><a class="anchor" id="wsse_8_2b">
Signing Message Parts</a></h3>
<p>The soap_wsse_sign_body function signs the entire SOAP body. If it is desirable to sign individual parts of a message the soap_wsse_sign function should be used. Message parts with wsu:Id attributes are signed. These message parts should not be nested (nested elements will not be separately signed). All and only those XML elements with wsu:Id attributes are signed. The wsu:Id attribute values used in a message must be unique within the message.</p>
<p>For example, consider a transaction in which we only want to sign a contract in the SOAP Body. This allows us to modify the rest of the message or extract the contract in XML and pass it on with the signature.</p>
<p>The gSOAP header file includes a myContract declaration:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>ns__myContract
    { @<span class="keywordtype">char</span>* wsu__Id = <span class="stringliteral">&quot;Contract&quot;</span>;
      <span class="keywordtype">char</span>* name;
      <span class="keywordtype">char</span>* title;
      <span class="keywordtype">char</span>* terms;
    };
    <span class="keywordtype">int</span> ns__myMethod(<span class="keyword">struct</span> ns__myContract agreement, <span class="keywordtype">bool</span>* accepted);
</pre></div><p>The default value of the wsu:Id is "Contract" so that we can instantiate the struct, automatically sign it, and send it as follows:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>ns__myContract contract;
    <span class="keywordtype">bool</span> accept;
    soap_default_ns__myContract(soap, &amp;contract);
    contract.name = ...;
    contract.title = ...;
    contract.terms = ...;
    <span class="keywordflow">if</span> (soap_wsse_add_BinarySecurityTokenX509(soap, <span class="stringliteral">&quot;X509Token&quot;</span>, cert)
     || soap_wsse_add_KeyInfo_SecurityTokenReferenceX509(soap, <span class="stringliteral">&quot;#X509Token&quot;</span>)
     || soap_wsse_sign(soap, SOAP_SMD_SIGN_RSA_SHA1, rsa_private_key, 0))
      ... <span class="comment">// an error occurred</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (soap_call_ns__myMethod(soap, contract, &amp;accept))
      ... <span class="comment">// a transmission error occurred</span>
</pre></div><p>The above example shows a wsu:Id attribute embedded (hardcoded) in a struct. When it is not possible to add the wsu__Id member, for example when the type is a string instead of a struct, it is suggested to specify the XML element to be signed with the soap_wsse_set_wsu_id(soap, "space-separated string of element
names") function, to be used before each call or when returning from a service operation. This lets the engine add wsu:Id="tag" attribute-value pair to the element's tag name. For example:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_set_wsu_id(soap, <span class="stringliteral">&quot;ns:myContract&quot;</span>); <span class="comment">// &lt;ns:myContract wsu:Id=&quot;ns:myContract&quot;&gt;...</span>
    <span class="keywordflow">if</span> (soap_wsse_add_BinarySecurityTokenX509(soap, <span class="stringliteral">&quot;X509Token&quot;</span>, cert)
     || soap_wsse_add_KeyInfo_SecurityTokenReferenceX509(soap, <span class="stringliteral">&quot;#X509Token&quot;</span>)
     || soap_wsse_sign(soap, SOAP_SMD_SIGN_RSA_SHA1, rsa_private_key, 0))
      ... <span class="comment">// an error occurred</span>
    soap_wsse_set_wsu_id(soap, NULL);
</pre></div><p> This adds the wsu:Id="ns-myContract" to the ns:myContract element. Here, the wsu__Id value in the struct MUST NOT be set. Otherwise, two wsu:Id attributes are present which is invalid. Also, the element signed must be unique in the message. That is, there cannot be more than one matching element, otherwise the resulting signature is invalid.</p>
<p>We recommend to sign the entire SOAP Body using soap_wsse_sign_body and reserve the use of soap_wsse_set_wsu_id for SOAP Header elements, such as WS-Addressing elements. For example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &quot;wsaapi.h&quot;</span>
    ...
    soap_wsa_request(soap, RequestMessageID, ToAddress, RequestAction);
    soap_wsse_set_wsu_id(soap, <span class="stringliteral">&quot;wsa5:To wsa5:From wsa5:ReplyTo wsa5:Action&quot;</span>);
    <span class="keywordflow">if</span> (soap_wsse_add_BinarySecurityTokenX509(soap, <span class="stringliteral">&quot;X509Token&quot;</span>, cert)
     || soap_wsse_add_KeyInfo_SecurityTokenReferenceX509(soap, <span class="stringliteral">&quot;#X509Token&quot;</span>)
     || soap_wsse_sign_body(soap, SOAP_SMD_SIGN_RSA_SHA1, rsa_private_key, 0))
      ... <span class="comment">// an error occurred</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (soap_call_ns__myMethod(soap, ...))
      ... <span class="comment">// a transmission error occurred</span>
    soap_wsse_set_wsu_id(soap, NULL);
</pre></div><p> This signs the wsa5:To and wsa5:Action SOAP header elements (set with soap_wsa_request, see the WS-Addressing "wsa" API in the gSOAP documentation for more information on the use of WS-Addressing). It is fine to specify more elements than present in the XML payload. The other WS-Addressing headers are not present and are not signed.</p>
<p>Note: soap_wsse_set_wsu_id() should only be set once. Each new call overrides the previous.</p>
<p>Note: to reset the automatic wsu:Id attributes addition, pass NULL to soap_wsse_set_wsu_id().</p>
<p>Note: never use soap_wsse_set_wsu_id() to set the wsu:Id for an element that occur more than once in the payload, since each will have the same wsu:Id attribute that may lead to a WS-Signature failure.</p>
<h3><a class="anchor" id="wsse_8_3">
Signing Tokens</a></h3>
<p>To sign security tokens such as user names, passwords, and binary security tokens, just assign their Id values with a unique string, such as "Time" for timestamps and "User" for user names. For example:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_Timestamp(soap, <span class="stringliteral">&quot;Time&quot;</span>, 600);
    soap_wsse_add_UsernameTokenDigest(soap, <span class="stringliteral">&quot;User&quot;</span>, <span class="stringliteral">&quot;username&quot;</span>, <span class="stringliteral">&quot;password&quot;</span>);
    ... <span class="comment">// the rest of the signing code</span>
</pre></div><h3><a class="anchor" id="wsse_8_4">
Signature Validation</a></h3>
<p>To automatically verify the signature of an inbound message signed with DSA or RSA algorithms, assuming the message contains the X509 certificate as a binary security token, use:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>soap *soap = soap_new1(SOAP_XML_CANONICAL | SOAP_XML_INDENT);
    soap_register_plugin(soap, soap_wsse);
    soap_wsse_verify_auto(soap, SOAP_SMD_NONE, NULL, 0);

    <span class="comment">// server:</span>
    <span class="keywordflow">if</span> (soap_serve(soap))
      ... <span class="comment">// an error occurred</span>

    <span class="comment">// client:</span>
    <span class="keywordflow">if</span> (soap_call_ns__myMethod(soap, ...))
      ... <span class="comment">// an error occurred</span>
</pre></div><p>All locally referenced and signed elements in the signed message will be verified. Elements that are not signed cannot be verified. Also elements referenced with absolute URIs that are not part of the message are not automatically verified. The received message is stored in a DOM accessible with soap-&gt;dom. This enables further analysis of the message content.</p>
<p>For a post-parsing check to verify if an XML element was signed in an inbound message, use: </p>
<div class="fragment"><pre class="fragment">    soap_wsse_verify_auto(soap, SOAP_SMD_NONE, NULL, 0);
    ... <span class="comment">// client call</span>
    <span class="keywordflow">if</span> (soap_wsse_verify_element(soap, <span class="stringliteral">&quot;namespaceURI&quot;</span>, <span class="stringliteral">&quot;tag&quot;</span>) &gt; 0)
      ... <span class="comment">// at least one element with matching tag and namespace is signed</span>
</pre></div><p> The signed element nesting rules are obeyed, so if the matching element is a descendent of a signed element, it is signed as well.</p>
<p>Because it is a post check, a client should invoke soap_wsse_verify_element after the call completed. A service should invoke this function within the service operation routine, i.e. when the message request is accepted and about to be processed.</p>
<p>For example, to check whether the wsu:Timestamp element was signed (assuming it is present and message expiration checked with soap_wsse_verify_Timestamp), use soap_wsse_verify_element(soap, "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd", "Timestamp").</p>
<p>To check the SOAP Body (either using SOAP 1.1 or 1.2), use the shorthand soap_wsse_verify_body(soap).</p>
<p>The soap_wsse_verify_auto function keeps processing signed (and unsigned) messages as they arrive. For unsigned messages this can be expensive and the verification engine should be shut down using soap_wsse_verify_done.</p>
<p>To verify the HMAC signature of an inbound message, the HMAC key must be supplied:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">static</span> <span class="keywordtype">char</span> hmac_key[16] = <span class="comment">// the same secret key that was used to sign</span>
    { 0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
      0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00 };
    <span class="keyword">struct </span>soap *soap = soap_new1(SOAP_XML_CANONICAL | SOAP_XML_INDENT);
    soap_register_plugin(soap, soap_wsse);
    soap_wsse_verify_auto(soap, SOAP_SMD_HMAC_SHA1, hmac_key, <span class="keyword">sizeof</span>(hmac_key));

    <span class="comment">// server:</span>
    <span class="keywordflow">if</span> (soap_serve(soap))
      ... <span class="comment">// an error occurred</span>

    <span class="comment">// client:</span>
    <span class="keywordflow">if</span> (soap_call_ns__myMethod(soap, ...))
      ... <span class="comment">// an error occurred</span>
</pre></div><p>To summarize the signature verification process:</p>
<ol type="1">
<li>Register the wsse plugin.</li>
<li>For HMAC, obtain the HMAC secret key</li>
<li>Use soap_wsse_verify_auto to verify inbound messages.</li>
<li>After receiving a message, the DOM in soap-&gt;dom can be traversed for further analysis.</li>
<li>Always check the function return values for errors. You don't want to accept a request or response message with an invalid Security header.</li>
<li>Use soap_wsse_verify_done to terminate verification, e.g. to consume plain messages more efficiently.</li>
</ol>
<h2><a class="anchor" id="wsse_9">
Encryption</a></h2>
<p>The material in this section relates to the WS-Security specification section 9.</p>
<p>For encryption support, please contact the toolkit developers.</p>
<h2><a class="anchor" id="wsse_10">
Security Timestamps</a></h2>
<p>The material in this section relates to the WS-Security specification section 10.</p>
<p>To add a timestamp with the creation time to the Security header, use:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_Timestamp(soap, NULL, 0); <span class="comment">// no expiration</span>
</pre></div><p>The lifetime of a message (in seconds) is passed as the third argument, which will be displayed as the timestamp expiration time:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_Timestamp(soap, NULL, 10); <span class="comment">// 10 seconds lifetime</span>
</pre></div><p>Timestamps, like other header elements, are not automatically secured with a digital signature. To secure a timestamp, we add an identifier (wsu:Id) to each element we want the WS-Security plugin to sign thereby making it impossible for someone to tamper with that part of the message. To do this for the timestamp, we simply pass a unique identification string as the second argument:</p>
<div class="fragment"><pre class="fragment">    soap_wsse_add_Timestamp(soap, <span class="stringliteral">&quot;Time&quot;</span>, 10); <span class="comment">// timestamp will be signed</span>
</pre></div> </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Sep 21 16:00:06 2011 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
