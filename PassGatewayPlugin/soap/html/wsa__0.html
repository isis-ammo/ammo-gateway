<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>The wsa plugin for client applications and stand-alone services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="wsa_0">The wsa plugin for client applications and stand-alone services </a></h1><h2><a class="anchor" id="wsa_1">
WS-Addressing Setup</a></h2>
<p>The material in this section relates to the WS-Addressing specification.</p>
<p>To use the wsa plugin:</p>
<ol type="1">
<li>Run wsdl2h -t typemap.dat on a WSDL of a service that requires WS-Addressing headers. The typemap.dat file included in the gSOAP package is used to recognize and translate Addressing header blocks.</li>
<li>Run soapcpp2 -a on the header file produced by wsdl2h. To enable addressing-based service operation selection, you MUST use soapcpp2 option -a. This allows the service to dispatch methods based on the WS-Addressing action information header value (when the wsa plugin is registered).</li>
<li>(Re-)compile and link stdsoap2.c/pp or libgsoap, (dom.c/pp when needed), wsaapi.c and the soapcpp2-generated source files.</li>
<li>Use the wsa plugin API functions described below.</li>
</ol>
<p>An example wsa client/server application can be found in samples/wsa.</p>
<p>A gSOAP service definitions header file with a "wsa import" to support WS-Addressing is automatically generated by wsdl2h for a set of WSDLs that use WS-Addressing. The wsdl2h-generated header file should be further processed by soapcpp2 to generate the binding code. The <a class="el" href="wsaapi_8h_source.html">wsaapi.h</a> and wsaapi.c implement the WS-Addressing API described in this document.</p>
<p>A wsdl2h-generated service definitions header file might include the following imports:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#import &quot;soap12.h&quot;</span>
<span class="preprocessor">#import &quot;wsa.h&quot;</span> <span class="comment">// or wsa3.h (2003/03), wsa4.h (2004/03), wsa5.h (2005/03)</span>
</pre></div><p>The wsa.h header file is imported from import/wsa.h when soapcpp2 is run on this file. The wsa.h import can be manually added to enable WS-Addressing when needed. The gSOAP service definitions header file is processed with soapcpp2 to generate the client-side and/or server-side binding code.</p>
<p>Note that the wsa.h, wsa3.h, wsa4.h, and wsa5.h header files are located in the import directory of the gSOAP package. These files define the WS-Addressing information header elements and types. The soap12.h header file enables SOAP 1.2 messaging.</p>
<p>For developers: the WS-Addressing header blocks in wsa.h (and others) were generated from the WS-Addressing schema with the wsdl2h tool and WS/WS-typemap.dat as follows:</p>
<div class="fragment"><pre class="fragment">    &gt; wsdl2h -cegy -o wsa.h -t WS/WS-typemap.dat WS/WS-Addressing.xsd
</pre></div><p>Refer to wsa.h for more details.</p>
<h2><a class="anchor" id="wsa_2">
Client-side Usage</a></h2>
<h3><a class="anchor" id="wsa_2_1">
Constructing WS-Addressing Information Headers</a></h3>
<p>To associate WS-Addressing information headers with service operations, the SOAP Header struct <a class="el" href="structSOAP__ENV____Header.html">SOAP_ENV__Header</a> must have been defined and for each service operation that uses WS-Addressing method-header-part directives should be used in the gSOAP service definitions header file as follows:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#import &quot;wsa.h&quot;</span>

<span class="comment">//gsoap ns service method-header-part: example wsa__MessageID</span>
<span class="comment">//gsoap ns service method-header-part: example wsa__RelatesTo</span>
<span class="comment">//gsoap ns service method-header-part: example wsa__From</span>
<span class="comment">//gsoap ns service method-header-part: example wsa__ReplyTo</span>
<span class="comment">//gsoap ns service method-header-part: example wsa__FaultTo</span>
<span class="comment">//gsoap ns service method-header-part: example wsa__To</span>
<span class="comment">//gsoap ns service method-header-part: example wsa__Action</span>
<span class="comment">//gsoap ns service method-action: example urn:example/examplePort/example</span>
<span class="keywordtype">int</span> ns__example(<span class="keywordtype">char</span> *in, <span class="keyword">struct</span> ns__exampleResponse *out);
</pre></div><p>Note that the use of wsa versions determines the wsa prefix, e.g. use wsa5 for the latest WS-Addressing as in wsa5__MessageID.</p>
<p>In the client-side code, the WS-Addressing information headers are set with soap_wsa_request() by passing an optional message UUID string, a mandatory destination address URI string, and a mandatory request action URI string. The wsa plugin should be registered with the current soap struct context. An optional source address information header can be added with soap_wsa_add_From() (must be invoked after the soap_wsa_request call).</p>
<p>For example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;wsaapi.h&quot;</span>
soap_register_plugin(soap, soap_wsa);

<span class="keywordflow">if</span> (soap_wsa_request(soap, RequestMessageID, ToAddress, RequestAction))
 || soap_wsa_add_From(soap, FromAddress)) <span class="comment">// optional: add a &#39;From&#39; address</span>
  ... <span class="comment">// error: out of memory</span>

<span class="keywordflow">if</span> (soap_call_ns__example(soap, ToAddress, NULL, ...))
  soap_print_fault(soap, stderr); <span class="comment">// an error occurred</span>
<span class="keywordflow">else</span>
  <span class="comment">// process the response </span>
</pre></div><h3><a class="anchor" id="wsa_2_2">
Information Headers for Relaying Server Responses</a></h3>
<p>To relay the response to another destination, the WS-Addressing ReplyTo information header is added with soap_wsa_add_ReplyTo() by passing a reply address URI string. The service returns HTTP 202 ACCEPTED to the client when the response message relay was successful.</p>
<p>For example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;wsaapi.h&quot;</span>
soap_register_plugin(soap, soap_wsa);

<span class="keywordflow">if</span> (soap_wsa_request(soap, RequestMessageID, ToAddress, RequestAction)
 || soap_wsa_add_From(soap, FromAddress) <span class="comment">// optional: add a &#39;From&#39; address</span>
 || soap_wsa_add_ReplyTo(soap, ReplyToAddress))
  ... <span class="comment">// error: out of memory</span>

<span class="keywordflow">if</span> (soap_call_ns__example(soap, ToAddress, NULL, ...))
{
  <span class="keywordflow">if</span> (soap-&gt;error == 202) <span class="comment">// HTTP ACCEPTED</span>
    printf(<span class="stringliteral">&quot;Request was accepted and results were forwarded\n&quot;</span>);
  <span class="keywordflow">else</span>
    soap_print_fault(soap, stderr); <span class="comment">// an error occurred</span>
}
<span class="keywordflow">else</span>
  <span class="comment">// unexpected OK: for some reason the response was not relayed</span>
</pre></div><p>Note: the response message will be relayed when the From address is absent or different than the ReplyTo address</p>
<h3><a class="anchor" id="wsa_2_3">
Information Headers for Relaying Server Faults</a></h3>
<p>To relay a server fault message to another destination, the WS-Addressing FaultTo information header is added with soap_wsa_add_FaultTo() by passing a relay address URI string. The service returns HTTP 202 ACCEPTED to the client when the fault was relayed.</p>
<p>For example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;wsaapi.h&quot;</span>
soap_register_plugin(soap, soap_wsa);

<span class="keywordflow">if</span> (soap_wsa_request(soap, RequestMessageID, ToAddress, RequestAction)
 || soap_wsa_add_From(soap, FromAddress) <span class="comment">// optional: add a &#39;From&#39; address</span>
 || soap_wsa_add_FaultTo(soap, FaultToAddress))
  ... <span class="comment">// error: out of memory</span>

<span class="keywordflow">if</span> (soap_call_ns__example(soap, ToAddress, NULL, ...))
{
  <span class="keywordflow">if</span> (soap-&gt;error == 202) <span class="comment">// HTTP ACCEPTED</span>
    printf(<span class="stringliteral">&quot;A fault occurred and the fault details were forwarded\n&quot;</span>);
  <span class="keywordflow">else</span>
    soap_print_fault(soap, stderr); <span class="comment">// a connection error occurred</span>
}
<span class="keywordflow">else</span>
  <span class="comment">// process response </span>
</pre></div><p>Note that the call can still return a fault, such as a connection error when the service is not responding. In addition to the fault relay, the responses can be relayed with soap_wsa_add_ReplyTo().</p>
<h3><a class="anchor" id="wsa_2_4">
Error Handling</a></h3>
<p>SOAP and HTTP errors set the soap-&gt;error attribute, as shown in this example:</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (soap_call_ns__example(soap, ToAddress, NULL, ...))
{
  <span class="keywordflow">if</span> (soap-&gt;error == 202) <span class="comment">// HTTP ACCEPTED</span>
    printf(<span class="stringliteral">&quot;A fault occurred and the fault details were forwarded\n&quot;</span>);
  <span class="keywordflow">else</span>
    soap_print_fault(soap, stderr); <span class="comment">// a connection error occurred</span>
}
<span class="keywordflow">else</span>
  <span class="comment">// process response </span>
</pre></div><p>When a WS-Addressing error occurred, the wsa error code is stored in the SOAP Fault Subcode field. This information can be retrieved with:</p>
<div class="fragment"><pre class="fragment">wsa__FaultSubcodeValues fault;
<span class="keywordflow">if</span> (soap_wsa_check_fault(soap, &amp;fault))
{
  <span class="keywordflow">switch</span> (fault)
  {
    <span class="keywordflow">case</span> wsa__InvalidMessageInformationHeader: ...
    <span class="keywordflow">case</span> wsa__MessageInformationHeaderRequired: ...
    <span class="keywordflow">case</span> wsa__DestinationUreachable: ...
    <span class="keywordflow">case</span> wsa__ActionNotSupported: ...
    <span class="keywordflow">case</span> wsa__EndpointUnavailable: ...
  }
}
</pre></div><p>When using wsa5.h, please refer to the standards and fault codes for this implementation. For the wsa5.h 2005/03 standard, several faults have an additional parameter (SOAP Fault detail):</p>
<div class="fragment"><pre class="fragment">wsa5__FaultCodesType fault;
<span class="keywordtype">char</span> *info;
<span class="keywordflow">if</span> (soap_wsa_check_fault(soap, &amp;fault, &amp;info))
{
  <span class="keywordflow">switch</span> (fault)
  {
    <span class="keywordflow">case</span> wsa5__InvalidAddressingHeader:
      <span class="keywordflow">if</span> (info)
        printf(<span class="stringliteral">&quot;The invalid addressing header element is %s\n&quot;</span>, info);
    ...
  }
}
</pre></div><h3><a class="anchor" id="wsa_2_5">
Combining WS-Addressing with WS-Security</a></h3>
<p>WS-Security can be combined with WS-Addressing. To sign WS-Addressing header blocks, use the soap_wsse_set_wsu_id() WSSE-plugin call to set the wsu:Id attribute and signing of these attributed elements. For example, suppose we use WS-Addressing 2005:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;wsaapi.h&quot;</span>
<span class="preprocessor">#include &quot;wsseapi.h&quot;</span>
soap_register_plugin(soap, soap_wsa);
soap_register_plugin(soap, soap_wsse);

soap_wsse_set_wsu_id(soap, <span class="stringliteral">&quot;wsa5:From wsa5:To wsa5:ReplyTo wsa5:FaultTo wsa5:Action&quot;</span>);
<span class="keywordflow">if</span> (soap_wsa_request(soap, RequestMessageID, ToAddress, RequestAction)
 || soap_wsa_add_From(soap, FromAddress) <span class="comment">// optional: add a &#39;From&#39; address</span>
 || soap_wsa_add_FaultTo(soap, FaultToAddress))
  ... <span class="comment">// error: out of memory</span>
<span class="keywordflow">if</span> (soap_call_ns__example(soap, ToAddress, NULL, ...))
  ... <span class="comment">// error</span>
</pre></div><p>Note: soap_wsse_set_wsu_id() should only be set once. Each new call overrides the previous.</p>
<p>For more details on WS-Security, please see the <a href="../../wsse/html/index.html">WSSE plugin documentation</a>.</p>
<h2><a class="anchor" id="wsa_3">
Server-side Usage</a></h2>
<p>The wsa plugin should be registered with:</p>
<div class="fragment"><pre class="fragment">soap_register_plugin(soap, soap_wsa);
</pre></div><p>Once the plugin is registered, the soap_bind(), soap_accept(), and soap_serve() functions can be called to process requests and semi-automatically handle the WS-Addressing header blocks.</p>
<p>Important: to dispatch service operations based on the WS-Addressing wsa:Action information header, you must use soapcpp2 option -a. The generates a new dispatcher (in soapServer.c) based on the action value.</p>
<p>A service operation implementation should use soap_wsa_check() to verify the validity of the WS-Addressing information headers in the SOAP request message. To allow response message to be automatically relayed based on the ReplyTo information header, the service operation should return soap_wsa_reply() with an optional message UUID string and a mandatory response action string.</p>
<p>For example:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> ns__example(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">char</span> *in, <span class="keyword">struct</span> ns__exampleResponse *out)
{ <span class="keywordflow">if</span> (soap_wsa_check(soap))
    <span class="keywordflow">return</span> soap-&gt;error;
  <span class="comment">// ... service logic</span>
  <span class="keywordflow">return</span> soap_wsa_reply(soap, ResponseMessageID, ResponseAction);
}
</pre></div><p>To return a SOAP fault that is automatically relayed to a fault service based on the FaultTo information header, the soap_wsa_sender_fault(), soap_wsa_receiver_fault(), soap_wsa_sender_fault_subcode(), and soap_wsa_receiver_fault_subcode() functions should be used instead of the soap_sender_fault(), soap_receiver_fault(), soap_sender_fault_subcode(), and soap_receiver_fault_subcode(), respectively.</p>
<p>For example, the following service operation illustrates the use of soap_wsa_check() to verify and process WS-Addressing header blocks and soap_wsA_reply() to enable responses to be relayed as per ReplyTo address in the WS-Addressing header:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> ns__example(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">char</span> *in, <span class="keyword">struct</span> ns__exampleResponse *out)
{ <span class="keywordflow">if</span> (soap_wsa_check(soap))
    <span class="keywordflow">return</span> soap-&gt;error;
  <span class="comment">// ... service logic</span>
  <span class="comment">// ... an error occurred, need to return fault possibly to fault service:</span>
    <span class="keywordflow">return</span> soap_wsa_sender_fault(soap, <span class="stringliteral">&quot;Exception in service operation&quot;</span>, NULL);
  <span class="comment">// ... normal execution continues</span>
  <span class="keywordflow">return</span> soap_wsa_reply(soap, ResponseMessageID, ResponseAction);
}
</pre></div><h2><a class="anchor" id="wsa_4">
HTTPS Server-side Usage</a></h2>
<p>To enable HTTPS (SSL/TSL) servers, compile the sources with -DWITH_OPENSSL (and link with libgsoapssl, libssl, and libcrypto). Because WS-Addressing may relay messages over HTTPS as a sender (client), you must initialize the SSL context for server and client uses. Therefore, the context must have access to all the certificates need to verify the authenticity of the ReplyTo and FaultTo HTTPS servers. To do so, use the following SSL initialization before soap_bind():</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>soap *soap = soap_new();
<span class="keywordflow">if</span> (soap_ssl_server_context(soap,
  SOAP_SSL_DEFAULT,
  <span class="stringliteral">&quot;server.pem&quot;</span>, <span class="comment">// the keyfile (server should authenticate)</span>
  <span class="stringliteral">&quot;password&quot;</span>,   <span class="comment">// password to read the key file</span>
  <span class="stringliteral">&quot;cacert.pem&quot;</span>, <span class="comment">// cacert file to store trusted certificates (role as client)</span>
  NULL,         <span class="comment">// optional capath</span>
  NULL,         <span class="comment">// DH file name or DH param key len bits, when NULL use RSA</span>
  NULL,         <span class="comment">// file with random data to seed randomness</span>
  <span class="stringliteral">&quot;myserver&quot;</span>    <span class="comment">// unique server identification for SSL session cache</span>
))
{ soap_print_fault(soap, stderr);
  ...
}
soap-&gt;bind_flags = SO_REUSEADDR;
<span class="keywordflow">if</span> (!soap_valid_socket(soap_bind(soap, NULL, port, 100)))
{ soap_print_fault(soap, stderr);
  ...
}
</pre></div><h2><a class="anchor" id="wsa_5">
Implementing a Server for Handling ReplyTo Response Messages</a></h2>
<p>To implement a separate server for handling relayed SOAP response messages based on the ReplyTo information header in the request message, the gSOAP header file should include a one-way service operation for the response message.</p>
<p>For example, suppose a service operation returns an exampleResponse message. We declare the one-way exampleResponse operation as follows:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#import &quot;wsa.h&quot;</span>

<span class="comment">//gsoap ns service method-header-part: exampleResult wsa__MessageID</span>
<span class="comment">//gsoap ns service method-header-part: exampleResult wsa__RelatesTo</span>
<span class="comment">//gsoap ns service method-header-part: exampleResult wsa__From</span>
<span class="comment">//gsoap ns service method-header-part: exampleResult wsa__ReplyTo</span>
<span class="comment">//gsoap ns service method-header-part: exampleResult wsa__FaultTo</span>
<span class="comment">//gsoap ns service method-header-part: exampleResult wsa__To</span>
<span class="comment">//gsoap ns service method-header-part: exampleResult wsa__Action</span>
<span class="comment">//gsoap ns service method-action: exampleResult urn:example/examplePort/exampleResponse</span>
<span class="keywordtype">int</span> ns__exampleResponse(<span class="keywordtype">char</span> *out, <span class="keywordtype">void</span>);
</pre></div><p>Note that the action information is important, because it is used by the service dispatcher (assuming soapcpp2 option -a is used).</p>
<p>The implementation in the server code uses soap_wsa_check() to check the presense and validity of the WS-Addressing information header in the message. The soap_send_empty_response() function should be used to return an acknowledgment HTTP header with HTTP 202 ACCEPTED to the sender:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> ns__exampleResponse(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">char</span> *out)
{ <span class="keywordflow">if</span> (soap_wsa_check(soap))
    <span class="keywordflow">return</span> soap_send_empty_response(soap, 500); <span class="comment">// HTTP 500 Internal Server Error</span>
  <span class="comment">// ... service logic</span>
  <span class="keywordflow">return</span> soap_send_empty_response(soap, SOAP_OK); <span class="comment">// HTTP 202 ACCEPTED</span>
}
</pre></div><h2><a class="anchor" id="wsa_6">
Implementing a Server for Handling FaultTo Fault Messages</a></h2>
<p>To implement a separate server for handling relayed SOAP fault messages based on the FaultTo information header in the request message, the gSOAP header file for soapcpp2 should include a SOAP fault service operation. This operation accepts fault messages that are relayed by other services.</p>
<p>Basically, we use a trick to generate the SOAP-ENV:Fault struct via a one-way service operation. This allows us both to implement a one-way service operation that accepts faults and to automatically generate the fault struct for fault data storage and manipulation.</p>
<p>The fault operation in the header file should be declared as follows (for the 2004/08 standard):</p>
<div class="fragment"><pre class="fragment"><span class="comment">//gsoap SOAP_ENV service method-action: Fault http://schemas.xmlsoap.org/ws/2004/08/addressing/fault</span>
<span class="keywordtype">int</span> <a class="code" href="structSOAP__ENV____Fault.html">SOAP_ENV__Fault</a>
(       _QName                   faultcode,             <span class="comment">// SOAP 1.1</span>
        <span class="keywordtype">char</span>                    *faultstring,           <span class="comment">// SOAP 1.1</span>
        <span class="keywordtype">char</span>                    *faultactor,            <span class="comment">// SOAP 1.1</span>
        <span class="keyword">struct</span> <a class="code" href="structSOAP__ENV____Detail.html">SOAP_ENV__Detail</a> *detail,                <span class="comment">// SOAP 1.1</span>
        <span class="keyword">struct</span> <a class="code" href="structSOAP__ENV____Code.html">SOAP_ENV__Code</a>   *<a class="code" href="structSOAP__ENV____Code.html">SOAP_ENV__Code</a>,        <span class="comment">// SOAP 1.2</span>
        <span class="keyword">struct</span> <a class="code" href="structSOAP__ENV____Reason.html">SOAP_ENV__Reason</a> *<a class="code" href="structSOAP__ENV____Reason.html">SOAP_ENV__Reason</a>,      <span class="comment">// SOAP 1.2</span>
        <span class="keywordtype">char</span>                    *SOAP_ENV__Node,        <span class="comment">// SOAP 1.2</span>
        <span class="keywordtype">char</span>                    *SOAP_ENV__Role,        <span class="comment">// SOAP 1.2</span>
        <span class="keyword">struct</span> <a class="code" href="structSOAP__ENV____Detail.html">SOAP_ENV__Detail</a> *<a class="code" href="structSOAP__ENV____Detail.html">SOAP_ENV__Detail</a>,      <span class="comment">// SOAP 1.2</span>
        <span class="keywordtype">void</span>
);
</pre></div><p>Because each service operation has a struct to hold its input parameters, we automatically generate the (original) <a class="el" href="structSOAP__ENV____Fault.html">SOAP_ENV__Fault</a> struct on the fly!</p>
<p>Note: it is important to associate the wsa fault action with this operation as shown above.</p>
<p>The implementation of the service operation in the server code is:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="structSOAP__ENV____Fault.html">SOAP_ENV__Fault</a>(<span class="keyword">struct</span> soap *soap, <span class="keywordtype">char</span> *faultcode, <span class="keywordtype">char</span> *faultstring, <span class="keywordtype">char</span> *faultactor, <span class="keyword">struct</span> <a class="code" href="structSOAP__ENV____Detail.html">SOAP_ENV__Detail</a> *detail, <span class="keyword">struct</span> <a class="code" href="structSOAP__ENV____Code.html">SOAP_ENV__Code</a> *<a class="code" href="structSOAP__ENV____Code.html">SOAP_ENV__Code</a>, <span class="keyword">struct</span> <a class="code" href="structSOAP__ENV____Reason.html">SOAP_ENV__Reason</a> *<a class="code" href="structSOAP__ENV____Reason.html">SOAP_ENV__Reason</a>, <span class="keywordtype">char</span> *SOAP_ENV__Node, <span class="keywordtype">char</span> *SOAP_ENV__Role, <span class="keyword">struct</span> <a class="code" href="structSOAP__ENV____Detail.html">SOAP_ENV__Detail</a> *<a class="code" href="structSOAP__ENV____Detail.html">SOAP_ENV__Detail</a>)
{ 
  ... = faultcode; <span class="comment">// SOAP 1.1 fault code string (QName)</span>
  ... = faultstring; <span class="comment">// SOAP 1.1 fault string</span>
  ... = faultactor; <span class="comment">// SOAP 1.1 fault actor string</span>
  ... = detail; <span class="comment">// SOAP 1.1 fault detail struct</span>
  ... = SOAP_ENV__Code; <span class="comment">// SOAP 1.2 fault code struct</span>
  ... = SOAP_ENV__Reason; <span class="comment">// SOAP 1.2 reason struct</span>
  ... = SOAP_ENV__Node; <span class="comment">// SOAP 1.2 node string</span>
  ... = SOAP_ENV__Role; <span class="comment">// SOAP 1.2 role string</span>
  ... = SOAP_ENV__Detail; <span class="comment">// SOAP 1.2 detail struct</span>
  <span class="keywordflow">return</span> SOAP_OK;
}
</pre></div><p>Note that SOAP 1.1 or SOAP 1.2 parameters are set based on the 1.1/1.2 messaging requirements. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Sep 21 16:00:06 2011 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
