/* soapC.cpp
   Generated by gSOAP 2.7.17 from ../pass.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.17 2010-11-04 15:45:44 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE__pass__create_USCOREtopic_publish_USCOREmode:
		return soap_in__pass__create_USCOREtopic_publish_USCOREmode(soap, NULL, NULL, "pass:create_topic-publish_mode");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE__pass__item_USCOREdata_item_USCOREdata_USCOREclassification:
		return soap_in__pass__item_USCOREdata_item_USCOREdata_USCOREclassification(soap, NULL, NULL, "pass:item_data-item_data_classification");
	case SOAP_TYPE__pass__status_status_USCOREcode:
		return soap_in__pass__status_status_USCOREcode(soap, NULL, NULL, "pass:status-status_code");
	case SOAP_TYPE__pass__status_command:
		return soap_in__pass__status_command(soap, NULL, NULL, "pass:status-command");
	case SOAP_TYPE__xlink__actuate:
		return soap_in__xlink__actuate(soap, NULL, NULL, "xlink:actuate");
	case SOAP_TYPE__xlink__show:
		return soap_in__xlink__show(soap, NULL, NULL, "xlink:show");
	case SOAP_TYPE_pass__item_USCORETTL:
		return soap_in_pass__item_USCORETTL(soap, NULL, NULL, "pass:item_TTL");
	case SOAP_TYPE_pass__longitude:
		return soap_in_pass__longitude(soap, NULL, NULL, "pass:longitude");
	case SOAP_TYPE_pass__latitude:
		return soap_in_pass__latitude(soap, NULL, NULL, "pass:latitude");
	case SOAP_TYPE_pass__item_USCOREdata:
		return soap_in_pass__item_USCOREdata(soap, NULL, NULL, "pass:item_data");
	case SOAP_TYPE_pass__item:
		return soap_in_pass__item(soap, NULL, NULL, "pass:item");
	case SOAP_TYPE_pass__pass_USCOREfault:
		return soap_in_pass__pass_USCOREfault(soap, NULL, NULL, "pass:pass_fault");
	case SOAP_TYPE_pass__status:
		return soap_in_pass__status(soap, NULL, NULL, "pass:status");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__anyAttribute:
		return soap_in_xsd__anyAttribute(soap, NULL, NULL, "xsd:anyAttribute");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTo_pass__sync_USCOREresponse:
		return soap_in_PointerTo_pass__sync_USCOREresponse(soap, NULL, NULL, "pass:sync_response");
	case SOAP_TYPE_PointerTo_pass__sync:
		return soap_in_PointerTo_pass__sync(soap, NULL, NULL, "pass:sync");
	case SOAP_TYPE_PointerTo_pass__unsubscribe:
		return soap_in_PointerTo_pass__unsubscribe(soap, NULL, NULL, "pass:unsubscribe");
	case SOAP_TYPE_PointerTo_pass__retract_USCOREtopic:
		return soap_in_PointerTo_pass__retract_USCOREtopic(soap, NULL, NULL, "pass:retract_topic");
	case SOAP_TYPE_PointerTo_pass__retract_USCOREitem:
		return soap_in_PointerTo_pass__retract_USCOREitem(soap, NULL, NULL, "pass:retract_item");
	case SOAP_TYPE_PointerTopass__pass_USCOREfault:
		return soap_in_PointerTopass__pass_USCOREfault(soap, NULL, NULL, "pass:pass_fault");
	case SOAP_TYPE_PointerTo_pass__subscribe:
		return soap_in_PointerTo_pass__subscribe(soap, NULL, NULL, "pass:subscribe");
	case SOAP_TYPE_PointerTo_pass__create_USCOREtopic:
		return soap_in_PointerTo_pass__create_USCOREtopic(soap, NULL, NULL, "pass:create_topic");
	case SOAP_TYPE_PointerTo_pass__publish:
		return soap_in_PointerTo_pass__publish(soap, NULL, NULL, "pass:publish");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_in_PointerToxsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTopass__item:
		return soap_in_PointerTopass__item(soap, NULL, NULL, "pass:item");
	case SOAP_TYPE_PointerTo_pass__References_ReferenceObj:
		return soap_in_PointerTo_pass__References_ReferenceObj(soap, NULL, NULL, "pass:References-ReferenceObj");
	case SOAP_TYPE_PointerTo_xlink__actuate:
		return soap_in_PointerTo_xlink__actuate(soap, NULL, NULL, "xlink:actuate");
	case SOAP_TYPE_PointerTo_xlink__show:
		return soap_in_PointerTo_xlink__show(soap, NULL, NULL, "xlink:show");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTo_pass__References:
		return soap_in_PointerTo_pass__References(soap, NULL, NULL, "pass:References");
	case SOAP_TYPE_PointerTopass__item_USCOREdata:
		return soap_in_PointerTopass__item_USCOREdata(soap, NULL, NULL, "pass:item_data");
	case SOAP_TYPE_PointerTo_pass__AOI_USCORErectangle:
		return soap_in_PointerTo_pass__AOI_USCORErectangle(soap, NULL, NULL, "pass:AOI_rectangle");
	case SOAP_TYPE_PointerTopass__status:
		return soap_in_PointerTopass__status(soap, NULL, NULL, "pass:status");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "pass:item_TTL"))
		{	*type = SOAP_TYPE_pass__item_USCORETTL;
			return soap_in_pass__item_USCORETTL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:longitude"))
		{	*type = SOAP_TYPE_pass__longitude;
			return soap_in_pass__longitude(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:latitude"))
		{	*type = SOAP_TYPE_pass__latitude;
			return soap_in_pass__latitude(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:item_data"))
		{	*type = SOAP_TYPE_pass__item_USCOREdata;
			return soap_in_pass__item_USCOREdata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:item"))
		{	*type = SOAP_TYPE_pass__item;
			return soap_in_pass__item(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:pass_fault"))
		{	*type = SOAP_TYPE_pass__pass_USCOREfault;
			return soap_in_pass__pass_USCOREfault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:status"))
		{	*type = SOAP_TYPE_pass__status;
			return soap_in_pass__status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:create_topic-publish_mode"))
		{	*type = SOAP_TYPE__pass__create_USCOREtopic_publish_USCOREmode;
			return soap_in__pass__create_USCOREtopic_publish_USCOREmode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:item_data-item_data_classification"))
		{	*type = SOAP_TYPE__pass__item_USCOREdata_item_USCOREdata_USCOREclassification;
			return soap_in__pass__item_USCOREdata_item_USCOREdata_USCOREclassification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:status-status_code"))
		{	*type = SOAP_TYPE__pass__status_status_USCOREcode;
			return soap_in__pass__status_status_USCOREcode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:status-command"))
		{	*type = SOAP_TYPE__pass__status_command;
			return soap_in__pass__status_command(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xlink:actuate"))
		{	*type = SOAP_TYPE__xlink__actuate;
			return soap_in__xlink__actuate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xlink:show"))
		{	*type = SOAP_TYPE__xlink__show;
			return soap_in__xlink__show(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyAttribute"))
		{	*type = SOAP_TYPE_xsd__anyAttribute;
			return soap_in_xsd__anyAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "pass:References-ReferenceObj"))
		{	*type = SOAP_TYPE__pass__References_ReferenceObj;
			return soap_in__pass__References_ReferenceObj(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:create_topic"))
		{	*type = SOAP_TYPE__pass__create_USCOREtopic;
			return soap_in__pass__create_USCOREtopic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:sync_response"))
		{	*type = SOAP_TYPE__pass__sync_USCOREresponse;
			return soap_in__pass__sync_USCOREresponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:sync"))
		{	*type = SOAP_TYPE__pass__sync;
			return soap_in__pass__sync(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:subscribe"))
		{	*type = SOAP_TYPE__pass__subscribe;
			return soap_in__pass__subscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:unsubscribe"))
		{	*type = SOAP_TYPE__pass__unsubscribe;
			return soap_in__pass__unsubscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:retract_topic"))
		{	*type = SOAP_TYPE__pass__retract_USCOREtopic;
			return soap_in__pass__retract_USCOREtopic(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:retract_item"))
		{	*type = SOAP_TYPE__pass__retract_USCOREitem;
			return soap_in__pass__retract_USCOREitem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:publish"))
		{	*type = SOAP_TYPE__pass__publish;
			return soap_in__pass__publish(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:References"))
		{	*type = SOAP_TYPE__pass__References;
			return soap_in__pass__References(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "pass:AOI_rectangle"))
		{	*type = SOAP_TYPE__pass__AOI_USCORErectangle;
			return soap_in__pass__AOI_USCORErectangle(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE__pass__create_USCOREtopic_publish_USCOREmode:
		return soap_out__pass__create_USCOREtopic_publish_USCOREmode(soap, tag, id, (const enum _pass__create_USCOREtopic_publish_USCOREmode *)ptr, "pass:create_topic-publish_mode");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__pass__item_USCOREdata_item_USCOREdata_USCOREclassification:
		return soap_out__pass__item_USCOREdata_item_USCOREdata_USCOREclassification(soap, tag, id, (const enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification *)ptr, "pass:item_data-item_data_classification");
	case SOAP_TYPE__pass__status_status_USCOREcode:
		return soap_out__pass__status_status_USCOREcode(soap, tag, id, (const enum _pass__status_status_USCOREcode *)ptr, "pass:status-status_code");
	case SOAP_TYPE__pass__status_command:
		return soap_out__pass__status_command(soap, tag, id, (const enum _pass__status_command *)ptr, "pass:status-command");
	case SOAP_TYPE__xlink__actuate:
		return soap_out__xlink__actuate(soap, tag, id, (const enum _xlink__actuate *)ptr, "xlink:actuate");
	case SOAP_TYPE__xlink__show:
		return soap_out__xlink__show(soap, tag, id, (const enum _xlink__show *)ptr, "xlink:show");
	case SOAP_TYPE__pass__References_ReferenceObj:
		return ((_pass__References_ReferenceObj *)ptr)->soap_out(soap, "pass:References-ReferenceObj", id, NULL);
	case SOAP_TYPE_pass__item_USCORETTL:
		return soap_out_pass__item_USCORETTL(soap, tag, id, (const std::string *)ptr, "pass:item_TTL");
	case SOAP_TYPE_pass__longitude:
		return soap_out_pass__longitude(soap, tag, id, (const std::string *)ptr, "pass:longitude");
	case SOAP_TYPE_pass__latitude:
		return soap_out_pass__latitude(soap, tag, id, (const std::string *)ptr, "pass:latitude");
	case SOAP_TYPE__pass__create_USCOREtopic:
		return ((_pass__create_USCOREtopic *)ptr)->soap_out(soap, "pass:create_topic", id, NULL);
	case SOAP_TYPE__pass__sync_USCOREresponse:
		return ((_pass__sync_USCOREresponse *)ptr)->soap_out(soap, "pass:sync_response", id, NULL);
	case SOAP_TYPE__pass__sync:
		return ((_pass__sync *)ptr)->soap_out(soap, "pass:sync", id, NULL);
	case SOAP_TYPE__pass__subscribe:
		return ((_pass__subscribe *)ptr)->soap_out(soap, "pass:subscribe", id, NULL);
	case SOAP_TYPE__pass__unsubscribe:
		return ((_pass__unsubscribe *)ptr)->soap_out(soap, "pass:unsubscribe", id, NULL);
	case SOAP_TYPE__pass__retract_USCOREtopic:
		return ((_pass__retract_USCOREtopic *)ptr)->soap_out(soap, "pass:retract_topic", id, NULL);
	case SOAP_TYPE__pass__retract_USCOREitem:
		return ((_pass__retract_USCOREitem *)ptr)->soap_out(soap, "pass:retract_item", id, NULL);
	case SOAP_TYPE__pass__publish:
		return ((_pass__publish *)ptr)->soap_out(soap, "pass:publish", id, NULL);
	case SOAP_TYPE__pass__References:
		return ((_pass__References *)ptr)->soap_out(soap, "pass:References", id, NULL);
	case SOAP_TYPE__pass__AOI_USCORErectangle:
		return ((_pass__AOI_USCORErectangle *)ptr)->soap_out(soap, "pass:AOI_rectangle", id, NULL);
	case SOAP_TYPE_pass__item_USCOREdata:
		return ((pass__item_USCOREdata *)ptr)->soap_out(soap, tag, id, "pass:item_data");
	case SOAP_TYPE_pass__item:
		return ((pass__item *)ptr)->soap_out(soap, tag, id, "pass:item");
	case SOAP_TYPE_pass__pass_USCOREfault:
		return ((pass__pass_USCOREfault *)ptr)->soap_out(soap, tag, id, "pass:pass_fault");
	case SOAP_TYPE_pass__status:
		return ((pass__status *)ptr)->soap_out(soap, tag, id, "pass:status");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::string *)ptr, "xsd:integer");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__anyAttribute:
		return soap_out_xsd__anyAttribute(soap, tag, id, (const struct soap_dom_attribute *)ptr, "xsd:anyAttribute");
	case SOAP_TYPE_xsd__anyType:
		return soap_out_xsd__anyType(soap, tag, id, (const struct soap_dom_element *)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerTo_pass__sync_USCOREresponse:
		return soap_out_PointerTo_pass__sync_USCOREresponse(soap, tag, id, (_pass__sync_USCOREresponse *const*)ptr, "pass:sync_response");
	case SOAP_TYPE_PointerTo_pass__sync:
		return soap_out_PointerTo_pass__sync(soap, tag, id, (_pass__sync *const*)ptr, "pass:sync");
	case SOAP_TYPE_PointerTo_pass__unsubscribe:
		return soap_out_PointerTo_pass__unsubscribe(soap, tag, id, (_pass__unsubscribe *const*)ptr, "pass:unsubscribe");
	case SOAP_TYPE_PointerTo_pass__retract_USCOREtopic:
		return soap_out_PointerTo_pass__retract_USCOREtopic(soap, tag, id, (_pass__retract_USCOREtopic *const*)ptr, "pass:retract_topic");
	case SOAP_TYPE_PointerTo_pass__retract_USCOREitem:
		return soap_out_PointerTo_pass__retract_USCOREitem(soap, tag, id, (_pass__retract_USCOREitem *const*)ptr, "pass:retract_item");
	case SOAP_TYPE_PointerTopass__pass_USCOREfault:
		return soap_out_PointerTopass__pass_USCOREfault(soap, tag, id, (pass__pass_USCOREfault *const*)ptr, "pass:pass_fault");
	case SOAP_TYPE_PointerTo_pass__subscribe:
		return soap_out_PointerTo_pass__subscribe(soap, tag, id, (_pass__subscribe *const*)ptr, "pass:subscribe");
	case SOAP_TYPE_PointerTo_pass__create_USCOREtopic:
		return soap_out_PointerTo_pass__create_USCOREtopic(soap, tag, id, (_pass__create_USCOREtopic *const*)ptr, "pass:create_topic");
	case SOAP_TYPE_PointerTo_pass__publish:
		return soap_out_PointerTo_pass__publish(soap, tag, id, (_pass__publish *const*)ptr, "pass:publish");
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		return soap_out_PointerToxsd__nonNegativeInteger(soap, tag, id, (std::string *const*)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_PointerTopass__item:
		return soap_out_PointerTopass__item(soap, tag, id, (pass__item *const*)ptr, "pass:item");
	case SOAP_TYPE_PointerTo_pass__References_ReferenceObj:
		return soap_out_PointerTo_pass__References_ReferenceObj(soap, tag, id, (_pass__References_ReferenceObj *const*)ptr, "pass:References-ReferenceObj");
	case SOAP_TYPE_PointerTo_xlink__actuate:
		return soap_out_PointerTo_xlink__actuate(soap, tag, id, (enum _xlink__actuate *const*)ptr, "xlink:actuate");
	case SOAP_TYPE_PointerTo_xlink__show:
		return soap_out_PointerTo_xlink__show(soap, tag, id, (enum _xlink__show *const*)ptr, "xlink:show");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTo_pass__References:
		return soap_out_PointerTo_pass__References(soap, tag, id, (_pass__References *const*)ptr, "pass:References");
	case SOAP_TYPE_PointerTopass__item_USCOREdata:
		return soap_out_PointerTopass__item_USCOREdata(soap, tag, id, (pass__item_USCOREdata *const*)ptr, "pass:item_data");
	case SOAP_TYPE_PointerTo_pass__AOI_USCORErectangle:
		return soap_out_PointerTo_pass__AOI_USCORErectangle(soap, tag, id, (_pass__AOI_USCORErectangle *const*)ptr, "pass:AOI_rectangle");
	case SOAP_TYPE_PointerTopass__status:
		return soap_out_PointerTopass__status(soap, tag, id, (pass__status *const*)ptr, "pass:status");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__pass__References_ReferenceObj:
		((_pass__References_ReferenceObj *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_pass__item_USCORETTL:
		soap_serialize_pass__item_USCORETTL(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_pass__longitude:
		soap_serialize_pass__longitude(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_pass__latitude:
		soap_serialize_pass__latitude(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__pass__create_USCOREtopic:
		((_pass__create_USCOREtopic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__pass__sync_USCOREresponse:
		((_pass__sync_USCOREresponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__pass__sync:
		((_pass__sync *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__pass__subscribe:
		((_pass__subscribe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__pass__unsubscribe:
		((_pass__unsubscribe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__pass__retract_USCOREtopic:
		((_pass__retract_USCOREtopic *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__pass__retract_USCOREitem:
		((_pass__retract_USCOREitem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__pass__publish:
		((_pass__publish *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__pass__References:
		((_pass__References *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__pass__AOI_USCORErectangle:
		((_pass__AOI_USCORErectangle *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_pass__item_USCOREdata:
		((pass__item_USCOREdata *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_pass__item:
		((pass__item *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_pass__pass_USCOREfault:
		((pass__pass_USCOREfault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_pass__status:
		((pass__status *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns2__unsubscribe:
		soap_serialize___ns2__unsubscribe(soap, (const struct __ns2__unsubscribe *)ptr);
		break;
	case SOAP_TYPE___ns2__retract_USCOREtopic:
		soap_serialize___ns2__retract_USCOREtopic(soap, (const struct __ns2__retract_USCOREtopic *)ptr);
		break;
	case SOAP_TYPE___ns2__retract_USCOREitem:
		soap_serialize___ns2__retract_USCOREitem(soap, (const struct __ns2__retract_USCOREitem *)ptr);
		break;
	case SOAP_TYPE___ns2__publish:
		soap_serialize___ns2__publish(soap, (const struct __ns2__publish *)ptr);
		break;
	case SOAP_TYPE___ns1__sync:
		soap_serialize___ns1__sync(soap, (const struct __ns1__sync *)ptr);
		break;
	case SOAP_TYPE___ns1__create_USCOREtopic:
		soap_serialize___ns1__create_USCOREtopic(soap, (const struct __ns1__create_USCOREtopic *)ptr);
		break;
	case SOAP_TYPE___ns1__publish:
		soap_serialize___ns1__publish(soap, (const struct __ns1__publish *)ptr);
		break;
	case SOAP_TYPE___ns1__unsubscribe:
		soap_serialize___ns1__unsubscribe(soap, (const struct __ns1__unsubscribe *)ptr);
		break;
	case SOAP_TYPE___ns1__retract_USCOREtopic:
		soap_serialize___ns1__retract_USCOREtopic(soap, (const struct __ns1__retract_USCOREtopic *)ptr);
		break;
	case SOAP_TYPE___ns1__retract_USCOREitem:
		soap_serialize___ns1__retract_USCOREitem(soap, (const struct __ns1__retract_USCOREitem *)ptr);
		break;
	case SOAP_TYPE___ns1__subscribe:
		soap_serialize___ns1__subscribe(soap, (const struct __ns1__subscribe *)ptr);
		break;
	case SOAP_TYPE_xsd__anyAttribute:
		soap_serialize_xsd__anyAttribute(soap, (const struct soap_dom_attribute *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		soap_serialize_xsd__anyType(soap, (const struct soap_dom_element *)ptr);
		break;
	case SOAP_TYPE_PointerTo_pass__sync_USCOREresponse:
		soap_serialize_PointerTo_pass__sync_USCOREresponse(soap, (_pass__sync_USCOREresponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_pass__sync:
		soap_serialize_PointerTo_pass__sync(soap, (_pass__sync *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_pass__unsubscribe:
		soap_serialize_PointerTo_pass__unsubscribe(soap, (_pass__unsubscribe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_pass__retract_USCOREtopic:
		soap_serialize_PointerTo_pass__retract_USCOREtopic(soap, (_pass__retract_USCOREtopic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_pass__retract_USCOREitem:
		soap_serialize_PointerTo_pass__retract_USCOREitem(soap, (_pass__retract_USCOREitem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTopass__pass_USCOREfault:
		soap_serialize_PointerTopass__pass_USCOREfault(soap, (pass__pass_USCOREfault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_pass__subscribe:
		soap_serialize_PointerTo_pass__subscribe(soap, (_pass__subscribe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_pass__create_USCOREtopic:
		soap_serialize_PointerTo_pass__create_USCOREtopic(soap, (_pass__create_USCOREtopic *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_pass__publish:
		soap_serialize_PointerTo_pass__publish(soap, (_pass__publish *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__nonNegativeInteger:
		soap_serialize_PointerToxsd__nonNegativeInteger(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTopass__item:
		soap_serialize_PointerTopass__item(soap, (pass__item *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_pass__References_ReferenceObj:
		soap_serialize_PointerTo_pass__References_ReferenceObj(soap, (_pass__References_ReferenceObj *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_xlink__actuate:
		soap_serialize_PointerTo_xlink__actuate(soap, (enum _xlink__actuate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_xlink__show:
		soap_serialize_PointerTo_xlink__show(soap, (enum _xlink__show *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_pass__References:
		soap_serialize_PointerTo_pass__References(soap, (_pass__References *const*)ptr);
		break;
	case SOAP_TYPE_PointerTopass__item_USCOREdata:
		soap_serialize_PointerTopass__item_USCOREdata(soap, (pass__item_USCOREdata *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_pass__AOI_USCORErectangle:
		soap_serialize_PointerTo_pass__AOI_USCORErectangle(soap, (_pass__AOI_USCORErectangle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTopass__status:
		soap_serialize_PointerTopass__status(soap, (pass__status *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_pass__status:
		return (void*)soap_instantiate_pass__status(soap, -1, type, arrayType, n);
	case SOAP_TYPE_pass__pass_USCOREfault:
		return (void*)soap_instantiate_pass__pass_USCOREfault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_pass__item:
		return (void*)soap_instantiate_pass__item(soap, -1, type, arrayType, n);
	case SOAP_TYPE_pass__item_USCOREdata:
		return (void*)soap_instantiate_pass__item_USCOREdata(soap, -1, type, arrayType, n);
	case SOAP_TYPE__pass__AOI_USCORErectangle:
		return (void*)soap_instantiate__pass__AOI_USCORErectangle(soap, -1, type, arrayType, n);
	case SOAP_TYPE__pass__References_ReferenceObj:
		return (void*)soap_instantiate__pass__References_ReferenceObj(soap, -1, type, arrayType, n);
	case SOAP_TYPE__pass__References:
		return (void*)soap_instantiate__pass__References(soap, -1, type, arrayType, n);
	case SOAP_TYPE__pass__publish:
		return (void*)soap_instantiate__pass__publish(soap, -1, type, arrayType, n);
	case SOAP_TYPE__pass__retract_USCOREitem:
		return (void*)soap_instantiate__pass__retract_USCOREitem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__pass__retract_USCOREtopic:
		return (void*)soap_instantiate__pass__retract_USCOREtopic(soap, -1, type, arrayType, n);
	case SOAP_TYPE__pass__unsubscribe:
		return (void*)soap_instantiate__pass__unsubscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__pass__subscribe:
		return (void*)soap_instantiate__pass__subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__pass__sync:
		return (void*)soap_instantiate__pass__sync(soap, -1, type, arrayType, n);
	case SOAP_TYPE__pass__sync_USCOREresponse:
		return (void*)soap_instantiate__pass__sync_USCOREresponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__pass__create_USCOREtopic:
		return (void*)soap_instantiate__pass__create_USCOREtopic(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__subscribe:
		return (void*)soap_instantiate___ns1__subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retract_USCOREitem:
		return (void*)soap_instantiate___ns1__retract_USCOREitem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__retract_USCOREtopic:
		return (void*)soap_instantiate___ns1__retract_USCOREtopic(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__unsubscribe:
		return (void*)soap_instantiate___ns1__unsubscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__publish:
		return (void*)soap_instantiate___ns1__publish(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__create_USCOREtopic:
		return (void*)soap_instantiate___ns1__create_USCOREtopic(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sync:
		return (void*)soap_instantiate___ns1__sync(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__publish:
		return (void*)soap_instantiate___ns2__publish(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__retract_USCOREitem:
		return (void*)soap_instantiate___ns2__retract_USCOREitem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__retract_USCOREtopic:
		return (void*)soap_instantiate___ns2__retract_USCOREtopic(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__unsubscribe:
		return (void*)soap_instantiate___ns2__unsubscribe(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyAttribute:
		return (void*)soap_instantiate_xsd__anyAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_pass__latitude:
		return (void*)soap_instantiate_pass__latitude(soap, -1, type, arrayType, n);
	case SOAP_TYPE_pass__longitude:
		return (void*)soap_instantiate_pass__longitude(soap, -1, type, arrayType, n);
	case SOAP_TYPE_pass__item_USCORETTL:
		return (void*)soap_instantiate_pass__item_USCORETTL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_pass__subscribe:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_pass__subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTopass__item:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTopass__item(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_pass__status:
		if (p->size < 0)
			SOAP_DELETE((pass__status*)p->ptr);
		else
			SOAP_DELETE_ARRAY((pass__status*)p->ptr);
		break;
	case SOAP_TYPE_pass__pass_USCOREfault:
		if (p->size < 0)
			SOAP_DELETE((pass__pass_USCOREfault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((pass__pass_USCOREfault*)p->ptr);
		break;
	case SOAP_TYPE_pass__item:
		if (p->size < 0)
			SOAP_DELETE((pass__item*)p->ptr);
		else
			SOAP_DELETE_ARRAY((pass__item*)p->ptr);
		break;
	case SOAP_TYPE_pass__item_USCOREdata:
		if (p->size < 0)
			SOAP_DELETE((pass__item_USCOREdata*)p->ptr);
		else
			SOAP_DELETE_ARRAY((pass__item_USCOREdata*)p->ptr);
		break;
	case SOAP_TYPE__pass__AOI_USCORErectangle:
		if (p->size < 0)
			SOAP_DELETE((_pass__AOI_USCORErectangle*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_pass__AOI_USCORErectangle*)p->ptr);
		break;
	case SOAP_TYPE__pass__References_ReferenceObj:
		if (p->size < 0)
			SOAP_DELETE((_pass__References_ReferenceObj*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_pass__References_ReferenceObj*)p->ptr);
		break;
	case SOAP_TYPE__pass__References:
		if (p->size < 0)
			SOAP_DELETE((_pass__References*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_pass__References*)p->ptr);
		break;
	case SOAP_TYPE__pass__publish:
		if (p->size < 0)
			SOAP_DELETE((_pass__publish*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_pass__publish*)p->ptr);
		break;
	case SOAP_TYPE__pass__retract_USCOREitem:
		if (p->size < 0)
			SOAP_DELETE((_pass__retract_USCOREitem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_pass__retract_USCOREitem*)p->ptr);
		break;
	case SOAP_TYPE__pass__retract_USCOREtopic:
		if (p->size < 0)
			SOAP_DELETE((_pass__retract_USCOREtopic*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_pass__retract_USCOREtopic*)p->ptr);
		break;
	case SOAP_TYPE__pass__unsubscribe:
		if (p->size < 0)
			SOAP_DELETE((_pass__unsubscribe*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_pass__unsubscribe*)p->ptr);
		break;
	case SOAP_TYPE__pass__subscribe:
		if (p->size < 0)
			SOAP_DELETE((_pass__subscribe*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_pass__subscribe*)p->ptr);
		break;
	case SOAP_TYPE__pass__sync:
		if (p->size < 0)
			SOAP_DELETE((_pass__sync*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_pass__sync*)p->ptr);
		break;
	case SOAP_TYPE__pass__sync_USCOREresponse:
		if (p->size < 0)
			SOAP_DELETE((_pass__sync_USCOREresponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_pass__sync_USCOREresponse*)p->ptr);
		break;
	case SOAP_TYPE__pass__create_USCOREtopic:
		if (p->size < 0)
			SOAP_DELETE((_pass__create_USCOREtopic*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_pass__create_USCOREtopic*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
	case SOAP_TYPE___ns1__subscribe:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__subscribe*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__subscribe*)p->ptr);
		break;
	case SOAP_TYPE___ns1__retract_USCOREitem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__retract_USCOREitem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__retract_USCOREitem*)p->ptr);
		break;
	case SOAP_TYPE___ns1__retract_USCOREtopic:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__retract_USCOREtopic*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__retract_USCOREtopic*)p->ptr);
		break;
	case SOAP_TYPE___ns1__unsubscribe:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__unsubscribe*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__unsubscribe*)p->ptr);
		break;
	case SOAP_TYPE___ns1__publish:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__publish*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__publish*)p->ptr);
		break;
	case SOAP_TYPE___ns1__create_USCOREtopic:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__create_USCOREtopic*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__create_USCOREtopic*)p->ptr);
		break;
	case SOAP_TYPE___ns1__sync:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__sync*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__sync*)p->ptr);
		break;
	case SOAP_TYPE___ns2__publish:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__publish*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__publish*)p->ptr);
		break;
	case SOAP_TYPE___ns2__retract_USCOREitem:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__retract_USCOREitem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__retract_USCOREitem*)p->ptr);
		break;
	case SOAP_TYPE___ns2__retract_USCOREtopic:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__retract_USCOREtopic*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__retract_USCOREtopic*)p->ptr);
		break;
	case SOAP_TYPE___ns2__unsubscribe:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__unsubscribe*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__unsubscribe*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE((struct soap_dom_element*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct soap_dom_element*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyAttribute:
		if (p->size < 0)
			SOAP_DELETE((struct soap_dom_attribute*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct soap_dom_attribute*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_pass__latitude:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_pass__longitude:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_pass__item_USCORETTL:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_pass__subscribe:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_pass__subscribe * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_pass__subscribe * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic:
		if (p->size < 0)
			SOAP_DELETE((std::vector<_pass__create_USCOREtopic * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<_pass__create_USCOREtopic * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTopass__item:
		if (p->size < 0)
			SOAP_DELETE((std::vector<pass__item * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<pass__item * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_pass__subscribe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_pass__subscribe * >*)p)[len] = *(_pass__subscribe **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_pass__create_USCOREtopic * >*)p)[len] = *(_pass__create_USCOREtopic **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTopass__item:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<pass__item * >*)p)[len] = *(pass__item **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__pass__create_USCOREtopic_publish_USCOREmode(struct soap *soap, enum _pass__create_USCOREtopic_publish_USCOREmode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__pass__create_USCOREtopic_publish_USCOREmode
	*a = SOAP_DEFAULT__pass__create_USCOREtopic_publish_USCOREmode;
#else
	*a = (enum _pass__create_USCOREtopic_publish_USCOREmode)0;
#endif
}

static const struct soap_code_map soap_codes__pass__create_USCOREtopic_publish_USCOREmode[] =
{	{ (long)_pass__create_USCOREtopic_publish_USCOREmode__locked, "locked" },
	{ (long)_pass__create_USCOREtopic_publish_USCOREmode__open, "open" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__pass__create_USCOREtopic_publish_USCOREmode2s(struct soap *soap, enum _pass__create_USCOREtopic_publish_USCOREmode n)
{	const char *s = soap_code_str(soap_codes__pass__create_USCOREtopic_publish_USCOREmode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__create_USCOREtopic_publish_USCOREmode(struct soap *soap, const char *tag, int id, const enum _pass__create_USCOREtopic_publish_USCOREmode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__create_USCOREtopic_publish_USCOREmode), type) || soap_send(soap, soap__pass__create_USCOREtopic_publish_USCOREmode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_pass__create_USCOREtopic_publish_USCOREmode(struct soap *soap, const char *s, enum _pass__create_USCOREtopic_publish_USCOREmode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__pass__create_USCOREtopic_publish_USCOREmode, s);
	if (map)
		*a = (enum _pass__create_USCOREtopic_publish_USCOREmode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _pass__create_USCOREtopic_publish_USCOREmode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _pass__create_USCOREtopic_publish_USCOREmode * SOAP_FMAC4 soap_in__pass__create_USCOREtopic_publish_USCOREmode(struct soap *soap, const char *tag, enum _pass__create_USCOREtopic_publish_USCOREmode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _pass__create_USCOREtopic_publish_USCOREmode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__pass__create_USCOREtopic_publish_USCOREmode, sizeof(enum _pass__create_USCOREtopic_publish_USCOREmode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_pass__create_USCOREtopic_publish_USCOREmode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _pass__create_USCOREtopic_publish_USCOREmode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__create_USCOREtopic_publish_USCOREmode, 0, sizeof(enum _pass__create_USCOREtopic_publish_USCOREmode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__pass__create_USCOREtopic_publish_USCOREmode(struct soap *soap, const enum _pass__create_USCOREtopic_publish_USCOREmode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__pass__create_USCOREtopic_publish_USCOREmode);
	if (soap_out__pass__create_USCOREtopic_publish_USCOREmode(soap, tag?tag:"pass:create_topic-publish_mode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _pass__create_USCOREtopic_publish_USCOREmode * SOAP_FMAC4 soap_get__pass__create_USCOREtopic_publish_USCOREmode(struct soap *soap, enum _pass__create_USCOREtopic_publish_USCOREmode *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__create_USCOREtopic_publish_USCOREmode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__pass__item_USCOREdata_item_USCOREdata_USCOREclassification(struct soap *soap, enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__pass__item_USCOREdata_item_USCOREdata_USCOREclassification
	*a = SOAP_DEFAULT__pass__item_USCOREdata_item_USCOREdata_USCOREclassification;
#else
	*a = (enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification)0;
#endif
}

static const struct soap_code_map soap_codes__pass__item_USCOREdata_item_USCOREdata_USCOREclassification[] =
{	{ (long)_pass__item_USCOREdata_item_USCOREdata_USCOREclassification__SECRET, "SECRET" },
	{ (long)_pass__item_USCOREdata_item_USCOREdata_USCOREclassification__CONFIDENTIAL, "CONFIDENTIAL" },
	{ (long)_pass__item_USCOREdata_item_USCOREdata_USCOREclassification__UNCLASSIFIED, "UNCLASSIFIED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__pass__item_USCOREdata_item_USCOREdata_USCOREclassification2s(struct soap *soap, enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification n)
{	const char *s = soap_code_str(soap_codes__pass__item_USCOREdata_item_USCOREdata_USCOREclassification, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__item_USCOREdata_item_USCOREdata_USCOREclassification(struct soap *soap, const char *tag, int id, const enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__item_USCOREdata_item_USCOREdata_USCOREclassification), type) || soap_send(soap, soap__pass__item_USCOREdata_item_USCOREdata_USCOREclassification2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_pass__item_USCOREdata_item_USCOREdata_USCOREclassification(struct soap *soap, const char *s, enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__pass__item_USCOREdata_item_USCOREdata_USCOREclassification, s);
	if (map)
		*a = (enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification * SOAP_FMAC4 soap_in__pass__item_USCOREdata_item_USCOREdata_USCOREclassification(struct soap *soap, const char *tag, enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__pass__item_USCOREdata_item_USCOREdata_USCOREclassification, sizeof(enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_pass__item_USCOREdata_item_USCOREdata_USCOREclassification(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__item_USCOREdata_item_USCOREdata_USCOREclassification, 0, sizeof(enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__pass__item_USCOREdata_item_USCOREdata_USCOREclassification(struct soap *soap, const enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__pass__item_USCOREdata_item_USCOREdata_USCOREclassification);
	if (soap_out__pass__item_USCOREdata_item_USCOREdata_USCOREclassification(soap, tag?tag:"pass:item_data-item_data_classification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification * SOAP_FMAC4 soap_get__pass__item_USCOREdata_item_USCOREdata_USCOREclassification(struct soap *soap, enum _pass__item_USCOREdata_item_USCOREdata_USCOREclassification *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__item_USCOREdata_item_USCOREdata_USCOREclassification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__pass__status_status_USCOREcode(struct soap *soap, enum _pass__status_status_USCOREcode *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__pass__status_status_USCOREcode
	*a = SOAP_DEFAULT__pass__status_status_USCOREcode;
#else
	*a = (enum _pass__status_status_USCOREcode)0;
#endif
}

static const struct soap_code_map soap_codes__pass__status_status_USCOREcode[] =
{	{ (long)_pass__status_status_USCOREcode__1000, "1000" },
	{ (long)_pass__status_status_USCOREcode__1100, "1100" },
	{ (long)_pass__status_status_USCOREcode__1101, "1101" },
	{ (long)_pass__status_status_USCOREcode__1102, "1102" },
	{ (long)_pass__status_status_USCOREcode__1103, "1103" },
	{ (long)_pass__status_status_USCOREcode__1104, "1104" },
	{ (long)_pass__status_status_USCOREcode__1105, "1105" },
	{ (long)_pass__status_status_USCOREcode__1106, "1106" },
	{ (long)_pass__status_status_USCOREcode__1107, "1107" },
	{ (long)_pass__status_status_USCOREcode__1108, "1108" },
	{ (long)_pass__status_status_USCOREcode__1109, "1109" },
	{ (long)_pass__status_status_USCOREcode__1110, "1110" },
	{ (long)_pass__status_status_USCOREcode__1111, "1111" },
	{ (long)_pass__status_status_USCOREcode__1200, "1200" },
	{ (long)_pass__status_status_USCOREcode__1201, "1201" },
	{ (long)_pass__status_status_USCOREcode__1202, "1202" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__pass__status_status_USCOREcode2s(struct soap *soap, enum _pass__status_status_USCOREcode n)
{	const char *s = soap_code_str(soap_codes__pass__status_status_USCOREcode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__status_status_USCOREcode(struct soap *soap, const char *tag, int id, const enum _pass__status_status_USCOREcode *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__status_status_USCOREcode), type) || soap_send(soap, soap__pass__status_status_USCOREcode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_pass__status_status_USCOREcode(struct soap *soap, const char *s, enum _pass__status_status_USCOREcode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__pass__status_status_USCOREcode, s);
	if (map)
		*a = (enum _pass__status_status_USCOREcode)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1202)))
			return soap->error = SOAP_TYPE;
		*a = (enum _pass__status_status_USCOREcode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _pass__status_status_USCOREcode * SOAP_FMAC4 soap_in__pass__status_status_USCOREcode(struct soap *soap, const char *tag, enum _pass__status_status_USCOREcode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _pass__status_status_USCOREcode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__pass__status_status_USCOREcode, sizeof(enum _pass__status_status_USCOREcode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_pass__status_status_USCOREcode(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _pass__status_status_USCOREcode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__status_status_USCOREcode, 0, sizeof(enum _pass__status_status_USCOREcode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__pass__status_status_USCOREcode(struct soap *soap, const enum _pass__status_status_USCOREcode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__pass__status_status_USCOREcode);
	if (soap_out__pass__status_status_USCOREcode(soap, tag?tag:"pass:status-status_code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _pass__status_status_USCOREcode * SOAP_FMAC4 soap_get__pass__status_status_USCOREcode(struct soap *soap, enum _pass__status_status_USCOREcode *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__status_status_USCOREcode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__pass__status_command(struct soap *soap, enum _pass__status_command *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__pass__status_command
	*a = SOAP_DEFAULT__pass__status_command;
#else
	*a = (enum _pass__status_command)0;
#endif
}

static const struct soap_code_map soap_codes__pass__status_command[] =
{	{ (long)_pass__status_command__create_USCOREtopic, "create_topic" },
	{ (long)_pass__status_command__sync, "sync" },
	{ (long)_pass__status_command__publish, "publish" },
	{ (long)_pass__status_command__subscribe, "subscribe" },
	{ (long)_pass__status_command__unsubscribe, "unsubscribe" },
	{ (long)_pass__status_command__retract_USCOREtopic, "retract_topic" },
	{ (long)_pass__status_command__retract_USCOREitem, "retract_item" },
	{ (long)_pass__status_command__unknown, "unknown" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__pass__status_command2s(struct soap *soap, enum _pass__status_command n)
{	const char *s = soap_code_str(soap_codes__pass__status_command, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__status_command(struct soap *soap, const char *tag, int id, const enum _pass__status_command *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__status_command), type) || soap_send(soap, soap__pass__status_command2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_pass__status_command(struct soap *soap, const char *s, enum _pass__status_command *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__pass__status_command, s);
	if (map)
		*a = (enum _pass__status_command)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 7)))
			return soap->error = SOAP_TYPE;
		*a = (enum _pass__status_command)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _pass__status_command * SOAP_FMAC4 soap_in__pass__status_command(struct soap *soap, const char *tag, enum _pass__status_command *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _pass__status_command *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__pass__status_command, sizeof(enum _pass__status_command), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_pass__status_command(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _pass__status_command *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__status_command, 0, sizeof(enum _pass__status_command), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__pass__status_command(struct soap *soap, const enum _pass__status_command *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__pass__status_command);
	if (soap_out__pass__status_command(soap, tag?tag:"pass:status-command", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _pass__status_command * SOAP_FMAC4 soap_get__pass__status_command(struct soap *soap, enum _pass__status_command *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__status_command(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xlink__actuate(struct soap *soap, enum _xlink__actuate *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__xlink__actuate
	*a = SOAP_DEFAULT__xlink__actuate;
#else
	*a = (enum _xlink__actuate)0;
#endif
}

static const struct soap_code_map soap_codes__xlink__actuate[] =
{	{ (long)_xlink__actuate__onLoad, "onLoad" },
	{ (long)_xlink__actuate__onRequest, "onRequest" },
	{ (long)_xlink__actuate__other, "other" },
	{ (long)_xlink__actuate__none, "none" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__xlink__actuate2s(struct soap *soap, enum _xlink__actuate n)
{	const char *s = soap_code_str(soap_codes__xlink__actuate, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xlink__actuate(struct soap *soap, const char *tag, int id, const enum _xlink__actuate *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xlink__actuate), type) || soap_send(soap, soap__xlink__actuate2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_xlink__actuate(struct soap *soap, const char *s, enum _xlink__actuate *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__xlink__actuate, s);
	if (map)
		*a = (enum _xlink__actuate)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum _xlink__actuate)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _xlink__actuate * SOAP_FMAC4 soap_in__xlink__actuate(struct soap *soap, const char *tag, enum _xlink__actuate *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _xlink__actuate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xlink__actuate, sizeof(enum _xlink__actuate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_xlink__actuate(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _xlink__actuate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xlink__actuate, 0, sizeof(enum _xlink__actuate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xlink__actuate(struct soap *soap, const enum _xlink__actuate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__xlink__actuate);
	if (soap_out__xlink__actuate(soap, tag?tag:"xlink:actuate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _xlink__actuate * SOAP_FMAC4 soap_get__xlink__actuate(struct soap *soap, enum _xlink__actuate *p, const char *tag, const char *type)
{
	if ((p = soap_in__xlink__actuate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xlink__show(struct soap *soap, enum _xlink__show *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__xlink__show
	*a = SOAP_DEFAULT__xlink__show;
#else
	*a = (enum _xlink__show)0;
#endif
}

static const struct soap_code_map soap_codes__xlink__show[] =
{	{ (long)_xlink__show__new_, "new" },
	{ (long)_xlink__show__replace, "replace" },
	{ (long)_xlink__show__embed, "embed" },
	{ (long)_xlink__show__other, "other" },
	{ (long)_xlink__show__none, "none" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__xlink__show2s(struct soap *soap, enum _xlink__show n)
{	const char *s = soap_code_str(soap_codes__xlink__show, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xlink__show(struct soap *soap, const char *tag, int id, const enum _xlink__show *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xlink__show), type) || soap_send(soap, soap__xlink__show2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_xlink__show(struct soap *soap, const char *s, enum _xlink__show *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__xlink__show, s);
	if (map)
		*a = (enum _xlink__show)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum _xlink__show)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _xlink__show * SOAP_FMAC4 soap_in__xlink__show(struct soap *soap, const char *tag, enum _xlink__show *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _xlink__show *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xlink__show, sizeof(enum _xlink__show), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_xlink__show(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _xlink__show *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xlink__show, 0, sizeof(enum _xlink__show), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xlink__show(struct soap *soap, const enum _xlink__show *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__xlink__show);
	if (soap_out__xlink__show(soap, tag?tag:"xlink:show", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _xlink__show * SOAP_FMAC4 soap_get__xlink__show(struct soap *soap, enum _xlink__show *p, const char *tag, const char *type)
{
	if ((p = soap_in__xlink__show(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _pass__References_ReferenceObj::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_pass__References_ReferenceObj::xlink__type = NULL;
	this->_pass__References_ReferenceObj::xlink__href = NULL;
	this->_pass__References_ReferenceObj::xlink__role = NULL;
	this->_pass__References_ReferenceObj::xlink__arcrole = NULL;
	this->_pass__References_ReferenceObj::xlink__title = NULL;
	this->_pass__References_ReferenceObj::xlink__show = NULL;
	this->_pass__References_ReferenceObj::xlink__actuate = NULL;
	soap_default_xsd__anyType(soap, &this->_pass__References_ReferenceObj::__mixed);
}

void _pass__References_ReferenceObj::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyType(soap, &this->_pass__References_ReferenceObj::__mixed);
}

int _pass__References_ReferenceObj::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__pass__References_ReferenceObj(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__References_ReferenceObj(struct soap *soap, const char *tag, int id, const _pass__References_ReferenceObj *a, const char *type)
{
	if (((_pass__References_ReferenceObj*)a)->xlink__type)
		soap_set_attr(soap, "xlink:type", ((_pass__References_ReferenceObj*)a)->xlink__type->c_str(), 1);
	if (((_pass__References_ReferenceObj*)a)->xlink__href)
		soap_set_attr(soap, "xlink:href", ((_pass__References_ReferenceObj*)a)->xlink__href->c_str(), 1);
	if (((_pass__References_ReferenceObj*)a)->xlink__role)
		soap_set_attr(soap, "xlink:role", ((_pass__References_ReferenceObj*)a)->xlink__role->c_str(), 1);
	if (((_pass__References_ReferenceObj*)a)->xlink__arcrole)
		soap_set_attr(soap, "xlink:arcrole", ((_pass__References_ReferenceObj*)a)->xlink__arcrole->c_str(), 1);
	if (((_pass__References_ReferenceObj*)a)->xlink__title)
		soap_set_attr(soap, "xlink:title", ((_pass__References_ReferenceObj*)a)->xlink__title->c_str(), 1);
	if (((_pass__References_ReferenceObj*)a)->xlink__show)
		soap_set_attr(soap, "xlink:show", soap__xlink__show2s(soap, *((_pass__References_ReferenceObj*)a)->xlink__show), 1);
	if (((_pass__References_ReferenceObj*)a)->xlink__actuate)
		soap_set_attr(soap, "xlink:actuate", soap__xlink__actuate2s(soap, *((_pass__References_ReferenceObj*)a)->xlink__actuate), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__References_ReferenceObj), type))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-mixed", -1, &(a->_pass__References_ReferenceObj::__mixed), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_pass__References_ReferenceObj::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__pass__References_ReferenceObj(soap, tag, this, type);
}

SOAP_FMAC3 _pass__References_ReferenceObj * SOAP_FMAC4 soap_in__pass__References_ReferenceObj(struct soap *soap, const char *tag, _pass__References_ReferenceObj *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_pass__References_ReferenceObj *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__pass__References_ReferenceObj, sizeof(_pass__References_ReferenceObj), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__pass__References_ReferenceObj)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_pass__References_ReferenceObj *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "xlink:type", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_pass__References_ReferenceObj*)a)->xlink__type = soap_new_std__string(soap, -1);
				((_pass__References_ReferenceObj*)a)->xlink__type->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xlink:href", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_pass__References_ReferenceObj*)a)->xlink__href = soap_new_std__string(soap, -1);
				((_pass__References_ReferenceObj*)a)->xlink__href->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xlink:role", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_pass__References_ReferenceObj*)a)->xlink__role = soap_new_std__string(soap, -1);
				((_pass__References_ReferenceObj*)a)->xlink__role->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xlink:arcrole", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_pass__References_ReferenceObj*)a)->xlink__arcrole = soap_new_std__string(soap, -1);
				((_pass__References_ReferenceObj*)a)->xlink__arcrole->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xlink:title", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_pass__References_ReferenceObj*)a)->xlink__title = soap_new_std__string(soap, -1);
				((_pass__References_ReferenceObj*)a)->xlink__title->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xlink:show", 0);
		if (t)
		{
			if (!(((_pass__References_ReferenceObj*)a)->xlink__show = (enum _xlink__show *)soap_malloc(soap, sizeof(enum _xlink__show))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_xlink__show(soap, t, ((_pass__References_ReferenceObj*)a)->xlink__show))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "xlink:actuate", 0);
		if (t)
		{
			if (!(((_pass__References_ReferenceObj*)a)->xlink__actuate = (enum _xlink__actuate *)soap_malloc(soap, sizeof(enum _xlink__actuate))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_xlink__actuate(soap, t, ((_pass__References_ReferenceObj*)a)->xlink__actuate))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___mixed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-mixed", &(a->_pass__References_ReferenceObj::__mixed), "xsd:anyType"))
				{	soap_flag___mixed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_pass__References_ReferenceObj *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__References_ReferenceObj, 0, sizeof(_pass__References_ReferenceObj), 0, soap_copy__pass__References_ReferenceObj);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _pass__References_ReferenceObj::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__pass__References_ReferenceObj);
	if (this->soap_out(soap, tag?tag:"pass:References-ReferenceObj", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_pass__References_ReferenceObj::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__pass__References_ReferenceObj(soap, this, tag, type);
}

SOAP_FMAC3 _pass__References_ReferenceObj * SOAP_FMAC4 soap_get__pass__References_ReferenceObj(struct soap *soap, _pass__References_ReferenceObj *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__References_ReferenceObj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _pass__References_ReferenceObj * SOAP_FMAC2 soap_instantiate__pass__References_ReferenceObj(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__pass__References_ReferenceObj(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__pass__References_ReferenceObj, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_pass__References_ReferenceObj);
		if (size)
			*size = sizeof(_pass__References_ReferenceObj);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_pass__References_ReferenceObj[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_pass__References_ReferenceObj);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_pass__References_ReferenceObj*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__pass__References_ReferenceObj(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _pass__References_ReferenceObj %p -> %p\n", q, p));
	*(_pass__References_ReferenceObj*)p = *(_pass__References_ReferenceObj*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_pass__item_USCORETTL(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_pass__item_USCORETTL), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_pass__item_USCORETTL(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_pass__item_USCORETTL, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_pass__item_USCORETTL, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_pass__item_USCORETTL, 0, sizeof(std::string), 0, soap_copy_pass__item_USCORETTL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pass__item_USCORETTL(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pass__item_USCORETTL);
	if (soap_out_pass__item_USCORETTL(soap, tag?tag:"pass:item_TTL", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_pass__item_USCORETTL(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_pass__item_USCORETTL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_pass__longitude(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_pass__longitude), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_pass__longitude(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_pass__longitude, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_pass__longitude, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_pass__longitude, 0, sizeof(std::string), 0, soap_copy_pass__longitude);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pass__longitude(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pass__longitude);
	if (soap_out_pass__longitude(soap, tag?tag:"pass:longitude", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_pass__longitude(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_pass__longitude(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_pass__latitude(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_pass__latitude), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_pass__latitude(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_pass__latitude, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_pass__latitude, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_pass__latitude, 0, sizeof(std::string), 0, soap_copy_pass__latitude);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_pass__latitude(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_pass__latitude);
	if (soap_out_pass__latitude(soap, tag?tag:"pass:latitude", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_pass__latitude(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_pass__latitude(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _pass__create_USCOREtopic::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_pass__create_USCOREtopic::description = NULL;
	this->_pass__create_USCOREtopic::publish_USCOREmode = (enum _pass__create_USCOREtopic_publish_USCOREmode)0;
	this->_pass__create_USCOREtopic::retractable = (bool)1;
	soap_default_std__string(soap, &this->_pass__create_USCOREtopic::topic);
	soap_default_std__string(soap, &this->_pass__create_USCOREtopic::owner_USCOREid);
	/* transient soap skipped */
}

void _pass__create_USCOREtopic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_pass__create_USCOREtopic::description);
	/* transient soap skipped */
}

int _pass__create_USCOREtopic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__pass__create_USCOREtopic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__create_USCOREtopic(struct soap *soap, const char *tag, int id, const _pass__create_USCOREtopic *a, const char *type)
{
	soap_set_attr(soap, "publish_mode", soap__pass__create_USCOREtopic_publish_USCOREmode2s(soap, ((_pass__create_USCOREtopic*)a)->publish_USCOREmode), 1);
	soap_set_attr(soap, "retractable", soap_bool2s(soap, ((_pass__create_USCOREtopic*)a)->retractable), 1);
	if (!((_pass__create_USCOREtopic*)a)->topic.empty())
		soap_set_attr(soap, "topic", ((_pass__create_USCOREtopic*)a)->topic.c_str(), 1);
	if (!((_pass__create_USCOREtopic*)a)->owner_USCOREid.empty())
		soap_set_attr(soap, "owner_id", ((_pass__create_USCOREtopic*)a)->owner_USCOREid.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__create_USCOREtopic), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "pass:description", -1, &(a->_pass__create_USCOREtopic::description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_pass__create_USCOREtopic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__pass__create_USCOREtopic(soap, tag, this, type);
}

SOAP_FMAC3 _pass__create_USCOREtopic * SOAP_FMAC4 soap_in__pass__create_USCOREtopic(struct soap *soap, const char *tag, _pass__create_USCOREtopic *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_pass__create_USCOREtopic *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__pass__create_USCOREtopic, sizeof(_pass__create_USCOREtopic), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__pass__create_USCOREtopic)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_pass__create_USCOREtopic *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2_pass__create_USCOREtopic_publish_USCOREmode(soap, soap_attr_value(soap, "publish_mode", 0), &((_pass__create_USCOREtopic*)a)->publish_USCOREmode))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "retractable", 0), &((_pass__create_USCOREtopic*)a)->retractable))
		return NULL;
	{	const char *t = soap_attr_value(soap, "topic", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__create_USCOREtopic*)a)->topic.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "owner_id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__create_USCOREtopic*)a)->owner_USCOREid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "pass:description", &(a->_pass__create_USCOREtopic::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_pass__create_USCOREtopic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__create_USCOREtopic, 0, sizeof(_pass__create_USCOREtopic), 0, soap_copy__pass__create_USCOREtopic);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _pass__create_USCOREtopic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__pass__create_USCOREtopic);
	if (this->soap_out(soap, tag?tag:"pass:create_topic", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_pass__create_USCOREtopic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__pass__create_USCOREtopic(soap, this, tag, type);
}

SOAP_FMAC3 _pass__create_USCOREtopic * SOAP_FMAC4 soap_get__pass__create_USCOREtopic(struct soap *soap, _pass__create_USCOREtopic *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__create_USCOREtopic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _pass__create_USCOREtopic * SOAP_FMAC2 soap_instantiate__pass__create_USCOREtopic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__pass__create_USCOREtopic(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__pass__create_USCOREtopic, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_pass__create_USCOREtopic);
		if (size)
			*size = sizeof(_pass__create_USCOREtopic);
		((_pass__create_USCOREtopic*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_pass__create_USCOREtopic[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_pass__create_USCOREtopic);
		for (int i = 0; i < n; i++)
			((_pass__create_USCOREtopic*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_pass__create_USCOREtopic*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__pass__create_USCOREtopic(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _pass__create_USCOREtopic %p -> %p\n", q, p));
	*(_pass__create_USCOREtopic*)p = *(_pass__create_USCOREtopic*)q;
}

void _pass__sync_USCOREresponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_pass__sync_USCOREresponse::status = NULL;
	this->_pass__sync_USCOREresponse::__union_sync_USCOREresponse = 0;
	/* transient soap skipped */
}

void _pass__sync_USCOREresponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTopass__status(soap, &this->_pass__sync_USCOREresponse::status);
	soap_serialize__pass__union_sync_USCOREresponse(soap, this->_pass__sync_USCOREresponse::__union_sync_USCOREresponse, &this->_pass__sync_USCOREresponse::union_sync_USCOREresponse);
	/* transient soap skipped */
}

int _pass__sync_USCOREresponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__pass__sync_USCOREresponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__sync_USCOREresponse(struct soap *soap, const char *tag, int id, const _pass__sync_USCOREresponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__sync_USCOREresponse), type))
		return soap->error;
	if (a->status)
		soap_element_result(soap, "pass:status");
	if (soap_out_PointerTopass__status(soap, "pass:status", -1, &(a->_pass__sync_USCOREresponse::status), ""))
		return soap->error;
	if (soap_out__pass__union_sync_USCOREresponse(soap, a->_pass__sync_USCOREresponse::__union_sync_USCOREresponse, &a->_pass__sync_USCOREresponse::union_sync_USCOREresponse))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_pass__sync_USCOREresponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__pass__sync_USCOREresponse(soap, tag, this, type);
}

SOAP_FMAC3 _pass__sync_USCOREresponse * SOAP_FMAC4 soap_in__pass__sync_USCOREresponse(struct soap *soap, const char *tag, _pass__sync_USCOREresponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_pass__sync_USCOREresponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__pass__sync_USCOREresponse, sizeof(_pass__sync_USCOREresponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__pass__sync_USCOREresponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_pass__sync_USCOREresponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_status1 = 1;
	size_t soap_flag_union_sync_USCOREresponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTopass__status(soap, "pass:status", &(a->_pass__sync_USCOREresponse::status), "pass:status"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_union_sync_USCOREresponse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__pass__union_sync_USCOREresponse(soap, &a->_pass__sync_USCOREresponse::__union_sync_USCOREresponse, &a->_pass__sync_USCOREresponse::union_sync_USCOREresponse))
				{	soap_flag_union_sync_USCOREresponse1 = 0;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "pass:status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_pass__sync_USCOREresponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__sync_USCOREresponse, 0, sizeof(_pass__sync_USCOREresponse), 0, soap_copy__pass__sync_USCOREresponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1 > 0 || soap_flag_union_sync_USCOREresponse1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _pass__sync_USCOREresponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__pass__sync_USCOREresponse);
	if (this->soap_out(soap, tag?tag:"pass:sync_response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_pass__sync_USCOREresponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__pass__sync_USCOREresponse(soap, this, tag, type);
}

SOAP_FMAC3 _pass__sync_USCOREresponse * SOAP_FMAC4 soap_get__pass__sync_USCOREresponse(struct soap *soap, _pass__sync_USCOREresponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__sync_USCOREresponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _pass__sync_USCOREresponse * SOAP_FMAC2 soap_instantiate__pass__sync_USCOREresponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__pass__sync_USCOREresponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__pass__sync_USCOREresponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_pass__sync_USCOREresponse);
		if (size)
			*size = sizeof(_pass__sync_USCOREresponse);
		((_pass__sync_USCOREresponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_pass__sync_USCOREresponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_pass__sync_USCOREresponse);
		for (int i = 0; i < n; i++)
			((_pass__sync_USCOREresponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_pass__sync_USCOREresponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__pass__sync_USCOREresponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _pass__sync_USCOREresponse %p -> %p\n", q, p));
	*(_pass__sync_USCOREresponse*)p = *(_pass__sync_USCOREresponse*)q;
}

void _pass__sync::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_pass__sync::AOI_USCORErectangle = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_pass__sync::item_USCOREid);
	this->_pass__sync::since_USCOREdtg = NULL;
	soap_default_std__string(soap, &this->_pass__sync::topic);
	soap_default_std__string(soap, &this->_pass__sync::requester_USCOREid);
	this->_pass__sync::compression = (bool)0;
	this->_pass__sync::xpath_USCOREfilter = NULL;
	this->_pass__sync::item_USCOREid_USCOREonly = (bool)0;
	/* transient soap skipped */
}

void _pass__sync::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__AOI_USCORErectangle(soap, &this->_pass__sync::AOI_USCORErectangle);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_pass__sync::item_USCOREid);
	/* transient soap skipped */
}

int _pass__sync::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__pass__sync(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__sync(struct soap *soap, const char *tag, int id, const _pass__sync *a, const char *type)
{
	if (((_pass__sync*)a)->since_USCOREdtg)
		soap_set_attr(soap, "since_dtg", soap_dateTime2s(soap, *((_pass__sync*)a)->since_USCOREdtg), 1);
	if (!((_pass__sync*)a)->topic.empty())
		soap_set_attr(soap, "topic", ((_pass__sync*)a)->topic.c_str(), 1);
	if (!((_pass__sync*)a)->requester_USCOREid.empty())
		soap_set_attr(soap, "requester_id", ((_pass__sync*)a)->requester_USCOREid.c_str(), 1);
	soap_set_attr(soap, "compression", soap_bool2s(soap, ((_pass__sync*)a)->compression), 1);
	if (((_pass__sync*)a)->xpath_USCOREfilter)
		soap_set_attr(soap, "xpath_filter", ((_pass__sync*)a)->xpath_USCOREfilter->c_str(), 1);
	soap_set_attr(soap, "item_id_only", soap_bool2s(soap, ((_pass__sync*)a)->item_USCOREid_USCOREonly), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__sync), type))
		return soap->error;
	if (soap_out_PointerTo_pass__AOI_USCORErectangle(soap, "pass:AOI_rectangle", -1, &(a->_pass__sync::AOI_USCORErectangle), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "pass:item_id", -1, &(a->_pass__sync::item_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_pass__sync::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__pass__sync(soap, tag, this, type);
}

SOAP_FMAC3 _pass__sync * SOAP_FMAC4 soap_in__pass__sync(struct soap *soap, const char *tag, _pass__sync *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_pass__sync *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__pass__sync, sizeof(_pass__sync), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__pass__sync)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_pass__sync *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "since_dtg", 0);
		if (t)
		{
			if (!(((_pass__sync*)a)->since_USCOREdtg = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, ((_pass__sync*)a)->since_USCOREdtg))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "topic", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__sync*)a)->topic.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "requester_id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__sync*)a)->requester_USCOREid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "compression", 0), &((_pass__sync*)a)->compression))
		return NULL;
	{	const char *t = soap_attr_value(soap, "xpath_filter", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_pass__sync*)a)->xpath_USCOREfilter = soap_new_std__string(soap, -1);
				((_pass__sync*)a)->xpath_USCOREfilter->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "item_id_only", 0), &((_pass__sync*)a)->item_USCOREid_USCOREonly))
		return NULL;
	size_t soap_flag_AOI_USCORErectangle1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AOI_USCORErectangle1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__AOI_USCORErectangle(soap, "pass:AOI_rectangle", &(a->_pass__sync::AOI_USCORErectangle), ""))
				{	soap_flag_AOI_USCORErectangle1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "pass:item_id", &(a->_pass__sync::item_USCOREid), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_pass__sync *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__sync, 0, sizeof(_pass__sync), 0, soap_copy__pass__sync);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _pass__sync::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__pass__sync);
	if (this->soap_out(soap, tag?tag:"pass:sync", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_pass__sync::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__pass__sync(soap, this, tag, type);
}

SOAP_FMAC3 _pass__sync * SOAP_FMAC4 soap_get__pass__sync(struct soap *soap, _pass__sync *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__sync(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _pass__sync * SOAP_FMAC2 soap_instantiate__pass__sync(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__pass__sync(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__pass__sync, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_pass__sync);
		if (size)
			*size = sizeof(_pass__sync);
		((_pass__sync*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_pass__sync[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_pass__sync);
		for (int i = 0; i < n; i++)
			((_pass__sync*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_pass__sync*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__pass__sync(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _pass__sync %p -> %p\n", q, p));
	*(_pass__sync*)p = *(_pass__sync*)q;
}

void _pass__subscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_pass__subscribe::return_USCOREaddress);
	this->_pass__subscribe::AOI_USCORErectangle = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_pass__subscribe::item_USCOREid);
	this->_pass__subscribe::duration_USCOREsecs = NULL;
	this->_pass__subscribe::subscription_USCOREid = NULL;
	soap_default_std__string(soap, &this->_pass__subscribe::topic);
	soap_default_std__string(soap, &this->_pass__subscribe::subscriber_USCOREid);
	this->_pass__subscribe::compression = (bool)0;
	/* transient soap skipped */
}

void _pass__subscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_pass__subscribe::return_USCOREaddress, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->_pass__subscribe::return_USCOREaddress);
	soap_serialize_PointerTo_pass__AOI_USCORErectangle(soap, &this->_pass__subscribe::AOI_USCORErectangle);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_pass__subscribe::item_USCOREid);
	/* transient soap skipped */
}

int _pass__subscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__pass__subscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__subscribe(struct soap *soap, const char *tag, int id, const _pass__subscribe *a, const char *type)
{
	if (((_pass__subscribe*)a)->duration_USCOREsecs)
		soap_set_attr(soap, "duration_secs", ((_pass__subscribe*)a)->duration_USCOREsecs->c_str(), 1);
	if (((_pass__subscribe*)a)->subscription_USCOREid)
		soap_set_attr(soap, "subscription_id", ((_pass__subscribe*)a)->subscription_USCOREid->c_str(), 1);
	if (!((_pass__subscribe*)a)->topic.empty())
		soap_set_attr(soap, "topic", ((_pass__subscribe*)a)->topic.c_str(), 1);
	if (!((_pass__subscribe*)a)->subscriber_USCOREid.empty())
		soap_set_attr(soap, "subscriber_id", ((_pass__subscribe*)a)->subscriber_USCOREid.c_str(), 1);
	soap_set_attr(soap, "compression", soap_bool2s(soap, ((_pass__subscribe*)a)->compression), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__subscribe), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "pass:return_address", -1, &(a->_pass__subscribe::return_USCOREaddress), ""))
		return soap->error;
	if (soap_out_PointerTo_pass__AOI_USCORErectangle(soap, "pass:AOI_rectangle", -1, &(a->_pass__subscribe::AOI_USCORErectangle), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "pass:item_id", -1, &(a->_pass__subscribe::item_USCOREid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_pass__subscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__pass__subscribe(soap, tag, this, type);
}

SOAP_FMAC3 _pass__subscribe * SOAP_FMAC4 soap_in__pass__subscribe(struct soap *soap, const char *tag, _pass__subscribe *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_pass__subscribe *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__pass__subscribe, sizeof(_pass__subscribe), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__pass__subscribe)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_pass__subscribe *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "duration_secs", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_pass__subscribe*)a)->duration_USCOREsecs = soap_new_std__string(soap, -1);
				((_pass__subscribe*)a)->duration_USCOREsecs->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "subscription_id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_pass__subscribe*)a)->subscription_USCOREid = soap_new_std__string(soap, -1);
				((_pass__subscribe*)a)->subscription_USCOREid->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "topic", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__subscribe*)a)->topic.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "subscriber_id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__subscribe*)a)->subscriber_USCOREid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "compression", 0), &((_pass__subscribe*)a)->compression))
		return NULL;
	size_t soap_flag_return_USCOREaddress1 = 1;
	size_t soap_flag_AOI_USCORErectangle1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_USCOREaddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "pass:return_address", &(a->_pass__subscribe::return_USCOREaddress), "xsd:anyURI"))
				{	soap_flag_return_USCOREaddress1--;
					continue;
				}
			if (soap_flag_AOI_USCORErectangle1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__AOI_USCORErectangle(soap, "pass:AOI_rectangle", &(a->_pass__subscribe::AOI_USCORErectangle), ""))
				{	soap_flag_AOI_USCORErectangle1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "pass:item_id", &(a->_pass__subscribe::item_USCOREid), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_pass__subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__subscribe, 0, sizeof(_pass__subscribe), 0, soap_copy__pass__subscribe);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_USCOREaddress1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _pass__subscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__pass__subscribe);
	if (this->soap_out(soap, tag?tag:"pass:subscribe", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_pass__subscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__pass__subscribe(soap, this, tag, type);
}

SOAP_FMAC3 _pass__subscribe * SOAP_FMAC4 soap_get__pass__subscribe(struct soap *soap, _pass__subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _pass__subscribe * SOAP_FMAC2 soap_instantiate__pass__subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__pass__subscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__pass__subscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_pass__subscribe);
		if (size)
			*size = sizeof(_pass__subscribe);
		((_pass__subscribe*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_pass__subscribe[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_pass__subscribe);
		for (int i = 0; i < n; i++)
			((_pass__subscribe*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_pass__subscribe*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__pass__subscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _pass__subscribe %p -> %p\n", q, p));
	*(_pass__subscribe*)p = *(_pass__subscribe*)q;
}

void _pass__unsubscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_pass__unsubscribe::subscriber_USCOREid);
	this->_pass__unsubscribe::subscription_USCOREid = NULL;
	/* transient soap skipped */
}

void _pass__unsubscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _pass__unsubscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__pass__unsubscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__unsubscribe(struct soap *soap, const char *tag, int id, const _pass__unsubscribe *a, const char *type)
{
	if (!((_pass__unsubscribe*)a)->subscriber_USCOREid.empty())
		soap_set_attr(soap, "subscriber_id", ((_pass__unsubscribe*)a)->subscriber_USCOREid.c_str(), 1);
	if (((_pass__unsubscribe*)a)->subscription_USCOREid)
		soap_set_attr(soap, "subscription_id", ((_pass__unsubscribe*)a)->subscription_USCOREid->c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__unsubscribe), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_pass__unsubscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__pass__unsubscribe(soap, tag, this, type);
}

SOAP_FMAC3 _pass__unsubscribe * SOAP_FMAC4 soap_in__pass__unsubscribe(struct soap *soap, const char *tag, _pass__unsubscribe *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_pass__unsubscribe *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__pass__unsubscribe, sizeof(_pass__unsubscribe), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__pass__unsubscribe)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_pass__unsubscribe *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "subscriber_id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__unsubscribe*)a)->subscriber_USCOREid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "subscription_id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_pass__unsubscribe*)a)->subscription_USCOREid = soap_new_std__string(soap, -1);
				((_pass__unsubscribe*)a)->subscription_USCOREid->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_pass__unsubscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__unsubscribe, 0, sizeof(_pass__unsubscribe), 0, soap_copy__pass__unsubscribe);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _pass__unsubscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__pass__unsubscribe);
	if (this->soap_out(soap, tag?tag:"pass:unsubscribe", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_pass__unsubscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__pass__unsubscribe(soap, this, tag, type);
}

SOAP_FMAC3 _pass__unsubscribe * SOAP_FMAC4 soap_get__pass__unsubscribe(struct soap *soap, _pass__unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _pass__unsubscribe * SOAP_FMAC2 soap_instantiate__pass__unsubscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__pass__unsubscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__pass__unsubscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_pass__unsubscribe);
		if (size)
			*size = sizeof(_pass__unsubscribe);
		((_pass__unsubscribe*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_pass__unsubscribe[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_pass__unsubscribe);
		for (int i = 0; i < n; i++)
			((_pass__unsubscribe*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_pass__unsubscribe*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__pass__unsubscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _pass__unsubscribe %p -> %p\n", q, p));
	*(_pass__unsubscribe*)p = *(_pass__unsubscribe*)q;
}

void _pass__retract_USCOREtopic::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_pass__retract_USCOREtopic::owner_USCOREid);
	soap_default_std__string(soap, &this->_pass__retract_USCOREtopic::topic);
	/* transient soap skipped */
}

void _pass__retract_USCOREtopic::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _pass__retract_USCOREtopic::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__pass__retract_USCOREtopic(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__retract_USCOREtopic(struct soap *soap, const char *tag, int id, const _pass__retract_USCOREtopic *a, const char *type)
{
	if (!((_pass__retract_USCOREtopic*)a)->owner_USCOREid.empty())
		soap_set_attr(soap, "owner_id", ((_pass__retract_USCOREtopic*)a)->owner_USCOREid.c_str(), 1);
	if (!((_pass__retract_USCOREtopic*)a)->topic.empty())
		soap_set_attr(soap, "topic", ((_pass__retract_USCOREtopic*)a)->topic.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__retract_USCOREtopic), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_pass__retract_USCOREtopic::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__pass__retract_USCOREtopic(soap, tag, this, type);
}

SOAP_FMAC3 _pass__retract_USCOREtopic * SOAP_FMAC4 soap_in__pass__retract_USCOREtopic(struct soap *soap, const char *tag, _pass__retract_USCOREtopic *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_pass__retract_USCOREtopic *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__pass__retract_USCOREtopic, sizeof(_pass__retract_USCOREtopic), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__pass__retract_USCOREtopic)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_pass__retract_USCOREtopic *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "owner_id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__retract_USCOREtopic*)a)->owner_USCOREid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "topic", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__retract_USCOREtopic*)a)->topic.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_pass__retract_USCOREtopic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__retract_USCOREtopic, 0, sizeof(_pass__retract_USCOREtopic), 0, soap_copy__pass__retract_USCOREtopic);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _pass__retract_USCOREtopic::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__pass__retract_USCOREtopic);
	if (this->soap_out(soap, tag?tag:"pass:retract_topic", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_pass__retract_USCOREtopic::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__pass__retract_USCOREtopic(soap, this, tag, type);
}

SOAP_FMAC3 _pass__retract_USCOREtopic * SOAP_FMAC4 soap_get__pass__retract_USCOREtopic(struct soap *soap, _pass__retract_USCOREtopic *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__retract_USCOREtopic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _pass__retract_USCOREtopic * SOAP_FMAC2 soap_instantiate__pass__retract_USCOREtopic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__pass__retract_USCOREtopic(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__pass__retract_USCOREtopic, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_pass__retract_USCOREtopic);
		if (size)
			*size = sizeof(_pass__retract_USCOREtopic);
		((_pass__retract_USCOREtopic*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_pass__retract_USCOREtopic[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_pass__retract_USCOREtopic);
		for (int i = 0; i < n; i++)
			((_pass__retract_USCOREtopic*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_pass__retract_USCOREtopic*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__pass__retract_USCOREtopic(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _pass__retract_USCOREtopic %p -> %p\n", q, p));
	*(_pass__retract_USCOREtopic*)p = *(_pass__retract_USCOREtopic*)q;
}

void _pass__retract_USCOREitem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_pass__retract_USCOREitem::publisher_USCOREid);
	soap_default_std__string(soap, &this->_pass__retract_USCOREitem::item_USCOREid);
	soap_default_std__string(soap, &this->_pass__retract_USCOREitem::topic);
	/* transient soap skipped */
}

void _pass__retract_USCOREitem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _pass__retract_USCOREitem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__pass__retract_USCOREitem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__retract_USCOREitem(struct soap *soap, const char *tag, int id, const _pass__retract_USCOREitem *a, const char *type)
{
	if (!((_pass__retract_USCOREitem*)a)->publisher_USCOREid.empty())
		soap_set_attr(soap, "publisher_id", ((_pass__retract_USCOREitem*)a)->publisher_USCOREid.c_str(), 1);
	if (!((_pass__retract_USCOREitem*)a)->item_USCOREid.empty())
		soap_set_attr(soap, "item_id", ((_pass__retract_USCOREitem*)a)->item_USCOREid.c_str(), 1);
	if (!((_pass__retract_USCOREitem*)a)->topic.empty())
		soap_set_attr(soap, "topic", ((_pass__retract_USCOREitem*)a)->topic.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__retract_USCOREitem), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_pass__retract_USCOREitem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__pass__retract_USCOREitem(soap, tag, this, type);
}

SOAP_FMAC3 _pass__retract_USCOREitem * SOAP_FMAC4 soap_in__pass__retract_USCOREitem(struct soap *soap, const char *tag, _pass__retract_USCOREitem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_pass__retract_USCOREitem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__pass__retract_USCOREitem, sizeof(_pass__retract_USCOREitem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__pass__retract_USCOREitem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_pass__retract_USCOREitem *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "publisher_id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__retract_USCOREitem*)a)->publisher_USCOREid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "item_id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__retract_USCOREitem*)a)->item_USCOREid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "topic", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__retract_USCOREitem*)a)->topic.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_pass__retract_USCOREitem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__retract_USCOREitem, 0, sizeof(_pass__retract_USCOREitem), 0, soap_copy__pass__retract_USCOREitem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _pass__retract_USCOREitem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__pass__retract_USCOREitem);
	if (this->soap_out(soap, tag?tag:"pass:retract_item", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_pass__retract_USCOREitem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__pass__retract_USCOREitem(soap, this, tag, type);
}

SOAP_FMAC3 _pass__retract_USCOREitem * SOAP_FMAC4 soap_get__pass__retract_USCOREitem(struct soap *soap, _pass__retract_USCOREitem *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__retract_USCOREitem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _pass__retract_USCOREitem * SOAP_FMAC2 soap_instantiate__pass__retract_USCOREitem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__pass__retract_USCOREitem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__pass__retract_USCOREitem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_pass__retract_USCOREitem);
		if (size)
			*size = sizeof(_pass__retract_USCOREitem);
		((_pass__retract_USCOREitem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_pass__retract_USCOREitem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_pass__retract_USCOREitem);
		for (int i = 0; i < n; i++)
			((_pass__retract_USCOREitem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_pass__retract_USCOREitem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__pass__retract_USCOREitem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _pass__retract_USCOREitem %p -> %p\n", q, p));
	*(_pass__retract_USCOREitem*)p = *(_pass__retract_USCOREitem*)q;
}

void _pass__publish::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTopass__item(soap, &this->_pass__publish::item);
	soap_default_std__string(soap, &this->_pass__publish::topic);
	this->_pass__publish::subscription_USCOREid = NULL;
	soap_default_std__string(soap, &this->_pass__publish::publisher_USCOREid);
	/* transient soap skipped */
}

void _pass__publish::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTopass__item(soap, &this->_pass__publish::item);
	/* transient soap skipped */
}

int _pass__publish::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__pass__publish(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__publish(struct soap *soap, const char *tag, int id, const _pass__publish *a, const char *type)
{
	if (!((_pass__publish*)a)->topic.empty())
		soap_set_attr(soap, "topic", ((_pass__publish*)a)->topic.c_str(), 1);
	if (((_pass__publish*)a)->subscription_USCOREid)
		soap_set_attr(soap, "subscription_id", ((_pass__publish*)a)->subscription_USCOREid->c_str(), 1);
	if (!((_pass__publish*)a)->publisher_USCOREid.empty())
		soap_set_attr(soap, "publisher_id", ((_pass__publish*)a)->publisher_USCOREid.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__publish), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTopass__item(soap, "pass:item", -1, &(a->_pass__publish::item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_pass__publish::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__pass__publish(soap, tag, this, type);
}

SOAP_FMAC3 _pass__publish * SOAP_FMAC4 soap_in__pass__publish(struct soap *soap, const char *tag, _pass__publish *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_pass__publish *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__pass__publish, sizeof(_pass__publish), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__pass__publish)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_pass__publish *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "topic", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__publish*)a)->topic.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "subscription_id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((_pass__publish*)a)->subscription_USCOREid = soap_new_std__string(soap, -1);
				((_pass__publish*)a)->subscription_USCOREid->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "publisher_id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__publish*)a)->publisher_USCOREid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTopass__item(soap, "pass:item", &(a->_pass__publish::item), "pass:item"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_pass__publish *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__publish, 0, sizeof(_pass__publish), 0, soap_copy__pass__publish);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_pass__publish::item.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _pass__publish::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__pass__publish);
	if (this->soap_out(soap, tag?tag:"pass:publish", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_pass__publish::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__pass__publish(soap, this, tag, type);
}

SOAP_FMAC3 _pass__publish * SOAP_FMAC4 soap_get__pass__publish(struct soap *soap, _pass__publish *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__publish(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _pass__publish * SOAP_FMAC2 soap_instantiate__pass__publish(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__pass__publish(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__pass__publish, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_pass__publish);
		if (size)
			*size = sizeof(_pass__publish);
		((_pass__publish*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_pass__publish[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_pass__publish);
		for (int i = 0; i < n; i++)
			((_pass__publish*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_pass__publish*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__pass__publish(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _pass__publish %p -> %p\n", q, p));
	*(_pass__publish*)p = *(_pass__publish*)q;
}

void _pass__References::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_pass__References::__sizeReferenceObj = 0;
	this->_pass__References::ReferenceObj = NULL;
	/* transient soap skipped */
}

void _pass__References::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_pass__References::ReferenceObj)
	{	int i;
		for (i = 0; i < this->_pass__References::__sizeReferenceObj; i++)
		{
			soap_embedded(soap, this->_pass__References::ReferenceObj + i, SOAP_TYPE__pass__References_ReferenceObj);
			this->_pass__References::ReferenceObj[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int _pass__References::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__pass__References(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__References(struct soap *soap, const char *tag, int id, const _pass__References *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__References), type))
		return soap->error;
	if (a->_pass__References::ReferenceObj)
	{	int i;
		for (i = 0; i < a->_pass__References::__sizeReferenceObj; i++)
			if (a->_pass__References::ReferenceObj[i].soap_out(soap, "pass:ReferenceObj", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_pass__References::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__pass__References(soap, tag, this, type);
}

SOAP_FMAC3 _pass__References * SOAP_FMAC4 soap_in__pass__References(struct soap *soap, const char *tag, _pass__References *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_pass__References *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__pass__References, sizeof(_pass__References), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__pass__References)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_pass__References *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_ReferenceObj1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "pass:ReferenceObj", 1, NULL))
			{	if (a->_pass__References::ReferenceObj == NULL)
				{	if (soap_blist_ReferenceObj1 == NULL)
						soap_blist_ReferenceObj1 = soap_new_block(soap);
					a->_pass__References::ReferenceObj = (_pass__References_ReferenceObj *)soap_push_block(soap, soap_blist_ReferenceObj1, sizeof(_pass__References_ReferenceObj));
					if (a->_pass__References::ReferenceObj == NULL)
						return NULL;
					_pass__References_ReferenceObj p;
					memcpy(a->_pass__References::ReferenceObj, &p, sizeof(_pass__References_ReferenceObj)); // a bit rough but portable
					a->_pass__References::ReferenceObj->soap_default(soap);
				}soap_revert(soap);
				if (soap_in__pass__References_ReferenceObj(soap, "pass:ReferenceObj", a->_pass__References::ReferenceObj, ""))
				{	a->_pass__References::__sizeReferenceObj++;
					a->_pass__References::ReferenceObj = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_pass__References::ReferenceObj)
			soap_pop_block(soap, soap_blist_ReferenceObj1);
		if (a->_pass__References::__sizeReferenceObj)
			a->_pass__References::ReferenceObj = (_pass__References_ReferenceObj *)soap_save_block(soap, soap_blist_ReferenceObj1, NULL, 1);
		else
		{	a->_pass__References::ReferenceObj = NULL;
			if (soap_blist_ReferenceObj1)
				soap_end_block(soap, soap_blist_ReferenceObj1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_pass__References *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__References, 0, sizeof(_pass__References), 0, soap_copy__pass__References);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_pass__References::__sizeReferenceObj < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _pass__References::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__pass__References);
	if (this->soap_out(soap, tag?tag:"pass:References", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_pass__References::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__pass__References(soap, this, tag, type);
}

SOAP_FMAC3 _pass__References * SOAP_FMAC4 soap_get__pass__References(struct soap *soap, _pass__References *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__References(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _pass__References * SOAP_FMAC2 soap_instantiate__pass__References(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__pass__References(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__pass__References, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_pass__References);
		if (size)
			*size = sizeof(_pass__References);
		((_pass__References*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_pass__References[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_pass__References);
		for (int i = 0; i < n; i++)
			((_pass__References*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_pass__References*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__pass__References(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _pass__References %p -> %p\n", q, p));
	*(_pass__References*)p = *(_pass__References*)q;
}

void _pass__AOI_USCORErectangle::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_pass__latitude(soap, &this->_pass__AOI_USCORErectangle::aoi_USCOREn_USCORElat);
	soap_default_pass__longitude(soap, &this->_pass__AOI_USCORErectangle::aoi_USCOREw_USCORElong);
	soap_default_pass__latitude(soap, &this->_pass__AOI_USCORErectangle::aoi_USCOREs_USCORElat);
	soap_default_pass__longitude(soap, &this->_pass__AOI_USCORErectangle::aoi_USCOREe_USCORElong);
	/* transient soap skipped */
}

void _pass__AOI_USCORErectangle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _pass__AOI_USCORErectangle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__pass__AOI_USCORErectangle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__AOI_USCORErectangle(struct soap *soap, const char *tag, int id, const _pass__AOI_USCORErectangle *a, const char *type)
{
	if (!((_pass__AOI_USCORErectangle*)a)->aoi_USCOREn_USCORElat.empty())
		soap_set_attr(soap, "aoi_n_lat", ((_pass__AOI_USCORErectangle*)a)->aoi_USCOREn_USCORElat.c_str(), 1);
	if (!((_pass__AOI_USCORErectangle*)a)->aoi_USCOREw_USCORElong.empty())
		soap_set_attr(soap, "aoi_w_long", ((_pass__AOI_USCORErectangle*)a)->aoi_USCOREw_USCORElong.c_str(), 1);
	if (!((_pass__AOI_USCORErectangle*)a)->aoi_USCOREs_USCORElat.empty())
		soap_set_attr(soap, "aoi_s_lat", ((_pass__AOI_USCORErectangle*)a)->aoi_USCOREs_USCORElat.c_str(), 1);
	if (!((_pass__AOI_USCORErectangle*)a)->aoi_USCOREe_USCORElong.empty())
		soap_set_attr(soap, "aoi_e_long", ((_pass__AOI_USCORErectangle*)a)->aoi_USCOREe_USCORElong.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__pass__AOI_USCORErectangle), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_pass__AOI_USCORErectangle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__pass__AOI_USCORErectangle(soap, tag, this, type);
}

SOAP_FMAC3 _pass__AOI_USCORErectangle * SOAP_FMAC4 soap_in__pass__AOI_USCORErectangle(struct soap *soap, const char *tag, _pass__AOI_USCORErectangle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_pass__AOI_USCORErectangle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__pass__AOI_USCORErectangle, sizeof(_pass__AOI_USCORErectangle), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__pass__AOI_USCORErectangle)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_pass__AOI_USCORErectangle *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "aoi_n_lat", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__AOI_USCORErectangle*)a)->aoi_USCOREn_USCORElat.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "aoi_w_long", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__AOI_USCORErectangle*)a)->aoi_USCOREw_USCORElong.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "aoi_s_lat", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__AOI_USCORErectangle*)a)->aoi_USCOREs_USCORElat.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "aoi_e_long", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((_pass__AOI_USCORErectangle*)a)->aoi_USCOREe_USCORElong.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_pass__AOI_USCORErectangle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__pass__AOI_USCORErectangle, 0, sizeof(_pass__AOI_USCORErectangle), 0, soap_copy__pass__AOI_USCORErectangle);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _pass__AOI_USCORErectangle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__pass__AOI_USCORErectangle);
	if (this->soap_out(soap, tag?tag:"pass:AOI_rectangle", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_pass__AOI_USCORErectangle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__pass__AOI_USCORErectangle(soap, this, tag, type);
}

SOAP_FMAC3 _pass__AOI_USCORErectangle * SOAP_FMAC4 soap_get__pass__AOI_USCORErectangle(struct soap *soap, _pass__AOI_USCORErectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in__pass__AOI_USCORErectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _pass__AOI_USCORErectangle * SOAP_FMAC2 soap_instantiate__pass__AOI_USCORErectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__pass__AOI_USCORErectangle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__pass__AOI_USCORErectangle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_pass__AOI_USCORErectangle);
		if (size)
			*size = sizeof(_pass__AOI_USCORErectangle);
		((_pass__AOI_USCORErectangle*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_pass__AOI_USCORErectangle[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_pass__AOI_USCORErectangle);
		for (int i = 0; i < n; i++)
			((_pass__AOI_USCORErectangle*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_pass__AOI_USCORErectangle*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__pass__AOI_USCORErectangle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _pass__AOI_USCORErectangle %p -> %p\n", q, p));
	*(_pass__AOI_USCORErectangle*)p = *(_pass__AOI_USCORErectangle*)q;
}

void pass__item_USCOREdata::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->pass__item_USCOREdata::References = NULL;
	soap_default_xsd__anyType(soap, &this->pass__item_USCOREdata::__any);
	soap_default__pass__item_USCOREdata_item_USCOREdata_USCOREclassification(soap, &this->pass__item_USCOREdata::item_USCOREdata_USCOREclassification);
	this->pass__item_USCOREdata::control_USCOREmark = NULL;
	this->pass__item_USCOREdata::release_USCOREmark = NULL;
	this->pass__item_USCOREdata::declass_USCOREexemption_USCOREcode = NULL;
	this->pass__item_USCOREdata::declass_USCOREdateTime = NULL;
	this->pass__item_USCOREdata::item_USCOREdata_USCOREcategory = NULL;
	soap_default_xsd__anyAttribute(soap, &this->pass__item_USCOREdata::__anyAttribute);
	/* transient soap skipped */
}

void pass__item_USCOREdata::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__References(soap, &this->pass__item_USCOREdata::References);
	soap_serialize_xsd__anyType(soap, &this->pass__item_USCOREdata::__any);
	/* transient soap skipped */
}

int pass__item_USCOREdata::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_pass__item_USCOREdata(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pass__item_USCOREdata(struct soap *soap, const char *tag, int id, const pass__item_USCOREdata *a, const char *type)
{
	soap_set_attr(soap, "item_data_classification", soap__pass__item_USCOREdata_item_USCOREdata_USCOREclassification2s(soap, ((pass__item_USCOREdata*)a)->item_USCOREdata_USCOREclassification), 1);
	if (((pass__item_USCOREdata*)a)->control_USCOREmark)
		soap_set_attr(soap, "control_mark", ((pass__item_USCOREdata*)a)->control_USCOREmark->c_str(), 1);
	if (((pass__item_USCOREdata*)a)->release_USCOREmark)
		soap_set_attr(soap, "release_mark", ((pass__item_USCOREdata*)a)->release_USCOREmark->c_str(), 1);
	if (((pass__item_USCOREdata*)a)->declass_USCOREexemption_USCOREcode)
		soap_set_attr(soap, "declass_exemption_code", ((pass__item_USCOREdata*)a)->declass_USCOREexemption_USCOREcode->c_str(), 1);
	if (((pass__item_USCOREdata*)a)->declass_USCOREdateTime)
		soap_set_attr(soap, "declass_dateTime", soap_dateTime2s(soap, *((pass__item_USCOREdata*)a)->declass_USCOREdateTime), 1);
	if (((pass__item_USCOREdata*)a)->item_USCOREdata_USCOREcategory)
		soap_set_attr(soap, "item_data_category", ((pass__item_USCOREdata*)a)->item_USCOREdata_USCOREcategory->c_str(), 1);
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &((pass__item_USCOREdata*)a)->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pass__item_USCOREdata), type))
		return soap->error;
	if (soap_out_PointerTo_pass__References(soap, "pass:References", -1, &(a->pass__item_USCOREdata::References), ""))
		return soap->error;
	if (soap_out_xsd__anyType(soap, "-any", -1, &(a->pass__item_USCOREdata::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *pass__item_USCOREdata::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_pass__item_USCOREdata(soap, tag, this, type);
}

SOAP_FMAC3 pass__item_USCOREdata * SOAP_FMAC4 soap_in_pass__item_USCOREdata(struct soap *soap, const char *tag, pass__item_USCOREdata *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (pass__item_USCOREdata *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_pass__item_USCOREdata, sizeof(pass__item_USCOREdata), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_pass__item_USCOREdata)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (pass__item_USCOREdata *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2_pass__item_USCOREdata_item_USCOREdata_USCOREclassification(soap, soap_attr_value(soap, "item_data_classification", 1), &((pass__item_USCOREdata*)a)->item_USCOREdata_USCOREclassification))
		return NULL;
	{	const char *t = soap_attr_value(soap, "control_mark", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((pass__item_USCOREdata*)a)->control_USCOREmark = soap_new_std__string(soap, -1);
				((pass__item_USCOREdata*)a)->control_USCOREmark->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "release_mark", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((pass__item_USCOREdata*)a)->release_USCOREmark = soap_new_std__string(soap, -1);
				((pass__item_USCOREdata*)a)->release_USCOREmark->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "declass_exemption_code", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((pass__item_USCOREdata*)a)->declass_USCOREexemption_USCOREcode = soap_new_std__string(soap, -1);
				((pass__item_USCOREdata*)a)->declass_USCOREexemption_USCOREcode->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "declass_dateTime", 0);
		if (t)
		{
			if (!(((pass__item_USCOREdata*)a)->declass_USCOREdateTime = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, ((pass__item_USCOREdata*)a)->declass_USCOREdateTime))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "item_data_category", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((pass__item_USCOREdata*)a)->item_USCOREdata_USCOREcategory = soap_new_std__string(soap, -1);
				((pass__item_USCOREdata*)a)->item_USCOREdata_USCOREcategory->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &((pass__item_USCOREdata*)a)->__anyAttribute, "xsd:anyAttribute");
	size_t soap_flag_References1 = 1;
	size_t soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_References1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__References(soap, "pass:References", &(a->pass__item_USCOREdata::References), ""))
				{	soap_flag_References1--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag___any1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__anyType(soap, "-any", &(a->pass__item_USCOREdata::__any), "xsd:anyType"))
				{	soap_flag___any1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (pass__item_USCOREdata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pass__item_USCOREdata, 0, sizeof(pass__item_USCOREdata), 0, soap_copy_pass__item_USCOREdata);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int pass__item_USCOREdata::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_pass__item_USCOREdata);
	if (this->soap_out(soap, tag?tag:"pass:item_data", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *pass__item_USCOREdata::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_pass__item_USCOREdata(soap, this, tag, type);
}

SOAP_FMAC3 pass__item_USCOREdata * SOAP_FMAC4 soap_get_pass__item_USCOREdata(struct soap *soap, pass__item_USCOREdata *p, const char *tag, const char *type)
{
	if ((p = soap_in_pass__item_USCOREdata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 pass__item_USCOREdata * SOAP_FMAC2 soap_instantiate_pass__item_USCOREdata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_pass__item_USCOREdata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_pass__item_USCOREdata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(pass__item_USCOREdata);
		if (size)
			*size = sizeof(pass__item_USCOREdata);
		((pass__item_USCOREdata*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(pass__item_USCOREdata[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(pass__item_USCOREdata);
		for (int i = 0; i < n; i++)
			((pass__item_USCOREdata*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (pass__item_USCOREdata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_pass__item_USCOREdata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying pass__item_USCOREdata %p -> %p\n", q, p));
	*(pass__item_USCOREdata*)p = *(pass__item_USCOREdata*)q;
}

void pass__item::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->pass__item::AOI_USCORErectangle = NULL;
	this->pass__item::description = NULL;
	this->pass__item::item_USCOREdata = NULL;
	soap_default_time(soap, &this->pass__item::item_USCOREdtg);
	soap_default_pass__item_USCORETTL(soap, &this->pass__item::item_USCORETTL_USCOREsecs);
	soap_default_std__string(soap, &this->pass__item::item_USCOREid);
	/* transient soap skipped */
}

void pass__item::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__AOI_USCORErectangle(soap, &this->pass__item::AOI_USCORErectangle);
	soap_serialize_PointerTostd__string(soap, &this->pass__item::description);
	soap_serialize_PointerTopass__item_USCOREdata(soap, &this->pass__item::item_USCOREdata);
	/* transient soap skipped */
}

int pass__item::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_pass__item(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pass__item(struct soap *soap, const char *tag, int id, const pass__item *a, const char *type)
{
	soap_set_attr(soap, "item_dtg", soap_dateTime2s(soap, ((pass__item*)a)->item_USCOREdtg), 1);
	if (!((pass__item*)a)->item_USCORETTL_USCOREsecs.empty())
		soap_set_attr(soap, "item_TTL_secs", ((pass__item*)a)->item_USCORETTL_USCOREsecs.c_str(), 1);
	if (!((pass__item*)a)->item_USCOREid.empty())
		soap_set_attr(soap, "item_id", ((pass__item*)a)->item_USCOREid.c_str(), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pass__item), type))
		return soap->error;
	if (soap_out_PointerTo_pass__AOI_USCORErectangle(soap, "pass:AOI_rectangle", -1, &(a->pass__item::AOI_USCORErectangle), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "pass:description", -1, &(a->pass__item::description), ""))
		return soap->error;
	if (soap_out_PointerTopass__item_USCOREdata(soap, "pass:item_data", -1, &(a->pass__item::item_USCOREdata), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *pass__item::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_pass__item(soap, tag, this, type);
}

SOAP_FMAC3 pass__item * SOAP_FMAC4 soap_in_pass__item(struct soap *soap, const char *tag, pass__item *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (pass__item *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_pass__item, sizeof(pass__item), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_pass__item)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (pass__item *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2dateTime(soap, soap_attr_value(soap, "item_dtg", 1), &((pass__item*)a)->item_USCOREdtg))
		return NULL;
	{	const char *t = soap_attr_value(soap, "item_TTL_secs", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((pass__item*)a)->item_USCORETTL_USCOREsecs.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "item_id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((pass__item*)a)->item_USCOREid.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_AOI_USCORErectangle1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_item_USCOREdata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AOI_USCORErectangle1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__AOI_USCORErectangle(soap, "pass:AOI_rectangle", &(a->pass__item::AOI_USCORErectangle), ""))
				{	soap_flag_AOI_USCORErectangle1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "pass:description", &(a->pass__item::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_item_USCOREdata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTopass__item_USCOREdata(soap, "pass:item_data", &(a->pass__item::item_USCOREdata), "pass:item_data"))
				{	soap_flag_item_USCOREdata1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (pass__item *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pass__item, 0, sizeof(pass__item), 0, soap_copy_pass__item);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_item_USCOREdata1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int pass__item::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_pass__item);
	if (this->soap_out(soap, tag?tag:"pass:item", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *pass__item::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_pass__item(soap, this, tag, type);
}

SOAP_FMAC3 pass__item * SOAP_FMAC4 soap_get_pass__item(struct soap *soap, pass__item *p, const char *tag, const char *type)
{
	if ((p = soap_in_pass__item(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 pass__item * SOAP_FMAC2 soap_instantiate_pass__item(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_pass__item(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_pass__item, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(pass__item);
		if (size)
			*size = sizeof(pass__item);
		((pass__item*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(pass__item[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(pass__item);
		for (int i = 0; i < n; i++)
			((pass__item*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (pass__item*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_pass__item(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying pass__item %p -> %p\n", q, p));
	*(pass__item*)p = *(pass__item*)q;
}

void pass__pass_USCOREfault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->pass__pass_USCOREfault::status = NULL;
	this->pass__pass_USCOREfault::error_USCOREdetails = NULL;
	/* transient soap skipped */
}

void pass__pass_USCOREfault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTopass__status(soap, &this->pass__pass_USCOREfault::status);
	soap_serialize_PointerTostd__string(soap, &this->pass__pass_USCOREfault::error_USCOREdetails);
	/* transient soap skipped */
}

int pass__pass_USCOREfault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_pass__pass_USCOREfault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pass__pass_USCOREfault(struct soap *soap, const char *tag, int id, const pass__pass_USCOREfault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pass__pass_USCOREfault), type))
		return soap->error;
	if (soap_out_PointerTopass__status(soap, "pass:status", -1, &(a->pass__pass_USCOREfault::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "pass:error_details", -1, &(a->pass__pass_USCOREfault::error_USCOREdetails), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *pass__pass_USCOREfault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_pass__pass_USCOREfault(soap, tag, this, type);
}

SOAP_FMAC3 pass__pass_USCOREfault * SOAP_FMAC4 soap_in_pass__pass_USCOREfault(struct soap *soap, const char *tag, pass__pass_USCOREfault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (pass__pass_USCOREfault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_pass__pass_USCOREfault, sizeof(pass__pass_USCOREfault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_pass__pass_USCOREfault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (pass__pass_USCOREfault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_status1 = 1;
	size_t soap_flag_error_USCOREdetails1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTopass__status(soap, "pass:status", &(a->pass__pass_USCOREfault::status), "pass:status"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_error_USCOREdetails1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "pass:error_details", &(a->pass__pass_USCOREfault::error_USCOREdetails), "xsd:string"))
				{	soap_flag_error_USCOREdetails1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (pass__pass_USCOREfault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pass__pass_USCOREfault, 0, sizeof(pass__pass_USCOREfault), 0, soap_copy_pass__pass_USCOREfault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int pass__pass_USCOREfault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_pass__pass_USCOREfault);
	if (this->soap_out(soap, tag?tag:"pass:pass_fault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *pass__pass_USCOREfault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_pass__pass_USCOREfault(soap, this, tag, type);
}

SOAP_FMAC3 pass__pass_USCOREfault * SOAP_FMAC4 soap_get_pass__pass_USCOREfault(struct soap *soap, pass__pass_USCOREfault *p, const char *tag, const char *type)
{
	if ((p = soap_in_pass__pass_USCOREfault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 pass__pass_USCOREfault * SOAP_FMAC2 soap_instantiate_pass__pass_USCOREfault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_pass__pass_USCOREfault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_pass__pass_USCOREfault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(pass__pass_USCOREfault);
		if (size)
			*size = sizeof(pass__pass_USCOREfault);
		((pass__pass_USCOREfault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(pass__pass_USCOREfault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(pass__pass_USCOREfault);
		for (int i = 0; i < n; i++)
			((pass__pass_USCOREfault*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (pass__pass_USCOREfault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_pass__pass_USCOREfault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying pass__pass_USCOREfault %p -> %p\n", q, p));
	*(pass__pass_USCOREfault*)p = *(pass__pass_USCOREfault*)q;
}

void pass__status::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__pass__status_command(soap, &this->pass__status::command);
	soap_default_std__string(soap, &this->pass__status::topic);
	this->pass__status::item_USCOREid = NULL;
	this->pass__status::subscription_USCOREid = NULL;
	this->pass__status::status_USCOREphrase = NULL;
	soap_default__pass__status_status_USCOREcode(soap, &this->pass__status::status_USCOREcode);
	/* transient soap skipped */
}

void pass__status::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int pass__status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_pass__status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_pass__status(struct soap *soap, const char *tag, int id, const pass__status *a, const char *type)
{
	soap_set_attr(soap, "command", soap__pass__status_command2s(soap, ((pass__status*)a)->command), 1);
	if (!((pass__status*)a)->topic.empty())
		soap_set_attr(soap, "topic", ((pass__status*)a)->topic.c_str(), 1);
	if (((pass__status*)a)->item_USCOREid)
		soap_set_attr(soap, "item_id", ((pass__status*)a)->item_USCOREid->c_str(), 1);
	if (((pass__status*)a)->subscription_USCOREid)
		soap_set_attr(soap, "subscription_id", ((pass__status*)a)->subscription_USCOREid->c_str(), 1);
	if (((pass__status*)a)->status_USCOREphrase)
		soap_set_attr(soap, "status_phrase", ((pass__status*)a)->status_USCOREphrase->c_str(), 1);
	soap_set_attr(soap, "status_code", soap__pass__status_status_USCOREcode2s(soap, ((pass__status*)a)->status_USCOREcode), 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_pass__status), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *pass__status::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_pass__status(soap, tag, this, type);
}

SOAP_FMAC3 pass__status * SOAP_FMAC4 soap_in_pass__status(struct soap *soap, const char *tag, pass__status *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (pass__status *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_pass__status, sizeof(pass__status), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_pass__status)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (pass__status *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2_pass__status_command(soap, soap_attr_value(soap, "command", 1), &((pass__status*)a)->command))
		return NULL;
	{	const char *t = soap_attr_value(soap, "topic", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((pass__status*)a)->topic.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "item_id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((pass__status*)a)->item_USCOREid = soap_new_std__string(soap, -1);
				((pass__status*)a)->item_USCOREid->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "subscription_id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((pass__status*)a)->subscription_USCOREid = soap_new_std__string(soap, -1);
				((pass__status*)a)->subscription_USCOREid->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "status_phrase", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((pass__status*)a)->status_USCOREphrase = soap_new_std__string(soap, -1);
				((pass__status*)a)->status_USCOREphrase->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2_pass__status_status_USCOREcode(soap, soap_attr_value(soap, "status_code", 1), &((pass__status*)a)->status_USCOREcode))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (pass__status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_pass__status, 0, sizeof(pass__status), 0, soap_copy_pass__status);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int pass__status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_pass__status);
	if (this->soap_out(soap, tag?tag:"pass:status", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *pass__status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_pass__status(soap, this, tag, type);
}

SOAP_FMAC3 pass__status * SOAP_FMAC4 soap_get_pass__status(struct soap *soap, pass__status *p, const char *tag, const char *type)
{
	if ((p = soap_in_pass__status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 pass__status * SOAP_FMAC2 soap_instantiate_pass__status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_pass__status(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_pass__status, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(pass__status);
		if (size)
			*size = sizeof(pass__status);
		((pass__status*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(pass__status[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(pass__status);
		for (int i = 0; i < n; i++)
			((pass__status*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (pass__status*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_pass__status(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying pass__status %p -> %p\n", q, p));
	*(pass__status*)p = *(pass__status*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__nonNegativeInteger, 0, sizeof(std::string), 0, soap_copy_xsd__nonNegativeInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__integer, 0, sizeof(std::string), 0, soap_copy_xsd__integer);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag?tag:"xsd:integer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__decimal, 0, sizeof(std::string), 0, soap_copy_xsd__decimal);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag?tag:"xsd:decimal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__unsubscribe(struct soap *soap, struct __ns2__unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pass__unsubscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__unsubscribe(struct soap *soap, const struct __ns2__unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__unsubscribe(soap, &a->pass__unsubscribe);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__unsubscribe(struct soap *soap, const char *tag, int id, const struct __ns2__unsubscribe *a, const char *type)
{
	if (soap_out_PointerTo_pass__unsubscribe(soap, "pass:unsubscribe", -1, &a->pass__unsubscribe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__unsubscribe * SOAP_FMAC4 soap_in___ns2__unsubscribe(struct soap *soap, const char *tag, struct __ns2__unsubscribe *a, const char *type)
{
	size_t soap_flag_pass__unsubscribe = 1;
	short soap_flag;
	a = (struct __ns2__unsubscribe *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__unsubscribe, sizeof(struct __ns2__unsubscribe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__unsubscribe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pass__unsubscribe && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__unsubscribe(soap, "pass:unsubscribe", &a->pass__unsubscribe, ""))
				{	soap_flag_pass__unsubscribe--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__unsubscribe(struct soap *soap, const struct __ns2__unsubscribe *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__unsubscribe(soap, tag?tag:"-ns2:unsubscribe", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__unsubscribe * SOAP_FMAC4 soap_get___ns2__unsubscribe(struct soap *soap, struct __ns2__unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__unsubscribe * SOAP_FMAC2 soap_instantiate___ns2__unsubscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__unsubscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__unsubscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__unsubscribe);
		if (size)
			*size = sizeof(struct __ns2__unsubscribe);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__unsubscribe[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__unsubscribe);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__unsubscribe*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__unsubscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__unsubscribe %p -> %p\n", q, p));
	*(struct __ns2__unsubscribe*)p = *(struct __ns2__unsubscribe*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__retract_USCOREtopic(struct soap *soap, struct __ns2__retract_USCOREtopic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pass__retract_USCOREtopic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__retract_USCOREtopic(struct soap *soap, const struct __ns2__retract_USCOREtopic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__retract_USCOREtopic(soap, &a->pass__retract_USCOREtopic);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__retract_USCOREtopic(struct soap *soap, const char *tag, int id, const struct __ns2__retract_USCOREtopic *a, const char *type)
{
	if (soap_out_PointerTo_pass__retract_USCOREtopic(soap, "pass:retract_topic", -1, &a->pass__retract_USCOREtopic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__retract_USCOREtopic * SOAP_FMAC4 soap_in___ns2__retract_USCOREtopic(struct soap *soap, const char *tag, struct __ns2__retract_USCOREtopic *a, const char *type)
{
	size_t soap_flag_pass__retract_USCOREtopic = 1;
	short soap_flag;
	a = (struct __ns2__retract_USCOREtopic *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__retract_USCOREtopic, sizeof(struct __ns2__retract_USCOREtopic), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__retract_USCOREtopic(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pass__retract_USCOREtopic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__retract_USCOREtopic(soap, "pass:retract_topic", &a->pass__retract_USCOREtopic, ""))
				{	soap_flag_pass__retract_USCOREtopic--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__retract_USCOREtopic(struct soap *soap, const struct __ns2__retract_USCOREtopic *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__retract_USCOREtopic(soap, tag?tag:"-ns2:retract_topic", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__retract_USCOREtopic * SOAP_FMAC4 soap_get___ns2__retract_USCOREtopic(struct soap *soap, struct __ns2__retract_USCOREtopic *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__retract_USCOREtopic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__retract_USCOREtopic * SOAP_FMAC2 soap_instantiate___ns2__retract_USCOREtopic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__retract_USCOREtopic(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__retract_USCOREtopic, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__retract_USCOREtopic);
		if (size)
			*size = sizeof(struct __ns2__retract_USCOREtopic);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__retract_USCOREtopic[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__retract_USCOREtopic);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__retract_USCOREtopic*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__retract_USCOREtopic(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__retract_USCOREtopic %p -> %p\n", q, p));
	*(struct __ns2__retract_USCOREtopic*)p = *(struct __ns2__retract_USCOREtopic*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__retract_USCOREitem(struct soap *soap, struct __ns2__retract_USCOREitem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pass__retract_USCOREitem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__retract_USCOREitem(struct soap *soap, const struct __ns2__retract_USCOREitem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__retract_USCOREitem(soap, &a->pass__retract_USCOREitem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__retract_USCOREitem(struct soap *soap, const char *tag, int id, const struct __ns2__retract_USCOREitem *a, const char *type)
{
	if (soap_out_PointerTo_pass__retract_USCOREitem(soap, "pass:retract_item", -1, &a->pass__retract_USCOREitem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__retract_USCOREitem * SOAP_FMAC4 soap_in___ns2__retract_USCOREitem(struct soap *soap, const char *tag, struct __ns2__retract_USCOREitem *a, const char *type)
{
	size_t soap_flag_pass__retract_USCOREitem = 1;
	short soap_flag;
	a = (struct __ns2__retract_USCOREitem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__retract_USCOREitem, sizeof(struct __ns2__retract_USCOREitem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__retract_USCOREitem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pass__retract_USCOREitem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__retract_USCOREitem(soap, "pass:retract_item", &a->pass__retract_USCOREitem, ""))
				{	soap_flag_pass__retract_USCOREitem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__retract_USCOREitem(struct soap *soap, const struct __ns2__retract_USCOREitem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__retract_USCOREitem(soap, tag?tag:"-ns2:retract_item", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__retract_USCOREitem * SOAP_FMAC4 soap_get___ns2__retract_USCOREitem(struct soap *soap, struct __ns2__retract_USCOREitem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__retract_USCOREitem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__retract_USCOREitem * SOAP_FMAC2 soap_instantiate___ns2__retract_USCOREitem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__retract_USCOREitem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__retract_USCOREitem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__retract_USCOREitem);
		if (size)
			*size = sizeof(struct __ns2__retract_USCOREitem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__retract_USCOREitem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__retract_USCOREitem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__retract_USCOREitem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__retract_USCOREitem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__retract_USCOREitem %p -> %p\n", q, p));
	*(struct __ns2__retract_USCOREitem*)p = *(struct __ns2__retract_USCOREitem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__publish(struct soap *soap, struct __ns2__publish *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pass__publish = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__publish(struct soap *soap, const struct __ns2__publish *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__publish(soap, &a->pass__publish);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__publish(struct soap *soap, const char *tag, int id, const struct __ns2__publish *a, const char *type)
{
	if (soap_out_PointerTo_pass__publish(soap, "pass:publish", -1, &a->pass__publish, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__publish * SOAP_FMAC4 soap_in___ns2__publish(struct soap *soap, const char *tag, struct __ns2__publish *a, const char *type)
{
	size_t soap_flag_pass__publish = 1;
	short soap_flag;
	a = (struct __ns2__publish *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__publish, sizeof(struct __ns2__publish), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__publish(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pass__publish && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__publish(soap, "pass:publish", &a->pass__publish, ""))
				{	soap_flag_pass__publish--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__publish(struct soap *soap, const struct __ns2__publish *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__publish(soap, tag?tag:"-ns2:publish", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__publish * SOAP_FMAC4 soap_get___ns2__publish(struct soap *soap, struct __ns2__publish *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__publish(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__publish * SOAP_FMAC2 soap_instantiate___ns2__publish(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__publish(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__publish, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__publish);
		if (size)
			*size = sizeof(struct __ns2__publish);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__publish[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns2__publish);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns2__publish*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__publish(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__publish %p -> %p\n", q, p));
	*(struct __ns2__publish*)p = *(struct __ns2__publish*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sync(struct soap *soap, struct __ns1__sync *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pass__sync = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sync(struct soap *soap, const struct __ns1__sync *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__sync(soap, &a->pass__sync);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sync(struct soap *soap, const char *tag, int id, const struct __ns1__sync *a, const char *type)
{
	if (soap_out_PointerTo_pass__sync(soap, "pass:sync", -1, &a->pass__sync, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sync * SOAP_FMAC4 soap_in___ns1__sync(struct soap *soap, const char *tag, struct __ns1__sync *a, const char *type)
{
	size_t soap_flag_pass__sync = 1;
	short soap_flag;
	a = (struct __ns1__sync *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sync, sizeof(struct __ns1__sync), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sync(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pass__sync && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__sync(soap, "pass:sync", &a->pass__sync, ""))
				{	soap_flag_pass__sync--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sync(struct soap *soap, const struct __ns1__sync *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sync(soap, tag?tag:"-ns1:sync", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sync * SOAP_FMAC4 soap_get___ns1__sync(struct soap *soap, struct __ns1__sync *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sync(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__sync * SOAP_FMAC2 soap_instantiate___ns1__sync(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sync(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__sync, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sync);
		if (size)
			*size = sizeof(struct __ns1__sync);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sync[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__sync);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__sync*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__sync(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__sync %p -> %p\n", q, p));
	*(struct __ns1__sync*)p = *(struct __ns1__sync*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__create_USCOREtopic(struct soap *soap, struct __ns1__create_USCOREtopic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pass__create_USCOREtopic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__create_USCOREtopic(struct soap *soap, const struct __ns1__create_USCOREtopic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__create_USCOREtopic(soap, &a->pass__create_USCOREtopic);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__create_USCOREtopic(struct soap *soap, const char *tag, int id, const struct __ns1__create_USCOREtopic *a, const char *type)
{
	if (soap_out_PointerTo_pass__create_USCOREtopic(soap, "pass:create_topic", -1, &a->pass__create_USCOREtopic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create_USCOREtopic * SOAP_FMAC4 soap_in___ns1__create_USCOREtopic(struct soap *soap, const char *tag, struct __ns1__create_USCOREtopic *a, const char *type)
{
	size_t soap_flag_pass__create_USCOREtopic = 1;
	short soap_flag;
	a = (struct __ns1__create_USCOREtopic *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__create_USCOREtopic, sizeof(struct __ns1__create_USCOREtopic), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__create_USCOREtopic(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pass__create_USCOREtopic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__create_USCOREtopic(soap, "pass:create_topic", &a->pass__create_USCOREtopic, ""))
				{	soap_flag_pass__create_USCOREtopic--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__create_USCOREtopic(struct soap *soap, const struct __ns1__create_USCOREtopic *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__create_USCOREtopic(soap, tag?tag:"-ns1:create_topic", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__create_USCOREtopic * SOAP_FMAC4 soap_get___ns1__create_USCOREtopic(struct soap *soap, struct __ns1__create_USCOREtopic *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__create_USCOREtopic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__create_USCOREtopic * SOAP_FMAC2 soap_instantiate___ns1__create_USCOREtopic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__create_USCOREtopic(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__create_USCOREtopic, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__create_USCOREtopic);
		if (size)
			*size = sizeof(struct __ns1__create_USCOREtopic);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__create_USCOREtopic[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__create_USCOREtopic);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__create_USCOREtopic*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__create_USCOREtopic(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__create_USCOREtopic %p -> %p\n", q, p));
	*(struct __ns1__create_USCOREtopic*)p = *(struct __ns1__create_USCOREtopic*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__publish(struct soap *soap, struct __ns1__publish *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pass__publish = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__publish(struct soap *soap, const struct __ns1__publish *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__publish(soap, &a->pass__publish);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__publish(struct soap *soap, const char *tag, int id, const struct __ns1__publish *a, const char *type)
{
	if (soap_out_PointerTo_pass__publish(soap, "pass:publish", -1, &a->pass__publish, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__publish * SOAP_FMAC4 soap_in___ns1__publish(struct soap *soap, const char *tag, struct __ns1__publish *a, const char *type)
{
	size_t soap_flag_pass__publish = 1;
	short soap_flag;
	a = (struct __ns1__publish *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__publish, sizeof(struct __ns1__publish), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__publish(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pass__publish && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__publish(soap, "pass:publish", &a->pass__publish, ""))
				{	soap_flag_pass__publish--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__publish(struct soap *soap, const struct __ns1__publish *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__publish(soap, tag?tag:"-ns1:publish", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__publish * SOAP_FMAC4 soap_get___ns1__publish(struct soap *soap, struct __ns1__publish *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__publish(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__publish * SOAP_FMAC2 soap_instantiate___ns1__publish(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__publish(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__publish, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__publish);
		if (size)
			*size = sizeof(struct __ns1__publish);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__publish[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__publish);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__publish*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__publish(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__publish %p -> %p\n", q, p));
	*(struct __ns1__publish*)p = *(struct __ns1__publish*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__unsubscribe(struct soap *soap, struct __ns1__unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pass__unsubscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__unsubscribe(struct soap *soap, const struct __ns1__unsubscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__unsubscribe(soap, &a->pass__unsubscribe);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__unsubscribe(struct soap *soap, const char *tag, int id, const struct __ns1__unsubscribe *a, const char *type)
{
	if (soap_out_PointerTo_pass__unsubscribe(soap, "pass:unsubscribe", -1, &a->pass__unsubscribe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__unsubscribe * SOAP_FMAC4 soap_in___ns1__unsubscribe(struct soap *soap, const char *tag, struct __ns1__unsubscribe *a, const char *type)
{
	size_t soap_flag_pass__unsubscribe = 1;
	short soap_flag;
	a = (struct __ns1__unsubscribe *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__unsubscribe, sizeof(struct __ns1__unsubscribe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__unsubscribe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pass__unsubscribe && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__unsubscribe(soap, "pass:unsubscribe", &a->pass__unsubscribe, ""))
				{	soap_flag_pass__unsubscribe--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__unsubscribe(struct soap *soap, const struct __ns1__unsubscribe *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__unsubscribe(soap, tag?tag:"-ns1:unsubscribe", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__unsubscribe * SOAP_FMAC4 soap_get___ns1__unsubscribe(struct soap *soap, struct __ns1__unsubscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__unsubscribe * SOAP_FMAC2 soap_instantiate___ns1__unsubscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__unsubscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__unsubscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__unsubscribe);
		if (size)
			*size = sizeof(struct __ns1__unsubscribe);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__unsubscribe[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__unsubscribe);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__unsubscribe*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__unsubscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__unsubscribe %p -> %p\n", q, p));
	*(struct __ns1__unsubscribe*)p = *(struct __ns1__unsubscribe*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retract_USCOREtopic(struct soap *soap, struct __ns1__retract_USCOREtopic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pass__retract_USCOREtopic = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retract_USCOREtopic(struct soap *soap, const struct __ns1__retract_USCOREtopic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__retract_USCOREtopic(soap, &a->pass__retract_USCOREtopic);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retract_USCOREtopic(struct soap *soap, const char *tag, int id, const struct __ns1__retract_USCOREtopic *a, const char *type)
{
	if (soap_out_PointerTo_pass__retract_USCOREtopic(soap, "pass:retract_topic", -1, &a->pass__retract_USCOREtopic, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retract_USCOREtopic * SOAP_FMAC4 soap_in___ns1__retract_USCOREtopic(struct soap *soap, const char *tag, struct __ns1__retract_USCOREtopic *a, const char *type)
{
	size_t soap_flag_pass__retract_USCOREtopic = 1;
	short soap_flag;
	a = (struct __ns1__retract_USCOREtopic *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retract_USCOREtopic, sizeof(struct __ns1__retract_USCOREtopic), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retract_USCOREtopic(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pass__retract_USCOREtopic && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__retract_USCOREtopic(soap, "pass:retract_topic", &a->pass__retract_USCOREtopic, ""))
				{	soap_flag_pass__retract_USCOREtopic--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retract_USCOREtopic(struct soap *soap, const struct __ns1__retract_USCOREtopic *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__retract_USCOREtopic(soap, tag?tag:"-ns1:retract_topic", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retract_USCOREtopic * SOAP_FMAC4 soap_get___ns1__retract_USCOREtopic(struct soap *soap, struct __ns1__retract_USCOREtopic *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retract_USCOREtopic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__retract_USCOREtopic * SOAP_FMAC2 soap_instantiate___ns1__retract_USCOREtopic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retract_USCOREtopic(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__retract_USCOREtopic, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__retract_USCOREtopic);
		if (size)
			*size = sizeof(struct __ns1__retract_USCOREtopic);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__retract_USCOREtopic[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__retract_USCOREtopic);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__retract_USCOREtopic*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__retract_USCOREtopic(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__retract_USCOREtopic %p -> %p\n", q, p));
	*(struct __ns1__retract_USCOREtopic*)p = *(struct __ns1__retract_USCOREtopic*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__retract_USCOREitem(struct soap *soap, struct __ns1__retract_USCOREitem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pass__retract_USCOREitem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__retract_USCOREitem(struct soap *soap, const struct __ns1__retract_USCOREitem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__retract_USCOREitem(soap, &a->pass__retract_USCOREitem);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__retract_USCOREitem(struct soap *soap, const char *tag, int id, const struct __ns1__retract_USCOREitem *a, const char *type)
{
	if (soap_out_PointerTo_pass__retract_USCOREitem(soap, "pass:retract_item", -1, &a->pass__retract_USCOREitem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retract_USCOREitem * SOAP_FMAC4 soap_in___ns1__retract_USCOREitem(struct soap *soap, const char *tag, struct __ns1__retract_USCOREitem *a, const char *type)
{
	size_t soap_flag_pass__retract_USCOREitem = 1;
	short soap_flag;
	a = (struct __ns1__retract_USCOREitem *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__retract_USCOREitem, sizeof(struct __ns1__retract_USCOREitem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__retract_USCOREitem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pass__retract_USCOREitem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__retract_USCOREitem(soap, "pass:retract_item", &a->pass__retract_USCOREitem, ""))
				{	soap_flag_pass__retract_USCOREitem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__retract_USCOREitem(struct soap *soap, const struct __ns1__retract_USCOREitem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__retract_USCOREitem(soap, tag?tag:"-ns1:retract_item", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__retract_USCOREitem * SOAP_FMAC4 soap_get___ns1__retract_USCOREitem(struct soap *soap, struct __ns1__retract_USCOREitem *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__retract_USCOREitem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__retract_USCOREitem * SOAP_FMAC2 soap_instantiate___ns1__retract_USCOREitem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__retract_USCOREitem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__retract_USCOREitem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__retract_USCOREitem);
		if (size)
			*size = sizeof(struct __ns1__retract_USCOREitem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__retract_USCOREitem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__retract_USCOREitem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__retract_USCOREitem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__retract_USCOREitem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__retract_USCOREitem %p -> %p\n", q, p));
	*(struct __ns1__retract_USCOREitem*)p = *(struct __ns1__retract_USCOREitem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__subscribe(struct soap *soap, struct __ns1__subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pass__subscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__subscribe(struct soap *soap, const struct __ns1__subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_pass__subscribe(soap, &a->pass__subscribe);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__subscribe(struct soap *soap, const char *tag, int id, const struct __ns1__subscribe *a, const char *type)
{
	if (soap_out_PointerTo_pass__subscribe(soap, "pass:subscribe", -1, &a->pass__subscribe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__subscribe * SOAP_FMAC4 soap_in___ns1__subscribe(struct soap *soap, const char *tag, struct __ns1__subscribe *a, const char *type)
{
	size_t soap_flag_pass__subscribe = 1;
	short soap_flag;
	a = (struct __ns1__subscribe *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__subscribe, sizeof(struct __ns1__subscribe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__subscribe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pass__subscribe && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_pass__subscribe(soap, "pass:subscribe", &a->pass__subscribe, ""))
				{	soap_flag_pass__subscribe--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__subscribe(struct soap *soap, const struct __ns1__subscribe *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__subscribe(soap, tag?tag:"-ns1:subscribe", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__subscribe * SOAP_FMAC4 soap_get___ns1__subscribe(struct soap *soap, struct __ns1__subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__subscribe * SOAP_FMAC2 soap_instantiate___ns1__subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__subscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__subscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__subscribe);
		if (size)
			*size = sizeof(struct __ns1__subscribe);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__subscribe[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__subscribe);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__subscribe*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__subscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__subscribe %p -> %p\n", q, p));
	*(struct __ns1__subscribe*)p = *(struct __ns1__subscribe*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyAttribute(soap, &a->__anyAttribute);
	a->pass__pass_USCOREfault_ = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTopass__pass_USCOREfault(soap, &a->pass__pass_USCOREfault_);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_out_xsd__anyAttribute(soap, "-anyAttribute", -1, &a->__anyAttribute, ""))
		return soap->error;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTopass__pass_USCOREfault(soap, "pass:pass_fault", -1, &a->pass__pass_USCOREfault_, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_pass__pass_USCOREfault_ = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	soap_in_xsd__anyAttribute(soap, "-anyAttribute", &a->__anyAttribute, "xsd:anyAttribute");
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pass__pass_USCOREfault_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTopass__pass_USCOREfault(soap, "pass:pass_fault", &a->pass__pass_USCOREfault_, "pass:pass_fault"))
				{	soap_flag_pass__pass_USCOREfault_--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyAttribute(struct soap *soap, const struct soap_dom_attribute *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyAttribute);
	if (soap_out_xsd__anyAttribute(soap, tag?tag:"xsd:anyAttribute", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_attribute * SOAP_FMAC4 soap_get_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct soap_dom_attribute * SOAP_FMAC2 soap_instantiate_xsd__anyAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyAttribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyAttribute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct soap_dom_attribute);
		if (size)
			*size = sizeof(struct soap_dom_attribute);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct soap_dom_attribute[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct soap_dom_attribute);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct soap_dom_attribute*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyAttribute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct soap_dom_attribute %p -> %p\n", q, p));
	*(struct soap_dom_attribute*)p = *(struct soap_dom_attribute*)q;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyType(struct soap *soap, const struct soap_dom_element *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (soap_out_xsd__anyType(soap, tag?tag:"xsd:anyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct soap_dom_element * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, struct soap_dom_element *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct soap_dom_element * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct soap_dom_element);
		if (size)
			*size = sizeof(struct soap_dom_element);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct soap_dom_element[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct soap_dom_element);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct soap_dom_element*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct soap_dom_element %p -> %p\n", q, p));
	*(struct soap_dom_element*)p = *(struct soap_dom_element*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__pass__union_sync_USCOREresponse(struct soap *soap, int choice, const union _pass__union_sync_USCOREresponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__pass__union_sync_USCOREresponse_publish:
		soap_serialize_PointerTo_pass__publish(soap, &a->publish);
		break;
	case SOAP_UNION__pass__union_sync_USCOREresponse_create_USCOREtopic:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTo_pass__create_USCOREtopic(soap, &a->create_USCOREtopic);
		break;
	case SOAP_UNION__pass__union_sync_USCOREresponse_subscribe:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTo_pass__subscribe(soap, &a->subscribe);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__pass__union_sync_USCOREresponse(struct soap *soap, int choice, const union _pass__union_sync_USCOREresponse *a)
{
	switch (choice)
	{
	case SOAP_UNION__pass__union_sync_USCOREresponse_publish:
		return soap_out_PointerTo_pass__publish(soap, "pass:publish", -1, &a->publish, "");
	case SOAP_UNION__pass__union_sync_USCOREresponse_create_USCOREtopic:
		return soap_out_PointerTostd__vectorTemplateOfPointerTo_pass__create_USCOREtopic(soap, "pass:create_topic", -1, &a->create_USCOREtopic, "");
	case SOAP_UNION__pass__union_sync_USCOREresponse_subscribe:
		return soap_out_PointerTostd__vectorTemplateOfPointerTo_pass__subscribe(soap, "pass:subscribe", -1, &a->subscribe, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _pass__union_sync_USCOREresponse * SOAP_FMAC4 soap_in__pass__union_sync_USCOREresponse(struct soap *soap, int *choice, union _pass__union_sync_USCOREresponse *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->publish = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTo_pass__publish(soap, "pass:publish", &a->publish, ""))
	{	*choice = SOAP_UNION__pass__union_sync_USCOREresponse_publish;
		return a;
	}
	a->create_USCOREtopic = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTo_pass__create_USCOREtopic(soap, "pass:create_topic", &a->create_USCOREtopic, ""))
	{	*choice = SOAP_UNION__pass__union_sync_USCOREresponse_create_USCOREtopic;
		return a;
	}
	a->subscribe = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTo_pass__subscribe(soap, "pass:subscribe", &a->subscribe, ""))
	{	*choice = SOAP_UNION__pass__union_sync_USCOREresponse_subscribe;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_pass__sync_USCOREresponse(struct soap *soap, _pass__sync_USCOREresponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__pass__sync_USCOREresponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_pass__sync_USCOREresponse(struct soap *soap, const char *tag, int id, _pass__sync_USCOREresponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__pass__sync_USCOREresponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _pass__sync_USCOREresponse ** SOAP_FMAC4 soap_in_PointerTo_pass__sync_USCOREresponse(struct soap *soap, const char *tag, _pass__sync_USCOREresponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_pass__sync_USCOREresponse **)soap_malloc(soap, sizeof(_pass__sync_USCOREresponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_pass__sync_USCOREresponse *)soap_instantiate__pass__sync_USCOREresponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_pass__sync_USCOREresponse ** p = (_pass__sync_USCOREresponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__pass__sync_USCOREresponse, sizeof(_pass__sync_USCOREresponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_pass__sync_USCOREresponse(struct soap *soap, _pass__sync_USCOREresponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_pass__sync_USCOREresponse);
	if (soap_out_PointerTo_pass__sync_USCOREresponse(soap, tag?tag:"pass:sync_response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _pass__sync_USCOREresponse ** SOAP_FMAC4 soap_get_PointerTo_pass__sync_USCOREresponse(struct soap *soap, _pass__sync_USCOREresponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_pass__sync_USCOREresponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_pass__sync(struct soap *soap, _pass__sync *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__pass__sync))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_pass__sync(struct soap *soap, const char *tag, int id, _pass__sync *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__pass__sync);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _pass__sync ** SOAP_FMAC4 soap_in_PointerTo_pass__sync(struct soap *soap, const char *tag, _pass__sync **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_pass__sync **)soap_malloc(soap, sizeof(_pass__sync *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_pass__sync *)soap_instantiate__pass__sync(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_pass__sync ** p = (_pass__sync **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__pass__sync, sizeof(_pass__sync), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_pass__sync(struct soap *soap, _pass__sync *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_pass__sync);
	if (soap_out_PointerTo_pass__sync(soap, tag?tag:"pass:sync", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _pass__sync ** SOAP_FMAC4 soap_get_PointerTo_pass__sync(struct soap *soap, _pass__sync **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_pass__sync(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_pass__unsubscribe(struct soap *soap, _pass__unsubscribe *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__pass__unsubscribe))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_pass__unsubscribe(struct soap *soap, const char *tag, int id, _pass__unsubscribe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__pass__unsubscribe);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _pass__unsubscribe ** SOAP_FMAC4 soap_in_PointerTo_pass__unsubscribe(struct soap *soap, const char *tag, _pass__unsubscribe **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_pass__unsubscribe **)soap_malloc(soap, sizeof(_pass__unsubscribe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_pass__unsubscribe *)soap_instantiate__pass__unsubscribe(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_pass__unsubscribe ** p = (_pass__unsubscribe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__pass__unsubscribe, sizeof(_pass__unsubscribe), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_pass__unsubscribe(struct soap *soap, _pass__unsubscribe *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_pass__unsubscribe);
	if (soap_out_PointerTo_pass__unsubscribe(soap, tag?tag:"pass:unsubscribe", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _pass__unsubscribe ** SOAP_FMAC4 soap_get_PointerTo_pass__unsubscribe(struct soap *soap, _pass__unsubscribe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_pass__unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_pass__retract_USCOREtopic(struct soap *soap, _pass__retract_USCOREtopic *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__pass__retract_USCOREtopic))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_pass__retract_USCOREtopic(struct soap *soap, const char *tag, int id, _pass__retract_USCOREtopic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__pass__retract_USCOREtopic);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _pass__retract_USCOREtopic ** SOAP_FMAC4 soap_in_PointerTo_pass__retract_USCOREtopic(struct soap *soap, const char *tag, _pass__retract_USCOREtopic **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_pass__retract_USCOREtopic **)soap_malloc(soap, sizeof(_pass__retract_USCOREtopic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_pass__retract_USCOREtopic *)soap_instantiate__pass__retract_USCOREtopic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_pass__retract_USCOREtopic ** p = (_pass__retract_USCOREtopic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__pass__retract_USCOREtopic, sizeof(_pass__retract_USCOREtopic), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_pass__retract_USCOREtopic(struct soap *soap, _pass__retract_USCOREtopic *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_pass__retract_USCOREtopic);
	if (soap_out_PointerTo_pass__retract_USCOREtopic(soap, tag?tag:"pass:retract_topic", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _pass__retract_USCOREtopic ** SOAP_FMAC4 soap_get_PointerTo_pass__retract_USCOREtopic(struct soap *soap, _pass__retract_USCOREtopic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_pass__retract_USCOREtopic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_pass__retract_USCOREitem(struct soap *soap, _pass__retract_USCOREitem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__pass__retract_USCOREitem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_pass__retract_USCOREitem(struct soap *soap, const char *tag, int id, _pass__retract_USCOREitem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__pass__retract_USCOREitem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _pass__retract_USCOREitem ** SOAP_FMAC4 soap_in_PointerTo_pass__retract_USCOREitem(struct soap *soap, const char *tag, _pass__retract_USCOREitem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_pass__retract_USCOREitem **)soap_malloc(soap, sizeof(_pass__retract_USCOREitem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_pass__retract_USCOREitem *)soap_instantiate__pass__retract_USCOREitem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_pass__retract_USCOREitem ** p = (_pass__retract_USCOREitem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__pass__retract_USCOREitem, sizeof(_pass__retract_USCOREitem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_pass__retract_USCOREitem(struct soap *soap, _pass__retract_USCOREitem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_pass__retract_USCOREitem);
	if (soap_out_PointerTo_pass__retract_USCOREitem(soap, tag?tag:"pass:retract_item", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _pass__retract_USCOREitem ** SOAP_FMAC4 soap_get_PointerTo_pass__retract_USCOREitem(struct soap *soap, _pass__retract_USCOREitem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_pass__retract_USCOREitem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTopass__pass_USCOREfault(struct soap *soap, pass__pass_USCOREfault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_pass__pass_USCOREfault))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTopass__pass_USCOREfault(struct soap *soap, const char *tag, int id, pass__pass_USCOREfault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_pass__pass_USCOREfault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 pass__pass_USCOREfault ** SOAP_FMAC4 soap_in_PointerTopass__pass_USCOREfault(struct soap *soap, const char *tag, pass__pass_USCOREfault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (pass__pass_USCOREfault **)soap_malloc(soap, sizeof(pass__pass_USCOREfault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (pass__pass_USCOREfault *)soap_instantiate_pass__pass_USCOREfault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	pass__pass_USCOREfault ** p = (pass__pass_USCOREfault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_pass__pass_USCOREfault, sizeof(pass__pass_USCOREfault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTopass__pass_USCOREfault(struct soap *soap, pass__pass_USCOREfault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTopass__pass_USCOREfault);
	if (soap_out_PointerTopass__pass_USCOREfault(soap, tag?tag:"pass:pass_fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 pass__pass_USCOREfault ** SOAP_FMAC4 soap_get_PointerTopass__pass_USCOREfault(struct soap *soap, pass__pass_USCOREfault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTopass__pass_USCOREfault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTo_pass__subscribe(struct soap *soap, std::vector<_pass__subscribe * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTo_pass__subscribe))
		soap_serialize_std__vectorTemplateOfPointerTo_pass__subscribe(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTo_pass__subscribe(struct soap *soap, const char *tag, int id, std::vector<_pass__subscribe * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTo_pass__subscribe(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_pass__subscribe * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTo_pass__subscribe(struct soap *soap, const char *tag, std::vector<_pass__subscribe * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<_pass__subscribe * >**)soap_malloc(soap, sizeof(std::vector<_pass__subscribe * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTo_pass__subscribe(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTo_pass__subscribe(struct soap *soap, std::vector<_pass__subscribe * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTo_pass__subscribe);
	if (soap_out_PointerTostd__vectorTemplateOfPointerTo_pass__subscribe(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_pass__subscribe * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTo_pass__subscribe(struct soap *soap, std::vector<_pass__subscribe * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTo_pass__subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_pass__subscribe(struct soap *soap, _pass__subscribe *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__pass__subscribe))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_pass__subscribe(struct soap *soap, const char *tag, int id, _pass__subscribe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__pass__subscribe);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _pass__subscribe ** SOAP_FMAC4 soap_in_PointerTo_pass__subscribe(struct soap *soap, const char *tag, _pass__subscribe **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_pass__subscribe **)soap_malloc(soap, sizeof(_pass__subscribe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_pass__subscribe *)soap_instantiate__pass__subscribe(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_pass__subscribe ** p = (_pass__subscribe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__pass__subscribe, sizeof(_pass__subscribe), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_pass__subscribe(struct soap *soap, _pass__subscribe *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_pass__subscribe);
	if (soap_out_PointerTo_pass__subscribe(soap, tag?tag:"pass:subscribe", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _pass__subscribe ** SOAP_FMAC4 soap_get_PointerTo_pass__subscribe(struct soap *soap, _pass__subscribe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_pass__subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTo_pass__create_USCOREtopic(struct soap *soap, std::vector<_pass__create_USCOREtopic * >*const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic))
		soap_serialize_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTo_pass__create_USCOREtopic(struct soap *soap, const char *tag, int id, std::vector<_pass__create_USCOREtopic * >*const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<_pass__create_USCOREtopic * >** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTo_pass__create_USCOREtopic(struct soap *soap, const char *tag, std::vector<_pass__create_USCOREtopic * >**a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
		if (!(a = (std::vector<_pass__create_USCOREtopic * >**)soap_malloc(soap, sizeof(std::vector<_pass__create_USCOREtopic * >*))))
			return NULL;
	if (!(*a = soap_in_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTo_pass__create_USCOREtopic(struct soap *soap, std::vector<_pass__create_USCOREtopic * >*const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTo_pass__create_USCOREtopic);
	if (soap_out_PointerTostd__vectorTemplateOfPointerTo_pass__create_USCOREtopic(soap, tag?tag:"", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<_pass__create_USCOREtopic * >** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTo_pass__create_USCOREtopic(struct soap *soap, std::vector<_pass__create_USCOREtopic * >**p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTo_pass__create_USCOREtopic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_pass__create_USCOREtopic(struct soap *soap, _pass__create_USCOREtopic *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__pass__create_USCOREtopic))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_pass__create_USCOREtopic(struct soap *soap, const char *tag, int id, _pass__create_USCOREtopic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__pass__create_USCOREtopic);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _pass__create_USCOREtopic ** SOAP_FMAC4 soap_in_PointerTo_pass__create_USCOREtopic(struct soap *soap, const char *tag, _pass__create_USCOREtopic **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_pass__create_USCOREtopic **)soap_malloc(soap, sizeof(_pass__create_USCOREtopic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_pass__create_USCOREtopic *)soap_instantiate__pass__create_USCOREtopic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_pass__create_USCOREtopic ** p = (_pass__create_USCOREtopic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__pass__create_USCOREtopic, sizeof(_pass__create_USCOREtopic), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_pass__create_USCOREtopic(struct soap *soap, _pass__create_USCOREtopic *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_pass__create_USCOREtopic);
	if (soap_out_PointerTo_pass__create_USCOREtopic(soap, tag?tag:"pass:create_topic", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _pass__create_USCOREtopic ** SOAP_FMAC4 soap_get_PointerTo_pass__create_USCOREtopic(struct soap *soap, _pass__create_USCOREtopic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_pass__create_USCOREtopic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_pass__publish(struct soap *soap, _pass__publish *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__pass__publish))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_pass__publish(struct soap *soap, const char *tag, int id, _pass__publish *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__pass__publish);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _pass__publish ** SOAP_FMAC4 soap_in_PointerTo_pass__publish(struct soap *soap, const char *tag, _pass__publish **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_pass__publish **)soap_malloc(soap, sizeof(_pass__publish *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_pass__publish *)soap_instantiate__pass__publish(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_pass__publish ** p = (_pass__publish **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__pass__publish, sizeof(_pass__publish), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_pass__publish(struct soap *soap, _pass__publish *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_pass__publish);
	if (soap_out_PointerTo_pass__publish(soap, tag?tag:"pass:publish", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _pass__publish ** SOAP_FMAC4 soap_get_PointerTo_pass__publish(struct soap *soap, _pass__publish **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_pass__publish(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger))
		soap_serialize_xsd__nonNegativeInteger(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__nonNegativeInteger);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__nonNegativeInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__nonNegativeInteger);
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTopass__item(struct soap *soap, pass__item *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_pass__item))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTopass__item(struct soap *soap, const char *tag, int id, pass__item *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_pass__item);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 pass__item ** SOAP_FMAC4 soap_in_PointerTopass__item(struct soap *soap, const char *tag, pass__item **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (pass__item **)soap_malloc(soap, sizeof(pass__item *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (pass__item *)soap_instantiate_pass__item(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	pass__item ** p = (pass__item **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_pass__item, sizeof(pass__item), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTopass__item(struct soap *soap, pass__item *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTopass__item);
	if (soap_out_PointerTopass__item(soap, tag?tag:"pass:item", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 pass__item ** SOAP_FMAC4 soap_get_PointerTopass__item(struct soap *soap, pass__item **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTopass__item(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_pass__References_ReferenceObj(struct soap *soap, _pass__References_ReferenceObj *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__pass__References_ReferenceObj))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_pass__References_ReferenceObj(struct soap *soap, const char *tag, int id, _pass__References_ReferenceObj *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__pass__References_ReferenceObj);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _pass__References_ReferenceObj ** SOAP_FMAC4 soap_in_PointerTo_pass__References_ReferenceObj(struct soap *soap, const char *tag, _pass__References_ReferenceObj **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_pass__References_ReferenceObj **)soap_malloc(soap, sizeof(_pass__References_ReferenceObj *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_pass__References_ReferenceObj *)soap_instantiate__pass__References_ReferenceObj(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_pass__References_ReferenceObj ** p = (_pass__References_ReferenceObj **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__pass__References_ReferenceObj, sizeof(_pass__References_ReferenceObj), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_pass__References_ReferenceObj(struct soap *soap, _pass__References_ReferenceObj *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_pass__References_ReferenceObj);
	if (soap_out_PointerTo_pass__References_ReferenceObj(soap, tag?tag:"pass:References-ReferenceObj", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _pass__References_ReferenceObj ** SOAP_FMAC4 soap_get_PointerTo_pass__References_ReferenceObj(struct soap *soap, _pass__References_ReferenceObj **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_pass__References_ReferenceObj(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xlink__actuate(struct soap *soap, enum _xlink__actuate *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__xlink__actuate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xlink__actuate(struct soap *soap, const char *tag, int id, enum _xlink__actuate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xlink__actuate);
	if (id < 0)
		return soap->error;
	return soap_out__xlink__actuate(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _xlink__actuate ** SOAP_FMAC4 soap_in_PointerTo_xlink__actuate(struct soap *soap, const char *tag, enum _xlink__actuate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _xlink__actuate **)soap_malloc(soap, sizeof(enum _xlink__actuate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xlink__actuate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _xlink__actuate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xlink__actuate, sizeof(enum _xlink__actuate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xlink__actuate(struct soap *soap, enum _xlink__actuate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xlink__actuate);
	if (soap_out_PointerTo_xlink__actuate(soap, tag?tag:"xlink:actuate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _xlink__actuate ** SOAP_FMAC4 soap_get_PointerTo_xlink__actuate(struct soap *soap, enum _xlink__actuate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xlink__actuate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xlink__show(struct soap *soap, enum _xlink__show *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__xlink__show);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xlink__show(struct soap *soap, const char *tag, int id, enum _xlink__show *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xlink__show);
	if (id < 0)
		return soap->error;
	return soap_out__xlink__show(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum _xlink__show ** SOAP_FMAC4 soap_in_PointerTo_xlink__show(struct soap *soap, const char *tag, enum _xlink__show **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum _xlink__show **)soap_malloc(soap, sizeof(enum _xlink__show *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xlink__show(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum _xlink__show **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xlink__show, sizeof(enum _xlink__show), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xlink__show(struct soap *soap, enum _xlink__show *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xlink__show);
	if (soap_out_PointerTo_xlink__show(soap, tag?tag:"xlink:show", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _xlink__show ** SOAP_FMAC4 soap_get_PointerTo_xlink__show(struct soap *soap, enum _xlink__show **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xlink__show(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_pass__References(struct soap *soap, _pass__References *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__pass__References))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_pass__References(struct soap *soap, const char *tag, int id, _pass__References *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__pass__References);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _pass__References ** SOAP_FMAC4 soap_in_PointerTo_pass__References(struct soap *soap, const char *tag, _pass__References **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_pass__References **)soap_malloc(soap, sizeof(_pass__References *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_pass__References *)soap_instantiate__pass__References(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_pass__References ** p = (_pass__References **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__pass__References, sizeof(_pass__References), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_pass__References(struct soap *soap, _pass__References *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_pass__References);
	if (soap_out_PointerTo_pass__References(soap, tag?tag:"pass:References", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _pass__References ** SOAP_FMAC4 soap_get_PointerTo_pass__References(struct soap *soap, _pass__References **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_pass__References(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTopass__item_USCOREdata(struct soap *soap, pass__item_USCOREdata *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_pass__item_USCOREdata))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTopass__item_USCOREdata(struct soap *soap, const char *tag, int id, pass__item_USCOREdata *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_pass__item_USCOREdata);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 pass__item_USCOREdata ** SOAP_FMAC4 soap_in_PointerTopass__item_USCOREdata(struct soap *soap, const char *tag, pass__item_USCOREdata **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (pass__item_USCOREdata **)soap_malloc(soap, sizeof(pass__item_USCOREdata *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (pass__item_USCOREdata *)soap_instantiate_pass__item_USCOREdata(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	pass__item_USCOREdata ** p = (pass__item_USCOREdata **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_pass__item_USCOREdata, sizeof(pass__item_USCOREdata), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTopass__item_USCOREdata(struct soap *soap, pass__item_USCOREdata *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTopass__item_USCOREdata);
	if (soap_out_PointerTopass__item_USCOREdata(soap, tag?tag:"pass:item_data", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 pass__item_USCOREdata ** SOAP_FMAC4 soap_get_PointerTopass__item_USCOREdata(struct soap *soap, pass__item_USCOREdata **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTopass__item_USCOREdata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_pass__AOI_USCORErectangle(struct soap *soap, _pass__AOI_USCORErectangle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__pass__AOI_USCORErectangle))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_pass__AOI_USCORErectangle(struct soap *soap, const char *tag, int id, _pass__AOI_USCORErectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__pass__AOI_USCORErectangle);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _pass__AOI_USCORErectangle ** SOAP_FMAC4 soap_in_PointerTo_pass__AOI_USCORErectangle(struct soap *soap, const char *tag, _pass__AOI_USCORErectangle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_pass__AOI_USCORErectangle **)soap_malloc(soap, sizeof(_pass__AOI_USCORErectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_pass__AOI_USCORErectangle *)soap_instantiate__pass__AOI_USCORErectangle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_pass__AOI_USCORErectangle ** p = (_pass__AOI_USCORErectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__pass__AOI_USCORErectangle, sizeof(_pass__AOI_USCORErectangle), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_pass__AOI_USCORErectangle(struct soap *soap, _pass__AOI_USCORErectangle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_pass__AOI_USCORErectangle);
	if (soap_out_PointerTo_pass__AOI_USCORErectangle(soap, tag?tag:"pass:AOI_rectangle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _pass__AOI_USCORErectangle ** SOAP_FMAC4 soap_get_PointerTo_pass__AOI_USCORErectangle(struct soap *soap, _pass__AOI_USCORErectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_pass__AOI_USCORErectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTopass__status(struct soap *soap, pass__status *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_pass__status))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTopass__status(struct soap *soap, const char *tag, int id, pass__status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_pass__status);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 pass__status ** SOAP_FMAC4 soap_in_PointerTopass__status(struct soap *soap, const char *tag, pass__status **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (pass__status **)soap_malloc(soap, sizeof(pass__status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (pass__status *)soap_instantiate_pass__status(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	pass__status ** p = (pass__status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_pass__status, sizeof(pass__status), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTopass__status(struct soap *soap, pass__status *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTopass__status);
	if (soap_out_PointerTopass__status(soap, tag?tag:"pass:status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 pass__status ** SOAP_FMAC4 soap_get_PointerTopass__status(struct soap *soap, pass__status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTopass__status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_pass__subscribe(struct soap *soap, std::vector<_pass__subscribe * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_pass__subscribe(struct soap *soap, const std::vector<_pass__subscribe * >*a)
{
	for (std::vector<_pass__subscribe * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_pass__subscribe(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_pass__subscribe(struct soap *soap, const char *tag, int id, const std::vector<_pass__subscribe * >*a, const char *type)
{
	for (std::vector<_pass__subscribe * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_pass__subscribe(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_pass__subscribe * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_pass__subscribe(struct soap *soap, const char *tag, std::vector<_pass__subscribe * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_pass__subscribe(soap, -1)))
		return NULL;
	_pass__subscribe *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__pass__subscribe, SOAP_TYPE_std__vectorTemplateOfPointerTo_pass__subscribe, sizeof(_pass__subscribe), 1))
				break;
			if (!soap_in_PointerTo_pass__subscribe(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_pass__subscribe(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_pass__subscribe * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTo_pass__subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_pass__subscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_pass__subscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_pass__subscribe * >);
		if (size)
			*size = sizeof(std::vector<_pass__subscribe * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_pass__subscribe * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_pass__subscribe * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_pass__subscribe * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_pass__subscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_pass__subscribe * > %p -> %p\n", q, p));
	*(std::vector<_pass__subscribe * >*)p = *(std::vector<_pass__subscribe * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic(struct soap *soap, std::vector<_pass__create_USCOREtopic * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic(struct soap *soap, const std::vector<_pass__create_USCOREtopic * >*a)
{
	for (std::vector<_pass__create_USCOREtopic * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_pass__create_USCOREtopic(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic(struct soap *soap, const char *tag, int id, const std::vector<_pass__create_USCOREtopic * >*a, const char *type)
{
	for (std::vector<_pass__create_USCOREtopic * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_pass__create_USCOREtopic(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_pass__create_USCOREtopic * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic(struct soap *soap, const char *tag, std::vector<_pass__create_USCOREtopic * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic(soap, -1)))
		return NULL;
	_pass__create_USCOREtopic *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__pass__create_USCOREtopic, SOAP_TYPE_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic, sizeof(_pass__create_USCOREtopic), 1))
				break;
			if (!soap_in_PointerTo_pass__create_USCOREtopic(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_pass__create_USCOREtopic(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_pass__create_USCOREtopic * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_pass__create_USCOREtopic * >);
		if (size)
			*size = sizeof(std::vector<_pass__create_USCOREtopic * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<_pass__create_USCOREtopic * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_pass__create_USCOREtopic * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_pass__create_USCOREtopic * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_pass__create_USCOREtopic(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_pass__create_USCOREtopic * > %p -> %p\n", q, p));
	*(std::vector<_pass__create_USCOREtopic * >*)p = *(std::vector<_pass__create_USCOREtopic * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTopass__item(struct soap *soap, std::vector<pass__item * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTopass__item(struct soap *soap, const std::vector<pass__item * >*a)
{
	for (std::vector<pass__item * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTopass__item(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTopass__item(struct soap *soap, const char *tag, int id, const std::vector<pass__item * >*a, const char *type)
{
	for (std::vector<pass__item * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTopass__item(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<pass__item * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTopass__item(struct soap *soap, const char *tag, std::vector<pass__item * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTopass__item(soap, -1)))
		return NULL;
	pass__item *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_pass__item, SOAP_TYPE_std__vectorTemplateOfPointerTopass__item, sizeof(pass__item), 1))
				break;
			if (!soap_in_PointerTopass__item(soap, tag, NULL, "pass:item"))
				break;
		}
		else
		{
			if (!soap_in_PointerTopass__item(soap, tag, &n, "pass:item"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<pass__item * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTopass__item(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTopass__item(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTopass__item, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<pass__item * >);
		if (size)
			*size = sizeof(std::vector<pass__item * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<pass__item * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<pass__item * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<pass__item * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTopass__item(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<pass__item * > %p -> %p\n", q, p));
	*(std::vector<pass__item * >*)p = *(std::vector<pass__item * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
