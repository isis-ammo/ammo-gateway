// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AmmoMessages.proto

#ifndef PROTOBUF_AmmoMessages_2eproto__INCLUDED
#define PROTOBUF_AmmoMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace ammo {
namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AmmoMessages_2eproto();
void protobuf_AssignDesc_AmmoMessages_2eproto();
void protobuf_ShutdownFile_AmmoMessages_2eproto();

class DataMessage;
class PushAcknowledgement;
class AuthenticationMessage;
class SubscribeMessage;
class AuthenticationResult;
class PullRequest;
class PullResponse;
class MessageWrapper;

enum AuthenticationResult_Status {
  AuthenticationResult_Status_FAILED = 0,
  AuthenticationResult_Status_SUCCESS = 1
};
bool AuthenticationResult_Status_IsValid(int value);
const AuthenticationResult_Status AuthenticationResult_Status_Status_MIN = AuthenticationResult_Status_FAILED;
const AuthenticationResult_Status AuthenticationResult_Status_Status_MAX = AuthenticationResult_Status_SUCCESS;
const int AuthenticationResult_Status_Status_ARRAYSIZE = AuthenticationResult_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthenticationResult_Status_descriptor();
inline const ::std::string& AuthenticationResult_Status_Name(AuthenticationResult_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthenticationResult_Status_descriptor(), value);
}
inline bool AuthenticationResult_Status_Parse(
    const ::std::string& name, AuthenticationResult_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthenticationResult_Status>(
    AuthenticationResult_Status_descriptor(), name, value);
}
enum MessageWrapper_MessageType {
  MessageWrapper_MessageType_DATA_MESSAGE = 0,
  MessageWrapper_MessageType_AUTHENTICATION_MESSAGE = 1,
  MessageWrapper_MessageType_AUTHENTICATION_RESULT = 2,
  MessageWrapper_MessageType_SUBSCRIBE_MESSAGE = 4,
  MessageWrapper_MessageType_PUSH_ACKNOWLEDGEMENT = 5,
  MessageWrapper_MessageType_PULL_REQUEST = 6,
  MessageWrapper_MessageType_PULL_RESPONSE = 7
};
bool MessageWrapper_MessageType_IsValid(int value);
const MessageWrapper_MessageType MessageWrapper_MessageType_MessageType_MIN = MessageWrapper_MessageType_DATA_MESSAGE;
const MessageWrapper_MessageType MessageWrapper_MessageType_MessageType_MAX = MessageWrapper_MessageType_PULL_RESPONSE;
const int MessageWrapper_MessageType_MessageType_ARRAYSIZE = MessageWrapper_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageWrapper_MessageType_descriptor();
inline const ::std::string& MessageWrapper_MessageType_Name(MessageWrapper_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageWrapper_MessageType_descriptor(), value);
}
inline bool MessageWrapper_MessageType_Parse(
    const ::std::string& name, MessageWrapper_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageWrapper_MessageType>(
    MessageWrapper_MessageType_descriptor(), name, value);
}
// ===================================================================

class DataMessage : public ::google::protobuf::Message {
 public:
  DataMessage();
  virtual ~DataMessage();
  
  DataMessage(const DataMessage& from);
  
  inline DataMessage& operator=(const DataMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataMessage& default_instance();
  
  void Swap(DataMessage* other);
  
  // implements Message ----------------------------------------------
  
  DataMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataMessage& from);
  void MergeFrom(const DataMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uri = 1;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 1;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  
  // optional string mime_type = 3;
  inline bool has_mime_type() const;
  inline void clear_mime_type();
  static const int kMimeTypeFieldNumber = 3;
  inline const ::std::string& mime_type() const;
  inline void set_mime_type(const ::std::string& value);
  inline void set_mime_type(const char* value);
  inline void set_mime_type(const char* value, size_t size);
  inline ::std::string* mutable_mime_type();
  
  // optional bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // @@protoc_insertion_point(class_scope:ammo.protocol.DataMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* uri_;
  static const ::std::string _default_uri_;
  ::std::string* mime_type_;
  static const ::std::string _default_mime_type_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  friend void  protobuf_AddDesc_AmmoMessages_2eproto();
  friend void protobuf_AssignDesc_AmmoMessages_2eproto();
  friend void protobuf_ShutdownFile_AmmoMessages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DataMessage* default_instance_;
};
// -------------------------------------------------------------------

class PushAcknowledgement : public ::google::protobuf::Message {
 public:
  PushAcknowledgement();
  virtual ~PushAcknowledgement();
  
  PushAcknowledgement(const PushAcknowledgement& from);
  
  inline PushAcknowledgement& operator=(const PushAcknowledgement& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PushAcknowledgement& default_instance();
  
  void Swap(PushAcknowledgement* other);
  
  // implements Message ----------------------------------------------
  
  PushAcknowledgement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PushAcknowledgement& from);
  void MergeFrom(const PushAcknowledgement& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uri = 1;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 1;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  
  // @@protoc_insertion_point(class_scope:ammo.protocol.PushAcknowledgement)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* uri_;
  static const ::std::string _default_uri_;
  friend void  protobuf_AddDesc_AmmoMessages_2eproto();
  friend void protobuf_AssignDesc_AmmoMessages_2eproto();
  friend void protobuf_ShutdownFile_AmmoMessages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PushAcknowledgement* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticationMessage : public ::google::protobuf::Message {
 public:
  AuthenticationMessage();
  virtual ~AuthenticationMessage();
  
  AuthenticationMessage(const AuthenticationMessage& from);
  
  inline AuthenticationMessage& operator=(const AuthenticationMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticationMessage& default_instance();
  
  void Swap(AuthenticationMessage* other);
  
  // implements Message ----------------------------------------------
  
  AuthenticationMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticationMessage& from);
  void MergeFrom(const AuthenticationMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  
  // required string user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  
  // required string user_key = 3;
  inline bool has_user_key() const;
  inline void clear_user_key();
  static const int kUserKeyFieldNumber = 3;
  inline const ::std::string& user_key() const;
  inline void set_user_key(const ::std::string& value);
  inline void set_user_key(const char* value);
  inline void set_user_key(const char* value, size_t size);
  inline ::std::string* mutable_user_key();
  
  // @@protoc_insertion_point(class_scope:ammo.protocol.AuthenticationMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* device_id_;
  static const ::std::string _default_device_id_;
  ::std::string* user_id_;
  static const ::std::string _default_user_id_;
  ::std::string* user_key_;
  static const ::std::string _default_user_key_;
  friend void  protobuf_AddDesc_AmmoMessages_2eproto();
  friend void protobuf_AssignDesc_AmmoMessages_2eproto();
  friend void protobuf_ShutdownFile_AmmoMessages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AuthenticationMessage* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeMessage : public ::google::protobuf::Message {
 public:
  SubscribeMessage();
  virtual ~SubscribeMessage();
  
  SubscribeMessage(const SubscribeMessage& from);
  
  inline SubscribeMessage& operator=(const SubscribeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeMessage& default_instance();
  
  void Swap(SubscribeMessage* other);
  
  // implements Message ----------------------------------------------
  
  SubscribeMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeMessage& from);
  void MergeFrom(const SubscribeMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string mime_type = 1;
  inline bool has_mime_type() const;
  inline void clear_mime_type();
  static const int kMimeTypeFieldNumber = 1;
  inline const ::std::string& mime_type() const;
  inline void set_mime_type(const ::std::string& value);
  inline void set_mime_type(const char* value);
  inline void set_mime_type(const char* value, size_t size);
  inline ::std::string* mutable_mime_type();
  
  // optional string query = 2;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 2;
  inline const ::std::string& query() const;
  inline void set_query(const ::std::string& value);
  inline void set_query(const char* value);
  inline void set_query(const char* value, size_t size);
  inline ::std::string* mutable_query();
  
  // @@protoc_insertion_point(class_scope:ammo.protocol.SubscribeMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* mime_type_;
  static const ::std::string _default_mime_type_;
  ::std::string* query_;
  static const ::std::string _default_query_;
  friend void  protobuf_AddDesc_AmmoMessages_2eproto();
  friend void protobuf_AssignDesc_AmmoMessages_2eproto();
  friend void protobuf_ShutdownFile_AmmoMessages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SubscribeMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticationResult : public ::google::protobuf::Message {
 public:
  AuthenticationResult();
  virtual ~AuthenticationResult();
  
  AuthenticationResult(const AuthenticationResult& from);
  
  inline AuthenticationResult& operator=(const AuthenticationResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticationResult& default_instance();
  
  void Swap(AuthenticationResult* other);
  
  // implements Message ----------------------------------------------
  
  AuthenticationResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticationResult& from);
  void MergeFrom(const AuthenticationResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef AuthenticationResult_Status Status;
  static const Status FAILED = AuthenticationResult_Status_FAILED;
  static const Status SUCCESS = AuthenticationResult_Status_SUCCESS;
  static inline bool Status_IsValid(int value) {
    return AuthenticationResult_Status_IsValid(value);
  }
  static const Status Status_MIN =
    AuthenticationResult_Status_Status_MIN;
  static const Status Status_MAX =
    AuthenticationResult_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    AuthenticationResult_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return AuthenticationResult_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return AuthenticationResult_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return AuthenticationResult_Status_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .ammo.protocol.AuthenticationResult.Status result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::ammo::protocol::AuthenticationResult_Status result() const;
  inline void set_result(::ammo::protocol::AuthenticationResult_Status value);
  
  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  
  // @@protoc_insertion_point(class_scope:ammo.protocol.AuthenticationResult)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int result_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  friend void  protobuf_AddDesc_AmmoMessages_2eproto();
  friend void protobuf_AssignDesc_AmmoMessages_2eproto();
  friend void protobuf_ShutdownFile_AmmoMessages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AuthenticationResult* default_instance_;
};
// -------------------------------------------------------------------

class PullRequest : public ::google::protobuf::Message {
 public:
  PullRequest();
  virtual ~PullRequest();
  
  PullRequest(const PullRequest& from);
  
  inline PullRequest& operator=(const PullRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PullRequest& default_instance();
  
  void Swap(PullRequest* other);
  
  // implements Message ----------------------------------------------
  
  PullRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PullRequest& from);
  void MergeFrom(const PullRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string request_uid = 1;
  inline bool has_request_uid() const;
  inline void clear_request_uid();
  static const int kRequestUidFieldNumber = 1;
  inline const ::std::string& request_uid() const;
  inline void set_request_uid(const ::std::string& value);
  inline void set_request_uid(const char* value);
  inline void set_request_uid(const char* value, size_t size);
  inline ::std::string* mutable_request_uid();
  
  // required string plugin_id = 2;
  inline bool has_plugin_id() const;
  inline void clear_plugin_id();
  static const int kPluginIdFieldNumber = 2;
  inline const ::std::string& plugin_id() const;
  inline void set_plugin_id(const ::std::string& value);
  inline void set_plugin_id(const char* value);
  inline void set_plugin_id(const char* value, size_t size);
  inline ::std::string* mutable_plugin_id();
  
  // required string mime_type = 3;
  inline bool has_mime_type() const;
  inline void clear_mime_type();
  static const int kMimeTypeFieldNumber = 3;
  inline const ::std::string& mime_type() const;
  inline void set_mime_type(const ::std::string& value);
  inline void set_mime_type(const char* value);
  inline void set_mime_type(const char* value, size_t size);
  inline ::std::string* mutable_mime_type();
  
  // required string query = 4;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 4;
  inline const ::std::string& query() const;
  inline void set_query(const ::std::string& value);
  inline void set_query(const char* value);
  inline void set_query(const char* value, size_t size);
  inline ::std::string* mutable_query();
  
  // optional string projection = 5;
  inline bool has_projection() const;
  inline void clear_projection();
  static const int kProjectionFieldNumber = 5;
  inline const ::std::string& projection() const;
  inline void set_projection(const ::std::string& value);
  inline void set_projection(const char* value);
  inline void set_projection(const char* value, size_t size);
  inline ::std::string* mutable_projection();
  
  // optional uint32 max_results = 6 [default = 0];
  inline bool has_max_results() const;
  inline void clear_max_results();
  static const int kMaxResultsFieldNumber = 6;
  inline ::google::protobuf::uint32 max_results() const;
  inline void set_max_results(::google::protobuf::uint32 value);
  
  // optional uint32 start_from_count = 7 [default = 0];
  inline bool has_start_from_count() const;
  inline void clear_start_from_count();
  static const int kStartFromCountFieldNumber = 7;
  inline ::google::protobuf::uint32 start_from_count() const;
  inline void set_start_from_count(::google::protobuf::uint32 value);
  
  // optional bool live_query = 8 [default = false];
  inline bool has_live_query() const;
  inline void clear_live_query();
  static const int kLiveQueryFieldNumber = 8;
  inline bool live_query() const;
  inline void set_live_query(bool value);
  
  // @@protoc_insertion_point(class_scope:ammo.protocol.PullRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* request_uid_;
  static const ::std::string _default_request_uid_;
  ::std::string* plugin_id_;
  static const ::std::string _default_plugin_id_;
  ::std::string* mime_type_;
  static const ::std::string _default_mime_type_;
  ::std::string* query_;
  static const ::std::string _default_query_;
  ::std::string* projection_;
  static const ::std::string _default_projection_;
  ::google::protobuf::uint32 max_results_;
  ::google::protobuf::uint32 start_from_count_;
  bool live_query_;
  friend void  protobuf_AddDesc_AmmoMessages_2eproto();
  friend void protobuf_AssignDesc_AmmoMessages_2eproto();
  friend void protobuf_ShutdownFile_AmmoMessages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PullRequest* default_instance_;
};
// -------------------------------------------------------------------

class PullResponse : public ::google::protobuf::Message {
 public:
  PullResponse();
  virtual ~PullResponse();
  
  PullResponse(const PullResponse& from);
  
  inline PullResponse& operator=(const PullResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PullResponse& default_instance();
  
  void Swap(PullResponse* other);
  
  // implements Message ----------------------------------------------
  
  PullResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PullResponse& from);
  void MergeFrom(const PullResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string request_uid = 1;
  inline bool has_request_uid() const;
  inline void clear_request_uid();
  static const int kRequestUidFieldNumber = 1;
  inline const ::std::string& request_uid() const;
  inline void set_request_uid(const ::std::string& value);
  inline void set_request_uid(const char* value);
  inline void set_request_uid(const char* value, size_t size);
  inline ::std::string* mutable_request_uid();
  
  // required string plugin_id = 2;
  inline bool has_plugin_id() const;
  inline void clear_plugin_id();
  static const int kPluginIdFieldNumber = 2;
  inline const ::std::string& plugin_id() const;
  inline void set_plugin_id(const ::std::string& value);
  inline void set_plugin_id(const char* value);
  inline void set_plugin_id(const char* value, size_t size);
  inline ::std::string* mutable_plugin_id();
  
  // required string mime_type = 3;
  inline bool has_mime_type() const;
  inline void clear_mime_type();
  static const int kMimeTypeFieldNumber = 3;
  inline const ::std::string& mime_type() const;
  inline void set_mime_type(const ::std::string& value);
  inline void set_mime_type(const char* value);
  inline void set_mime_type(const char* value, size_t size);
  inline ::std::string* mutable_mime_type();
  
  // required string uri = 4;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 4;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  
  // required bytes data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // @@protoc_insertion_point(class_scope:ammo.protocol.PullResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* request_uid_;
  static const ::std::string _default_request_uid_;
  ::std::string* plugin_id_;
  static const ::std::string _default_plugin_id_;
  ::std::string* mime_type_;
  static const ::std::string _default_mime_type_;
  ::std::string* uri_;
  static const ::std::string _default_uri_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  friend void  protobuf_AddDesc_AmmoMessages_2eproto();
  friend void protobuf_AssignDesc_AmmoMessages_2eproto();
  friend void protobuf_ShutdownFile_AmmoMessages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PullResponse* default_instance_;
};
// -------------------------------------------------------------------

class MessageWrapper : public ::google::protobuf::Message {
 public:
  MessageWrapper();
  virtual ~MessageWrapper();
  
  MessageWrapper(const MessageWrapper& from);
  
  inline MessageWrapper& operator=(const MessageWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageWrapper& default_instance();
  
  void Swap(MessageWrapper* other);
  
  // implements Message ----------------------------------------------
  
  MessageWrapper* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageWrapper& from);
  void MergeFrom(const MessageWrapper& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MessageWrapper_MessageType MessageType;
  static const MessageType DATA_MESSAGE = MessageWrapper_MessageType_DATA_MESSAGE;
  static const MessageType AUTHENTICATION_MESSAGE = MessageWrapper_MessageType_AUTHENTICATION_MESSAGE;
  static const MessageType AUTHENTICATION_RESULT = MessageWrapper_MessageType_AUTHENTICATION_RESULT;
  static const MessageType SUBSCRIBE_MESSAGE = MessageWrapper_MessageType_SUBSCRIBE_MESSAGE;
  static const MessageType PUSH_ACKNOWLEDGEMENT = MessageWrapper_MessageType_PUSH_ACKNOWLEDGEMENT;
  static const MessageType PULL_REQUEST = MessageWrapper_MessageType_PULL_REQUEST;
  static const MessageType PULL_RESPONSE = MessageWrapper_MessageType_PULL_RESPONSE;
  static inline bool MessageType_IsValid(int value) {
    return MessageWrapper_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    MessageWrapper_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    MessageWrapper_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    MessageWrapper_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return MessageWrapper_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return MessageWrapper_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return MessageWrapper_MessageType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .ammo.protocol.MessageWrapper.MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ammo::protocol::MessageWrapper_MessageType type() const;
  inline void set_type(::ammo::protocol::MessageWrapper_MessageType value);
  
  // optional string session_uuid = 2;
  inline bool has_session_uuid() const;
  inline void clear_session_uuid();
  static const int kSessionUuidFieldNumber = 2;
  inline const ::std::string& session_uuid() const;
  inline void set_session_uuid(const ::std::string& value);
  inline void set_session_uuid(const char* value);
  inline void set_session_uuid(const char* value, size_t size);
  inline ::std::string* mutable_session_uuid();
  
  // optional .ammo.protocol.DataMessage data_message = 3;
  inline bool has_data_message() const;
  inline void clear_data_message();
  static const int kDataMessageFieldNumber = 3;
  inline const ::ammo::protocol::DataMessage& data_message() const;
  inline ::ammo::protocol::DataMessage* mutable_data_message();
  
  // optional .ammo.protocol.AuthenticationMessage authentication_message = 4;
  inline bool has_authentication_message() const;
  inline void clear_authentication_message();
  static const int kAuthenticationMessageFieldNumber = 4;
  inline const ::ammo::protocol::AuthenticationMessage& authentication_message() const;
  inline ::ammo::protocol::AuthenticationMessage* mutable_authentication_message();
  
  // optional .ammo.protocol.AuthenticationResult authentication_result = 5;
  inline bool has_authentication_result() const;
  inline void clear_authentication_result();
  static const int kAuthenticationResultFieldNumber = 5;
  inline const ::ammo::protocol::AuthenticationResult& authentication_result() const;
  inline ::ammo::protocol::AuthenticationResult* mutable_authentication_result();
  
  // optional .ammo.protocol.SubscribeMessage subscribe_message = 6;
  inline bool has_subscribe_message() const;
  inline void clear_subscribe_message();
  static const int kSubscribeMessageFieldNumber = 6;
  inline const ::ammo::protocol::SubscribeMessage& subscribe_message() const;
  inline ::ammo::protocol::SubscribeMessage* mutable_subscribe_message();
  
  // optional .ammo.protocol.PushAcknowledgement push_acknowledgement = 7;
  inline bool has_push_acknowledgement() const;
  inline void clear_push_acknowledgement();
  static const int kPushAcknowledgementFieldNumber = 7;
  inline const ::ammo::protocol::PushAcknowledgement& push_acknowledgement() const;
  inline ::ammo::protocol::PushAcknowledgement* mutable_push_acknowledgement();
  
  // optional .ammo.protocol.PullRequest pull_request = 8;
  inline bool has_pull_request() const;
  inline void clear_pull_request();
  static const int kPullRequestFieldNumber = 8;
  inline const ::ammo::protocol::PullRequest& pull_request() const;
  inline ::ammo::protocol::PullRequest* mutable_pull_request();
  
  // optional .ammo.protocol.PullResponse pull_response = 9;
  inline bool has_pull_response() const;
  inline void clear_pull_response();
  static const int kPullResponseFieldNumber = 9;
  inline const ::ammo::protocol::PullResponse& pull_response() const;
  inline ::ammo::protocol::PullResponse* mutable_pull_response();
  
  // @@protoc_insertion_point(class_scope:ammo.protocol.MessageWrapper)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  ::std::string* session_uuid_;
  static const ::std::string _default_session_uuid_;
  ::ammo::protocol::DataMessage* data_message_;
  ::ammo::protocol::AuthenticationMessage* authentication_message_;
  ::ammo::protocol::AuthenticationResult* authentication_result_;
  ::ammo::protocol::SubscribeMessage* subscribe_message_;
  ::ammo::protocol::PushAcknowledgement* push_acknowledgement_;
  ::ammo::protocol::PullRequest* pull_request_;
  ::ammo::protocol::PullResponse* pull_response_;
  friend void  protobuf_AddDesc_AmmoMessages_2eproto();
  friend void protobuf_AssignDesc_AmmoMessages_2eproto();
  friend void protobuf_ShutdownFile_AmmoMessages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MessageWrapper* default_instance_;
};
// ===================================================================


// ===================================================================

// DataMessage

// required string uri = 1;
inline bool DataMessage::has_uri() const {
  return _has_bit(0);
}
inline void DataMessage::clear_uri() {
  if (uri_ != &_default_uri_) {
    uri_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DataMessage::uri() const {
  return *uri_;
}
inline void DataMessage::set_uri(const ::std::string& value) {
  _set_bit(0);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void DataMessage::set_uri(const char* value) {
  _set_bit(0);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void DataMessage::set_uri(const char* value, size_t size) {
  _set_bit(0);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMessage::mutable_uri() {
  _set_bit(0);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  return uri_;
}

// optional string mime_type = 3;
inline bool DataMessage::has_mime_type() const {
  return _has_bit(1);
}
inline void DataMessage::clear_mime_type() {
  if (mime_type_ != &_default_mime_type_) {
    mime_type_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& DataMessage::mime_type() const {
  return *mime_type_;
}
inline void DataMessage::set_mime_type(const ::std::string& value) {
  _set_bit(1);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void DataMessage::set_mime_type(const char* value) {
  _set_bit(1);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void DataMessage::set_mime_type(const char* value, size_t size) {
  _set_bit(1);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMessage::mutable_mime_type() {
  _set_bit(1);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  return mime_type_;
}

// optional bytes data = 2;
inline bool DataMessage::has_data() const {
  return _has_bit(2);
}
inline void DataMessage::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& DataMessage::data() const {
  return *data_;
}
inline void DataMessage::set_data(const ::std::string& value) {
  _set_bit(2);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void DataMessage::set_data(const char* value) {
  _set_bit(2);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void DataMessage::set_data(const void* value, size_t size) {
  _set_bit(2);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMessage::mutable_data() {
  _set_bit(2);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// -------------------------------------------------------------------

// PushAcknowledgement

// required string uri = 1;
inline bool PushAcknowledgement::has_uri() const {
  return _has_bit(0);
}
inline void PushAcknowledgement::clear_uri() {
  if (uri_ != &_default_uri_) {
    uri_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PushAcknowledgement::uri() const {
  return *uri_;
}
inline void PushAcknowledgement::set_uri(const ::std::string& value) {
  _set_bit(0);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void PushAcknowledgement::set_uri(const char* value) {
  _set_bit(0);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void PushAcknowledgement::set_uri(const char* value, size_t size) {
  _set_bit(0);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PushAcknowledgement::mutable_uri() {
  _set_bit(0);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  return uri_;
}

// -------------------------------------------------------------------

// AuthenticationMessage

// required string device_id = 1;
inline bool AuthenticationMessage::has_device_id() const {
  return _has_bit(0);
}
inline void AuthenticationMessage::clear_device_id() {
  if (device_id_ != &_default_device_id_) {
    device_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& AuthenticationMessage::device_id() const {
  return *device_id_;
}
inline void AuthenticationMessage::set_device_id(const ::std::string& value) {
  _set_bit(0);
  if (device_id_ == &_default_device_id_) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void AuthenticationMessage::set_device_id(const char* value) {
  _set_bit(0);
  if (device_id_ == &_default_device_id_) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void AuthenticationMessage::set_device_id(const char* value, size_t size) {
  _set_bit(0);
  if (device_id_ == &_default_device_id_) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticationMessage::mutable_device_id() {
  _set_bit(0);
  if (device_id_ == &_default_device_id_) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}

// required string user_id = 2;
inline bool AuthenticationMessage::has_user_id() const {
  return _has_bit(1);
}
inline void AuthenticationMessage::clear_user_id() {
  if (user_id_ != &_default_user_id_) {
    user_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AuthenticationMessage::user_id() const {
  return *user_id_;
}
inline void AuthenticationMessage::set_user_id(const ::std::string& value) {
  _set_bit(1);
  if (user_id_ == &_default_user_id_) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void AuthenticationMessage::set_user_id(const char* value) {
  _set_bit(1);
  if (user_id_ == &_default_user_id_) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void AuthenticationMessage::set_user_id(const char* value, size_t size) {
  _set_bit(1);
  if (user_id_ == &_default_user_id_) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticationMessage::mutable_user_id() {
  _set_bit(1);
  if (user_id_ == &_default_user_id_) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}

// required string user_key = 3;
inline bool AuthenticationMessage::has_user_key() const {
  return _has_bit(2);
}
inline void AuthenticationMessage::clear_user_key() {
  if (user_key_ != &_default_user_key_) {
    user_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& AuthenticationMessage::user_key() const {
  return *user_key_;
}
inline void AuthenticationMessage::set_user_key(const ::std::string& value) {
  _set_bit(2);
  if (user_key_ == &_default_user_key_) {
    user_key_ = new ::std::string;
  }
  user_key_->assign(value);
}
inline void AuthenticationMessage::set_user_key(const char* value) {
  _set_bit(2);
  if (user_key_ == &_default_user_key_) {
    user_key_ = new ::std::string;
  }
  user_key_->assign(value);
}
inline void AuthenticationMessage::set_user_key(const char* value, size_t size) {
  _set_bit(2);
  if (user_key_ == &_default_user_key_) {
    user_key_ = new ::std::string;
  }
  user_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticationMessage::mutable_user_key() {
  _set_bit(2);
  if (user_key_ == &_default_user_key_) {
    user_key_ = new ::std::string;
  }
  return user_key_;
}

// -------------------------------------------------------------------

// SubscribeMessage

// required string mime_type = 1;
inline bool SubscribeMessage::has_mime_type() const {
  return _has_bit(0);
}
inline void SubscribeMessage::clear_mime_type() {
  if (mime_type_ != &_default_mime_type_) {
    mime_type_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& SubscribeMessage::mime_type() const {
  return *mime_type_;
}
inline void SubscribeMessage::set_mime_type(const ::std::string& value) {
  _set_bit(0);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void SubscribeMessage::set_mime_type(const char* value) {
  _set_bit(0);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void SubscribeMessage::set_mime_type(const char* value, size_t size) {
  _set_bit(0);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubscribeMessage::mutable_mime_type() {
  _set_bit(0);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  return mime_type_;
}

// optional string query = 2;
inline bool SubscribeMessage::has_query() const {
  return _has_bit(1);
}
inline void SubscribeMessage::clear_query() {
  if (query_ != &_default_query_) {
    query_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SubscribeMessage::query() const {
  return *query_;
}
inline void SubscribeMessage::set_query(const ::std::string& value) {
  _set_bit(1);
  if (query_ == &_default_query_) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void SubscribeMessage::set_query(const char* value) {
  _set_bit(1);
  if (query_ == &_default_query_) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void SubscribeMessage::set_query(const char* value, size_t size) {
  _set_bit(1);
  if (query_ == &_default_query_) {
    query_ = new ::std::string;
  }
  query_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubscribeMessage::mutable_query() {
  _set_bit(1);
  if (query_ == &_default_query_) {
    query_ = new ::std::string;
  }
  return query_;
}

// -------------------------------------------------------------------

// AuthenticationResult

// required .ammo.protocol.AuthenticationResult.Status result = 1;
inline bool AuthenticationResult::has_result() const {
  return _has_bit(0);
}
inline void AuthenticationResult::clear_result() {
  result_ = 0;
  _clear_bit(0);
}
inline ::ammo::protocol::AuthenticationResult_Status AuthenticationResult::result() const {
  return static_cast< ::ammo::protocol::AuthenticationResult_Status >(result_);
}
inline void AuthenticationResult::set_result(::ammo::protocol::AuthenticationResult_Status value) {
  GOOGLE_DCHECK(::ammo::protocol::AuthenticationResult_Status_IsValid(value));
  _set_bit(0);
  result_ = value;
}

// optional string message = 2;
inline bool AuthenticationResult::has_message() const {
  return _has_bit(1);
}
inline void AuthenticationResult::clear_message() {
  if (message_ != &_default_message_) {
    message_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AuthenticationResult::message() const {
  return *message_;
}
inline void AuthenticationResult::set_message(const ::std::string& value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void AuthenticationResult::set_message(const char* value) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void AuthenticationResult::set_message(const char* value, size_t size) {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticationResult::mutable_message() {
  _set_bit(1);
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  return message_;
}

// -------------------------------------------------------------------

// PullRequest

// required string request_uid = 1;
inline bool PullRequest::has_request_uid() const {
  return _has_bit(0);
}
inline void PullRequest::clear_request_uid() {
  if (request_uid_ != &_default_request_uid_) {
    request_uid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PullRequest::request_uid() const {
  return *request_uid_;
}
inline void PullRequest::set_request_uid(const ::std::string& value) {
  _set_bit(0);
  if (request_uid_ == &_default_request_uid_) {
    request_uid_ = new ::std::string;
  }
  request_uid_->assign(value);
}
inline void PullRequest::set_request_uid(const char* value) {
  _set_bit(0);
  if (request_uid_ == &_default_request_uid_) {
    request_uid_ = new ::std::string;
  }
  request_uid_->assign(value);
}
inline void PullRequest::set_request_uid(const char* value, size_t size) {
  _set_bit(0);
  if (request_uid_ == &_default_request_uid_) {
    request_uid_ = new ::std::string;
  }
  request_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PullRequest::mutable_request_uid() {
  _set_bit(0);
  if (request_uid_ == &_default_request_uid_) {
    request_uid_ = new ::std::string;
  }
  return request_uid_;
}

// required string plugin_id = 2;
inline bool PullRequest::has_plugin_id() const {
  return _has_bit(1);
}
inline void PullRequest::clear_plugin_id() {
  if (plugin_id_ != &_default_plugin_id_) {
    plugin_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& PullRequest::plugin_id() const {
  return *plugin_id_;
}
inline void PullRequest::set_plugin_id(const ::std::string& value) {
  _set_bit(1);
  if (plugin_id_ == &_default_plugin_id_) {
    plugin_id_ = new ::std::string;
  }
  plugin_id_->assign(value);
}
inline void PullRequest::set_plugin_id(const char* value) {
  _set_bit(1);
  if (plugin_id_ == &_default_plugin_id_) {
    plugin_id_ = new ::std::string;
  }
  plugin_id_->assign(value);
}
inline void PullRequest::set_plugin_id(const char* value, size_t size) {
  _set_bit(1);
  if (plugin_id_ == &_default_plugin_id_) {
    plugin_id_ = new ::std::string;
  }
  plugin_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PullRequest::mutable_plugin_id() {
  _set_bit(1);
  if (plugin_id_ == &_default_plugin_id_) {
    plugin_id_ = new ::std::string;
  }
  return plugin_id_;
}

// required string mime_type = 3;
inline bool PullRequest::has_mime_type() const {
  return _has_bit(2);
}
inline void PullRequest::clear_mime_type() {
  if (mime_type_ != &_default_mime_type_) {
    mime_type_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& PullRequest::mime_type() const {
  return *mime_type_;
}
inline void PullRequest::set_mime_type(const ::std::string& value) {
  _set_bit(2);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void PullRequest::set_mime_type(const char* value) {
  _set_bit(2);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void PullRequest::set_mime_type(const char* value, size_t size) {
  _set_bit(2);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PullRequest::mutable_mime_type() {
  _set_bit(2);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  return mime_type_;
}

// required string query = 4;
inline bool PullRequest::has_query() const {
  return _has_bit(3);
}
inline void PullRequest::clear_query() {
  if (query_ != &_default_query_) {
    query_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& PullRequest::query() const {
  return *query_;
}
inline void PullRequest::set_query(const ::std::string& value) {
  _set_bit(3);
  if (query_ == &_default_query_) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void PullRequest::set_query(const char* value) {
  _set_bit(3);
  if (query_ == &_default_query_) {
    query_ = new ::std::string;
  }
  query_->assign(value);
}
inline void PullRequest::set_query(const char* value, size_t size) {
  _set_bit(3);
  if (query_ == &_default_query_) {
    query_ = new ::std::string;
  }
  query_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PullRequest::mutable_query() {
  _set_bit(3);
  if (query_ == &_default_query_) {
    query_ = new ::std::string;
  }
  return query_;
}

// optional string projection = 5;
inline bool PullRequest::has_projection() const {
  return _has_bit(4);
}
inline void PullRequest::clear_projection() {
  if (projection_ != &_default_projection_) {
    projection_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& PullRequest::projection() const {
  return *projection_;
}
inline void PullRequest::set_projection(const ::std::string& value) {
  _set_bit(4);
  if (projection_ == &_default_projection_) {
    projection_ = new ::std::string;
  }
  projection_->assign(value);
}
inline void PullRequest::set_projection(const char* value) {
  _set_bit(4);
  if (projection_ == &_default_projection_) {
    projection_ = new ::std::string;
  }
  projection_->assign(value);
}
inline void PullRequest::set_projection(const char* value, size_t size) {
  _set_bit(4);
  if (projection_ == &_default_projection_) {
    projection_ = new ::std::string;
  }
  projection_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PullRequest::mutable_projection() {
  _set_bit(4);
  if (projection_ == &_default_projection_) {
    projection_ = new ::std::string;
  }
  return projection_;
}

// optional uint32 max_results = 6 [default = 0];
inline bool PullRequest::has_max_results() const {
  return _has_bit(5);
}
inline void PullRequest::clear_max_results() {
  max_results_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 PullRequest::max_results() const {
  return max_results_;
}
inline void PullRequest::set_max_results(::google::protobuf::uint32 value) {
  _set_bit(5);
  max_results_ = value;
}

// optional uint32 start_from_count = 7 [default = 0];
inline bool PullRequest::has_start_from_count() const {
  return _has_bit(6);
}
inline void PullRequest::clear_start_from_count() {
  start_from_count_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 PullRequest::start_from_count() const {
  return start_from_count_;
}
inline void PullRequest::set_start_from_count(::google::protobuf::uint32 value) {
  _set_bit(6);
  start_from_count_ = value;
}

// optional bool live_query = 8 [default = false];
inline bool PullRequest::has_live_query() const {
  return _has_bit(7);
}
inline void PullRequest::clear_live_query() {
  live_query_ = false;
  _clear_bit(7);
}
inline bool PullRequest::live_query() const {
  return live_query_;
}
inline void PullRequest::set_live_query(bool value) {
  _set_bit(7);
  live_query_ = value;
}

// -------------------------------------------------------------------

// PullResponse

// required string request_uid = 1;
inline bool PullResponse::has_request_uid() const {
  return _has_bit(0);
}
inline void PullResponse::clear_request_uid() {
  if (request_uid_ != &_default_request_uid_) {
    request_uid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PullResponse::request_uid() const {
  return *request_uid_;
}
inline void PullResponse::set_request_uid(const ::std::string& value) {
  _set_bit(0);
  if (request_uid_ == &_default_request_uid_) {
    request_uid_ = new ::std::string;
  }
  request_uid_->assign(value);
}
inline void PullResponse::set_request_uid(const char* value) {
  _set_bit(0);
  if (request_uid_ == &_default_request_uid_) {
    request_uid_ = new ::std::string;
  }
  request_uid_->assign(value);
}
inline void PullResponse::set_request_uid(const char* value, size_t size) {
  _set_bit(0);
  if (request_uid_ == &_default_request_uid_) {
    request_uid_ = new ::std::string;
  }
  request_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PullResponse::mutable_request_uid() {
  _set_bit(0);
  if (request_uid_ == &_default_request_uid_) {
    request_uid_ = new ::std::string;
  }
  return request_uid_;
}

// required string plugin_id = 2;
inline bool PullResponse::has_plugin_id() const {
  return _has_bit(1);
}
inline void PullResponse::clear_plugin_id() {
  if (plugin_id_ != &_default_plugin_id_) {
    plugin_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& PullResponse::plugin_id() const {
  return *plugin_id_;
}
inline void PullResponse::set_plugin_id(const ::std::string& value) {
  _set_bit(1);
  if (plugin_id_ == &_default_plugin_id_) {
    plugin_id_ = new ::std::string;
  }
  plugin_id_->assign(value);
}
inline void PullResponse::set_plugin_id(const char* value) {
  _set_bit(1);
  if (plugin_id_ == &_default_plugin_id_) {
    plugin_id_ = new ::std::string;
  }
  plugin_id_->assign(value);
}
inline void PullResponse::set_plugin_id(const char* value, size_t size) {
  _set_bit(1);
  if (plugin_id_ == &_default_plugin_id_) {
    plugin_id_ = new ::std::string;
  }
  plugin_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PullResponse::mutable_plugin_id() {
  _set_bit(1);
  if (plugin_id_ == &_default_plugin_id_) {
    plugin_id_ = new ::std::string;
  }
  return plugin_id_;
}

// required string mime_type = 3;
inline bool PullResponse::has_mime_type() const {
  return _has_bit(2);
}
inline void PullResponse::clear_mime_type() {
  if (mime_type_ != &_default_mime_type_) {
    mime_type_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& PullResponse::mime_type() const {
  return *mime_type_;
}
inline void PullResponse::set_mime_type(const ::std::string& value) {
  _set_bit(2);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void PullResponse::set_mime_type(const char* value) {
  _set_bit(2);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void PullResponse::set_mime_type(const char* value, size_t size) {
  _set_bit(2);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PullResponse::mutable_mime_type() {
  _set_bit(2);
  if (mime_type_ == &_default_mime_type_) {
    mime_type_ = new ::std::string;
  }
  return mime_type_;
}

// required string uri = 4;
inline bool PullResponse::has_uri() const {
  return _has_bit(3);
}
inline void PullResponse::clear_uri() {
  if (uri_ != &_default_uri_) {
    uri_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& PullResponse::uri() const {
  return *uri_;
}
inline void PullResponse::set_uri(const ::std::string& value) {
  _set_bit(3);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void PullResponse::set_uri(const char* value) {
  _set_bit(3);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
}
inline void PullResponse::set_uri(const char* value, size_t size) {
  _set_bit(3);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PullResponse::mutable_uri() {
  _set_bit(3);
  if (uri_ == &_default_uri_) {
    uri_ = new ::std::string;
  }
  return uri_;
}

// required bytes data = 5;
inline bool PullResponse::has_data() const {
  return _has_bit(4);
}
inline void PullResponse::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& PullResponse::data() const {
  return *data_;
}
inline void PullResponse::set_data(const ::std::string& value) {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PullResponse::set_data(const char* value) {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PullResponse::set_data(const void* value, size_t size) {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PullResponse::mutable_data() {
  _set_bit(4);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// -------------------------------------------------------------------

// MessageWrapper

// required .ammo.protocol.MessageWrapper.MessageType type = 1;
inline bool MessageWrapper::has_type() const {
  return _has_bit(0);
}
inline void MessageWrapper::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline ::ammo::protocol::MessageWrapper_MessageType MessageWrapper::type() const {
  return static_cast< ::ammo::protocol::MessageWrapper_MessageType >(type_);
}
inline void MessageWrapper::set_type(::ammo::protocol::MessageWrapper_MessageType value) {
  GOOGLE_DCHECK(::ammo::protocol::MessageWrapper_MessageType_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// optional string session_uuid = 2;
inline bool MessageWrapper::has_session_uuid() const {
  return _has_bit(1);
}
inline void MessageWrapper::clear_session_uuid() {
  if (session_uuid_ != &_default_session_uuid_) {
    session_uuid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MessageWrapper::session_uuid() const {
  return *session_uuid_;
}
inline void MessageWrapper::set_session_uuid(const ::std::string& value) {
  _set_bit(1);
  if (session_uuid_ == &_default_session_uuid_) {
    session_uuid_ = new ::std::string;
  }
  session_uuid_->assign(value);
}
inline void MessageWrapper::set_session_uuid(const char* value) {
  _set_bit(1);
  if (session_uuid_ == &_default_session_uuid_) {
    session_uuid_ = new ::std::string;
  }
  session_uuid_->assign(value);
}
inline void MessageWrapper::set_session_uuid(const char* value, size_t size) {
  _set_bit(1);
  if (session_uuid_ == &_default_session_uuid_) {
    session_uuid_ = new ::std::string;
  }
  session_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageWrapper::mutable_session_uuid() {
  _set_bit(1);
  if (session_uuid_ == &_default_session_uuid_) {
    session_uuid_ = new ::std::string;
  }
  return session_uuid_;
}

// optional .ammo.protocol.DataMessage data_message = 3;
inline bool MessageWrapper::has_data_message() const {
  return _has_bit(2);
}
inline void MessageWrapper::clear_data_message() {
  if (data_message_ != NULL) data_message_->::ammo::protocol::DataMessage::Clear();
  _clear_bit(2);
}
inline const ::ammo::protocol::DataMessage& MessageWrapper::data_message() const {
  return data_message_ != NULL ? *data_message_ : *default_instance_->data_message_;
}
inline ::ammo::protocol::DataMessage* MessageWrapper::mutable_data_message() {
  _set_bit(2);
  if (data_message_ == NULL) data_message_ = new ::ammo::protocol::DataMessage;
  return data_message_;
}

// optional .ammo.protocol.AuthenticationMessage authentication_message = 4;
inline bool MessageWrapper::has_authentication_message() const {
  return _has_bit(3);
}
inline void MessageWrapper::clear_authentication_message() {
  if (authentication_message_ != NULL) authentication_message_->::ammo::protocol::AuthenticationMessage::Clear();
  _clear_bit(3);
}
inline const ::ammo::protocol::AuthenticationMessage& MessageWrapper::authentication_message() const {
  return authentication_message_ != NULL ? *authentication_message_ : *default_instance_->authentication_message_;
}
inline ::ammo::protocol::AuthenticationMessage* MessageWrapper::mutable_authentication_message() {
  _set_bit(3);
  if (authentication_message_ == NULL) authentication_message_ = new ::ammo::protocol::AuthenticationMessage;
  return authentication_message_;
}

// optional .ammo.protocol.AuthenticationResult authentication_result = 5;
inline bool MessageWrapper::has_authentication_result() const {
  return _has_bit(4);
}
inline void MessageWrapper::clear_authentication_result() {
  if (authentication_result_ != NULL) authentication_result_->::ammo::protocol::AuthenticationResult::Clear();
  _clear_bit(4);
}
inline const ::ammo::protocol::AuthenticationResult& MessageWrapper::authentication_result() const {
  return authentication_result_ != NULL ? *authentication_result_ : *default_instance_->authentication_result_;
}
inline ::ammo::protocol::AuthenticationResult* MessageWrapper::mutable_authentication_result() {
  _set_bit(4);
  if (authentication_result_ == NULL) authentication_result_ = new ::ammo::protocol::AuthenticationResult;
  return authentication_result_;
}

// optional .ammo.protocol.SubscribeMessage subscribe_message = 6;
inline bool MessageWrapper::has_subscribe_message() const {
  return _has_bit(5);
}
inline void MessageWrapper::clear_subscribe_message() {
  if (subscribe_message_ != NULL) subscribe_message_->::ammo::protocol::SubscribeMessage::Clear();
  _clear_bit(5);
}
inline const ::ammo::protocol::SubscribeMessage& MessageWrapper::subscribe_message() const {
  return subscribe_message_ != NULL ? *subscribe_message_ : *default_instance_->subscribe_message_;
}
inline ::ammo::protocol::SubscribeMessage* MessageWrapper::mutable_subscribe_message() {
  _set_bit(5);
  if (subscribe_message_ == NULL) subscribe_message_ = new ::ammo::protocol::SubscribeMessage;
  return subscribe_message_;
}

// optional .ammo.protocol.PushAcknowledgement push_acknowledgement = 7;
inline bool MessageWrapper::has_push_acknowledgement() const {
  return _has_bit(6);
}
inline void MessageWrapper::clear_push_acknowledgement() {
  if (push_acknowledgement_ != NULL) push_acknowledgement_->::ammo::protocol::PushAcknowledgement::Clear();
  _clear_bit(6);
}
inline const ::ammo::protocol::PushAcknowledgement& MessageWrapper::push_acknowledgement() const {
  return push_acknowledgement_ != NULL ? *push_acknowledgement_ : *default_instance_->push_acknowledgement_;
}
inline ::ammo::protocol::PushAcknowledgement* MessageWrapper::mutable_push_acknowledgement() {
  _set_bit(6);
  if (push_acknowledgement_ == NULL) push_acknowledgement_ = new ::ammo::protocol::PushAcknowledgement;
  return push_acknowledgement_;
}

// optional .ammo.protocol.PullRequest pull_request = 8;
inline bool MessageWrapper::has_pull_request() const {
  return _has_bit(7);
}
inline void MessageWrapper::clear_pull_request() {
  if (pull_request_ != NULL) pull_request_->::ammo::protocol::PullRequest::Clear();
  _clear_bit(7);
}
inline const ::ammo::protocol::PullRequest& MessageWrapper::pull_request() const {
  return pull_request_ != NULL ? *pull_request_ : *default_instance_->pull_request_;
}
inline ::ammo::protocol::PullRequest* MessageWrapper::mutable_pull_request() {
  _set_bit(7);
  if (pull_request_ == NULL) pull_request_ = new ::ammo::protocol::PullRequest;
  return pull_request_;
}

// optional .ammo.protocol.PullResponse pull_response = 9;
inline bool MessageWrapper::has_pull_response() const {
  return _has_bit(8);
}
inline void MessageWrapper::clear_pull_response() {
  if (pull_response_ != NULL) pull_response_->::ammo::protocol::PullResponse::Clear();
  _clear_bit(8);
}
inline const ::ammo::protocol::PullResponse& MessageWrapper::pull_response() const {
  return pull_response_ != NULL ? *pull_response_ : *default_instance_->pull_response_;
}
inline ::ammo::protocol::PullResponse* MessageWrapper::mutable_pull_response() {
  _set_bit(8);
  if (pull_response_ == NULL) pull_response_ = new ::ammo::protocol::PullResponse;
  return pull_response_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace ammo

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ammo::protocol::AuthenticationResult_Status>() {
  return ::ammo::protocol::AuthenticationResult_Status_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ammo::protocol::MessageWrapper_MessageType>() {
  return ::ammo::protocol::MessageWrapper_MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AmmoMessages_2eproto__INCLUDED
